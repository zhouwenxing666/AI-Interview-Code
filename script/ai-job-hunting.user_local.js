// ==UserScript==
// @name         AI工作猎助手纯净版-让ai帮您找工作！
// @namespace    https://github.com/yangfeng20
// @version      0.0.23-beta
// @author       maple.
// @description  找工作，用AI工作猎手！让AI帮您找工作！ai坐席：【DeepSeek+ChatGpt】赋能，ai助理作为您的求职者分身24小时 * 7在线找工作，并结合您的简历信息定制化回复。批量投递，自动发送简历，交换联系方式。hr拒绝挽留。高意向邮件通知，让您不错过每一份工作机会。BOSS直聘
// @license      Apache License 2.0
// @icon         https://gitee.com/yangfeng20/ai-job/raw/master/file/icon.png
// @match        https://www.zhipin.com/web/geek/*
// @match        https://www.zhipin.com/overseas/*
// @require      https://cdn.jsdelivr.net/npm/vue@3.4.21/dist/vue.global.prod.js
// @require      https://unpkg.com/vue-demi@latest/lib/index.iife.js
// @require      data:application/javascript,%3Bwindow.Vue%3DVue%3B
// @require      https://cdn.jsdelivr.net/npm/element-plus@2.7.0/dist/index.full.min.js
// @require      https://cdn.jsdelivr.net/npm/protobufjs@7.2.6/dist/protobuf.min.js
// @require      https://cdn.jsdelivr.net/npm/pinia@2.1.7/dist/pinia.iife.prod.js
// @require      https://cdn.jsdelivr.net/npm/event-source-polyfill@1.0.31/src/eventsource.min.js
// @require      https://cdn.jsdelivr.net/npm/systemjs@6.14.3/dist/system.min.js
// @require      https://cdn.jsdelivr.net/npm/systemjs@6.14.3/dist/extras/named-register.min.js
// @require      data:application/javascript,%3B(typeof%20System!%3D'undefined')%26%26(System%3Dnew%20System.constructor())%3B
// @resource     element-plus/dist/index.css  https://cdn.jsdelivr.net/npm/element-plus@2.7.0/dist/index.css
// @connect      docdownload.zhipin.com
// @connect      api.deepseek.com
// @connect      api.openai.com
// @grant        GM_addStyle
// @grant        GM_addValueChangeListener
// @grant        GM_getResourceText
// @grant        GM_getValue
// @grant        GM_notification
// @grant        GM_setValue
// @grant        GM_xmlhttpRequest
// @grant        unsafeWindow
// ==/UserScript==

(e=>{if(typeof GM_addStyle=="function"){GM_addStyle(e);return}const l=document.createElement("style");l.textContent=e,document.head.append(l)})(` @charset "UTF-8";:root{--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary-rgb:64,158,255;--el-color-success-rgb:103,194,58;--el-color-warning-rgb:230,162,60;--el-color-danger-rgb:245,108,108;--el-color-error-rgb:245,108,108;--el-color-info-rgb:144,147,153;--el-font-size-extra-large:20px;--el-font-size-large:18px;--el-font-size-medium:16px;--el-font-size-base:14px;--el-font-size-small:13px;--el-font-size-extra-small:12px;--el-font-family:"Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","\u5FAE\u8F6F\u96C5\u9ED1",Arial,sans-serif;--el-font-weight-primary:500;--el-font-line-height-primary:24px;--el-index-normal:1;--el-index-top:1000;--el-index-popper:2000;--el-border-radius-base:4px;--el-border-radius-small:2px;--el-border-radius-round:20px;--el-border-radius-circle:100%;--el-transition-duration:.3s;--el-transition-duration-fast:.2s;--el-transition-function-ease-in-out-bezier:cubic-bezier(.645,.045,.355,1);--el-transition-function-fast-bezier:cubic-bezier(.23,1,.32,1);--el-transition-all:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);--el-transition-fade:opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-md-fade:transform var(--el-transition-duration) var(--el-transition-function-fast-bezier),opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-fade-linear:opacity var(--el-transition-duration-fast) linear;--el-transition-border:border-color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-box-shadow:box-shadow var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-color:color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-component-size-large:40px;--el-component-size:32px;--el-component-size-small:24px}:root{color-scheme:light;--el-color-primary:#409eff;--el-color-primary-light-3:#79bbff;--el-color-primary-light-5:#a0cfff;--el-color-primary-light-7:#c6e2ff;--el-color-primary-light-8:#d9ecff;--el-color-primary-light-9:#ecf5ff;--el-color-primary-dark-2:#337ecc;--el-color-success:#67c23a;--el-color-success-light-3:#95d475;--el-color-success-light-5:#b3e19d;--el-color-success-light-7:#d1edc4;--el-color-success-light-8:#e1f3d8;--el-color-success-light-9:#f0f9eb;--el-color-success-dark-2:#529b2e;--el-color-warning:#e6a23c;--el-color-warning-light-3:#eebe77;--el-color-warning-light-5:#f3d19e;--el-color-warning-light-7:#f8e3c5;--el-color-warning-light-8:#faecd8;--el-color-warning-light-9:#fdf6ec;--el-color-warning-dark-2:#b88230;--el-color-danger:#f56c6c;--el-color-danger-light-3:#f89898;--el-color-danger-light-5:#fab6b6;--el-color-danger-light-7:#fcd3d3;--el-color-danger-light-8:#fde2e2;--el-color-danger-light-9:#fef0f0;--el-color-danger-dark-2:#c45656;--el-color-error:#f56c6c;--el-color-error-light-3:#f89898;--el-color-error-light-5:#fab6b6;--el-color-error-light-7:#fcd3d3;--el-color-error-light-8:#fde2e2;--el-color-error-light-9:#fef0f0;--el-color-error-dark-2:#c45656;--el-color-info:#909399;--el-color-info-light-3:#b1b3b8;--el-color-info-light-5:#c8c9cc;--el-color-info-light-7:#dedfe0;--el-color-info-light-8:#e9e9eb;--el-color-info-light-9:#f4f4f5;--el-color-info-dark-2:#73767a;--el-bg-color:#ffffff;--el-bg-color-page:#f2f3f5;--el-bg-color-overlay:#ffffff;--el-text-color-primary:#303133;--el-text-color-regular:#606266;--el-text-color-secondary:#909399;--el-text-color-placeholder:#a8abb2;--el-text-color-disabled:#c0c4cc;--el-border-color:#dcdfe6;--el-border-color-light:#e4e7ed;--el-border-color-lighter:#ebeef5;--el-border-color-extra-light:#f2f6fc;--el-border-color-dark:#d4d7de;--el-border-color-darker:#cdd0d6;--el-fill-color:#f0f2f5;--el-fill-color-light:#f5f7fa;--el-fill-color-lighter:#fafafa;--el-fill-color-extra-light:#fafcff;--el-fill-color-dark:#ebedf0;--el-fill-color-darker:#e6e8eb;--el-fill-color-blank:#ffffff;--el-box-shadow:0px 12px 32px 4px rgba(0,0,0,.04),0px 8px 20px rgba(0,0,0,.08);--el-box-shadow-light:0px 0px 12px rgba(0,0,0,.12);--el-box-shadow-lighter:0px 0px 6px rgba(0,0,0,.12);--el-box-shadow-dark:0px 16px 48px 16px rgba(0,0,0,.08),0px 12px 32px rgba(0,0,0,.12),0px 8px 16px -8px rgba(0,0,0,.16);--el-disabled-bg-color:var(--el-fill-color-light);--el-disabled-text-color:var(--el-text-color-placeholder);--el-disabled-border-color:var(--el-border-color-light);--el-overlay-color:rgba(0,0,0,.8);--el-overlay-color-light:rgba(0,0,0,.7);--el-overlay-color-lighter:rgba(0,0,0,.5);--el-mask-color:rgba(255,255,255,.9);--el-mask-color-extra-light:rgba(255,255,255,.3);--el-border-width:1px;--el-border-style:solid;--el-border-color-hover:var(--el-text-color-disabled);--el-border:var(--el-border-width) var(--el-border-style) var(--el-border-color);--el-svg-monochrome-grey:var(--el-border-color)}.el-icon-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon--right{margin-left:5px}.el-icon--left{margin-right:5px}@-webkit-keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(1turn)}}@keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(1turn)}}.el-icon{--color:inherit;align-items:center;display:inline-flex;height:1em;justify-content:center;line-height:1em;position:relative;width:1em;fill:currentColor;color:var(--color);font-size:inherit}.el-icon.is-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon svg{height:1em;width:1em}:root{--el-popup-modal-bg-color:var(--el-color-black);--el-popup-modal-opacity:.5}.v-modal-enter{-webkit-animation:v-modal-in var(--el-transition-duration-fast) ease;animation:v-modal-in var(--el-transition-duration-fast) ease}.v-modal-leave{-webkit-animation:v-modal-out var(--el-transition-duration-fast) ease forwards;animation:v-modal-out var(--el-transition-duration-fast) ease forwards}@-webkit-keyframes v-modal-in{0%{opacity:0}}@keyframes v-modal-in{0%{opacity:0}}@-webkit-keyframes v-modal-out{to{opacity:0}}@keyframes v-modal-out{to{opacity:0}}.v-modal{background:var(--el-popup-modal-bg-color);height:100%;left:0;opacity:var(--el-popup-modal-opacity);position:fixed;top:0;width:100%}.el-popup-parent--hidden{overflow:hidden}.el-dialog{--el-dialog-width:50%;--el-dialog-margin-top:15vh;--el-dialog-bg-color:var(--el-bg-color);--el-dialog-box-shadow:var(--el-box-shadow);--el-dialog-title-font-size:var(--el-font-size-large);--el-dialog-content-font-size:14px;--el-dialog-font-line-height:var(--el-font-line-height-primary);--el-dialog-padding-primary:16px;--el-dialog-border-radius:var(--el-border-radius-small);background:var(--el-dialog-bg-color);border-radius:var(--el-dialog-border-radius);box-shadow:var(--el-dialog-box-shadow);box-sizing:border-box;margin:var(--el-dialog-margin-top,15vh) auto 50px;overflow-wrap:break-word;padding:var(--el-dialog-padding-primary);position:relative;width:var(--el-dialog-width,50%)}.el-dialog:focus{outline:none!important}.el-dialog.is-align-center{margin:auto}.el-dialog.is-fullscreen{--el-dialog-width:100%;--el-dialog-margin-top:0;height:100%;margin-bottom:0;overflow:auto}.el-dialog__wrapper{bottom:0;left:0;margin:0;overflow:auto;position:fixed;right:0;top:0}.el-dialog.is-draggable .el-dialog__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-dialog__header{padding-bottom:var(--el-dialog-padding-primary)}.el-dialog__header.show-close{padding-right:calc(var(--el-dialog-padding-primary) + var(--el-message-close-size, 16px))}.el-dialog__headerbtn{background:transparent;border:none;cursor:pointer;font-size:var(--el-message-close-size,16px);height:48px;outline:none;padding:0;position:absolute;right:0;top:0;width:48px}.el-dialog__headerbtn .el-dialog__close{color:var(--el-color-info);font-size:inherit}.el-dialog__headerbtn:focus .el-dialog__close,.el-dialog__headerbtn:hover .el-dialog__close{color:var(--el-color-primary)}.el-dialog__title{color:var(--el-text-color-primary);font-size:var(--el-dialog-title-font-size);line-height:var(--el-dialog-font-line-height)}.el-dialog__body{color:var(--el-text-color-regular);font-size:var(--el-dialog-content-font-size)}.el-dialog__footer{box-sizing:border-box;padding-top:var(--el-dialog-padding-primary);text-align:right}.el-dialog--center{text-align:center}.el-dialog--center .el-dialog__body{text-align:initial}.el-dialog--center .el-dialog__footer{text-align:inherit}.el-overlay-dialog{bottom:0;left:0;overflow:auto;position:fixed;right:0;top:0}.dialog-fade-enter-active{-webkit-animation:modal-fade-in var(--el-transition-duration);animation:modal-fade-in var(--el-transition-duration)}.dialog-fade-enter-active .el-overlay-dialog{-webkit-animation:dialog-fade-in var(--el-transition-duration);animation:dialog-fade-in var(--el-transition-duration)}.dialog-fade-leave-active{-webkit-animation:modal-fade-out var(--el-transition-duration);animation:modal-fade-out var(--el-transition-duration)}.dialog-fade-leave-active .el-overlay-dialog{-webkit-animation:dialog-fade-out var(--el-transition-duration);animation:dialog-fade-out var(--el-transition-duration)}@-webkit-keyframes dialog-fade-in{0%{opacity:0;transform:translate3d(0,-20px,0)}to{opacity:1;transform:translateZ(0)}}@keyframes dialog-fade-in{0%{opacity:0;transform:translate3d(0,-20px,0)}to{opacity:1;transform:translateZ(0)}}@-webkit-keyframes dialog-fade-out{0%{opacity:1;transform:translateZ(0)}to{opacity:0;transform:translate3d(0,-20px,0)}}@keyframes dialog-fade-out{0%{opacity:1;transform:translateZ(0)}to{opacity:0;transform:translate3d(0,-20px,0)}}@-webkit-keyframes modal-fade-in{0%{opacity:0}to{opacity:1}}@keyframes modal-fade-in{0%{opacity:0}to{opacity:1}}@-webkit-keyframes modal-fade-out{0%{opacity:1}to{opacity:0}}@keyframes modal-fade-out{0%{opacity:1}to{opacity:0}}.el-overlay{background-color:var(--el-overlay-color-lighter);bottom:0;height:100%;left:0;overflow:auto;position:fixed;right:0;top:0;z-index:2000}.el-overlay .el-overlay-root{height:0}.el-image__error,.el-image__inner,.el-image__placeholder,.el-image__wrapper{height:100%;width:100%}.el-image{display:inline-block;overflow:hidden;position:relative}.el-image__inner{opacity:1;vertical-align:top}.el-image__inner.is-loading{opacity:0}.el-image__wrapper{left:0;position:absolute;top:0}.el-image__error,.el-image__placeholder{background:var(--el-fill-color-light)}.el-image__error{align-items:center;color:var(--el-text-color-placeholder);display:flex;font-size:14px;justify-content:center;vertical-align:middle}.el-image__preview{cursor:pointer}.el-image-viewer__wrapper{bottom:0;left:0;position:fixed;right:0;top:0}.el-image-viewer__btn{align-items:center;border-radius:50%;box-sizing:border-box;cursor:pointer;display:flex;justify-content:center;opacity:.8;position:absolute;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:1}.el-image-viewer__btn .el-icon{cursor:pointer;font-size:inherit}.el-image-viewer__close{font-size:40px;height:40px;right:40px;top:40px;width:40px}.el-image-viewer__canvas{align-items:center;display:flex;height:100%;justify-content:center;position:static;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:100%}.el-image-viewer__actions{background-color:var(--el-text-color-regular);border-color:#fff;border-radius:22px;bottom:30px;height:44px;left:50%;padding:0 23px;transform:translate(-50%);width:282px}.el-image-viewer__actions__inner{align-items:center;color:#fff;cursor:default;display:flex;font-size:23px;height:100%;justify-content:space-around;width:100%}.el-image-viewer__prev{left:40px}.el-image-viewer__next,.el-image-viewer__prev{background-color:var(--el-text-color-regular);border-color:#fff;color:#fff;font-size:24px;height:44px;top:50%;transform:translateY(-50%);width:44px}.el-image-viewer__next{right:40px;text-indent:2px}.el-image-viewer__close{background-color:var(--el-text-color-regular);border-color:#fff;color:#fff;font-size:24px;height:44px;width:44px}.el-image-viewer__mask{background:#000;height:100%;left:0;opacity:.5;position:absolute;top:0;width:100%}.viewer-fade-enter-active{-webkit-animation:viewer-fade-in var(--el-transition-duration);animation:viewer-fade-in var(--el-transition-duration)}.viewer-fade-leave-active{-webkit-animation:viewer-fade-out var(--el-transition-duration);animation:viewer-fade-out var(--el-transition-duration)}@-webkit-keyframes viewer-fade-in{0%{opacity:0;transform:translate3d(0,-20px,0)}to{opacity:1;transform:translateZ(0)}}@keyframes viewer-fade-in{0%{opacity:0;transform:translate3d(0,-20px,0)}to{opacity:1;transform:translateZ(0)}}@-webkit-keyframes viewer-fade-out{0%{opacity:1;transform:translateZ(0)}to{opacity:0;transform:translate3d(0,-20px,0)}}@keyframes viewer-fade-out{0%{opacity:1;transform:translateZ(0)}to{opacity:0;transform:translate3d(0,-20px,0)}}.el-link{--el-link-font-size:var(--el-font-size-base);--el-link-font-weight:var(--el-font-weight-primary);--el-link-text-color:var(--el-text-color-regular);--el-link-hover-text-color:var(--el-color-primary);--el-link-disabled-text-color:var(--el-text-color-placeholder);align-items:center;color:var(--el-link-text-color);cursor:pointer;display:inline-flex;flex-direction:row;font-size:var(--el-link-font-size);font-weight:var(--el-link-font-weight);justify-content:center;outline:none;padding:0;position:relative;text-decoration:none;vertical-align:middle}.el-link:hover{color:var(--el-link-hover-text-color)}.el-link.is-underline:hover:after{border-bottom:1px solid var(--el-link-hover-text-color);bottom:0;content:"";height:0;left:0;position:absolute;right:0}.el-link.is-disabled{color:var(--el-link-disabled-text-color);cursor:not-allowed}.el-link [class*=el-icon-]+span{margin-left:5px}.el-link.el-link--default:after{border-color:var(--el-link-hover-text-color)}.el-link__inner{align-items:center;display:inline-flex;justify-content:center}.el-link.el-link--primary{--el-link-text-color:var(--el-color-primary);--el-link-hover-text-color:var(--el-color-primary-light-3);--el-link-disabled-text-color:var(--el-color-primary-light-5)}.el-link.el-link--primary:after{border-color:var(--el-link-text-color)}.el-link.el-link--primary.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--success{--el-link-text-color:var(--el-color-success);--el-link-hover-text-color:var(--el-color-success-light-3);--el-link-disabled-text-color:var(--el-color-success-light-5)}.el-link.el-link--success:after{border-color:var(--el-link-text-color)}.el-link.el-link--success.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--warning{--el-link-text-color:var(--el-color-warning);--el-link-hover-text-color:var(--el-color-warning-light-3);--el-link-disabled-text-color:var(--el-color-warning-light-5)}.el-link.el-link--warning:after{border-color:var(--el-link-text-color)}.el-link.el-link--warning.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--danger{--el-link-text-color:var(--el-color-danger);--el-link-hover-text-color:var(--el-color-danger-light-3);--el-link-disabled-text-color:var(--el-color-danger-light-5)}.el-link.el-link--danger:after{border-color:var(--el-link-text-color)}.el-link.el-link--danger.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--error{--el-link-text-color:var(--el-color-error);--el-link-hover-text-color:var(--el-color-error-light-3);--el-link-disabled-text-color:var(--el-color-error-light-5)}.el-link.el-link--error:after{border-color:var(--el-link-text-color)}.el-link.el-link--error.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--info{--el-link-text-color:var(--el-color-info);--el-link-hover-text-color:var(--el-color-info-light-3);--el-link-disabled-text-color:var(--el-color-info-light-5)}.el-link.el-link--info:after{border-color:var(--el-link-text-color)}.el-link.el-link--info.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-textarea{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;display:inline-block;font-size:var(--el-font-size-base);position:relative;vertical-align:bottom;width:100%}.el-textarea__inner{-webkit-appearance:none;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;box-sizing:border-box;color:var(--el-input-text-color,var(--el-text-color-regular));display:block;font-family:inherit;font-size:inherit;line-height:1.5;padding:5px 11px;position:relative;resize:vertical;transition:var(--el-transition-box-shadow);width:100%}.el-textarea__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:-ms-input-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-textarea__inner:focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset;outline:none}.el-textarea .el-input__count{background:var(--el-fill-color-blank);bottom:5px;color:var(--el-color-info);font-size:12px;line-height:14px;position:absolute;right:10px}.el-textarea.is-disabled .el-textarea__inner{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset;color:var(--el-disabled-text-color);cursor:not-allowed}.el-textarea.is-disabled .el-textarea__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner::placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-exceed .el-textarea__inner{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-textarea.is-exceed .el-input__count{color:var(--el-color-danger)}.el-input{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;--el-input-height:var(--el-component-size);box-sizing:border-box;display:inline-flex;font-size:var(--el-font-size-base);line-height:var(--el-input-height);position:relative;vertical-align:middle;width:var(--el-input-width)}.el-input::-webkit-scrollbar{width:6px;z-index:11}.el-input::-webkit-scrollbar:horizontal{height:6px}.el-input::-webkit-scrollbar-thumb{background:var(--el-text-color-disabled);border-radius:5px;width:6px}.el-input::-webkit-scrollbar-corner,.el-input::-webkit-scrollbar-track{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track-piece{background:var(--el-fill-color-blank);width:6px}.el-input .el-input__clear,.el-input .el-input__password{color:var(--el-input-icon-color);cursor:pointer;font-size:14px}.el-input .el-input__clear:hover,.el-input .el-input__password:hover{color:var(--el-input-clear-hover-color)}.el-input .el-input__count{align-items:center;color:var(--el-color-info);display:inline-flex;font-size:12px;height:100%}.el-input .el-input__count .el-input__count-inner{background:var(--el-fill-color-blank);display:inline-block;line-height:normal;padding-left:8px}.el-input__wrapper{align-items:center;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;cursor:text;display:inline-flex;flex-grow:1;justify-content:center;padding:1px 11px;transform:translateZ(0);transition:var(--el-transition-box-shadow)}.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 32px) - 2px);-webkit-appearance:none;background:none;border:none;box-sizing:border-box;color:var(--el-input-text-color,var(--el-text-color-regular));flex-grow:1;font-size:inherit;height:var(--el-input-inner-height);line-height:var(--el-input-inner-height);outline:none;padding:0;width:100%}.el-input__inner:focus{outline:none}.el-input__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner:-ms-input-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner[type=password]::-ms-reveal{display:none}.el-input__inner[type=number]{line-height:1}.el-input__prefix{color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:inline-flex;flex-shrink:0;flex-wrap:nowrap;height:100%;pointer-events:none;text-align:center;transition:all var(--el-transition-duration);white-space:nowrap}.el-input__prefix-inner{align-items:center;display:inline-flex;justify-content:center;pointer-events:all}.el-input__prefix-inner>:last-child{margin-right:8px}.el-input__prefix-inner>:first-child,.el-input__prefix-inner>:first-child.el-input__icon{margin-left:0}.el-input__suffix{color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:inline-flex;flex-shrink:0;flex-wrap:nowrap;height:100%;pointer-events:none;text-align:center;transition:all var(--el-transition-duration);white-space:nowrap}.el-input__suffix-inner{align-items:center;display:inline-flex;justify-content:center;pointer-events:all}.el-input__suffix-inner>:first-child{margin-left:8px}.el-input .el-input__icon{align-items:center;display:flex;height:inherit;justify-content:center;line-height:inherit;margin-left:8px;transition:all var(--el-transition-duration)}.el-input__validateIcon{pointer-events:none}.el-input.is-active .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-color, ) inset}.el-input.is-disabled{cursor:not-allowed}.el-input.is-disabled .el-input__wrapper{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset}.el-input.is-disabled .el-input__inner{color:var(--el-disabled-text-color);-webkit-text-fill-color:var(--el-disabled-text-color);cursor:not-allowed}.el-input.is-disabled .el-input__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner::placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__icon{cursor:not-allowed}.el-input.is-exceed .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-input.is-exceed .el-input__suffix .el-input__count{color:var(--el-color-danger)}.el-input--large{--el-input-height:var(--el-component-size-large);font-size:14px}.el-input--large .el-input__wrapper{padding:1px 15px}.el-input--large .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 40px) - 2px)}.el-input--small{--el-input-height:var(--el-component-size-small);font-size:12px}.el-input--small .el-input__wrapper{padding:1px 7px}.el-input--small .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 24px) - 2px)}.el-input-group{align-items:stretch;display:inline-flex;width:100%}.el-input-group__append,.el-input-group__prepend{align-items:center;background-color:var(--el-fill-color-light);border-radius:var(--el-input-border-radius);color:var(--el-color-info);display:inline-flex;justify-content:center;min-height:100%;padding:0 20px;position:relative;white-space:nowrap}.el-input-group__append:focus,.el-input-group__prepend:focus{outline:none}.el-input-group__append .el-button,.el-input-group__append .el-select,.el-input-group__prepend .el-button,.el-input-group__prepend .el-select{display:inline-block;margin:0 -20px}.el-input-group__append button.el-button,.el-input-group__append button.el-button:hover,.el-input-group__append div.el-select .el-select__wrapper,.el-input-group__append div.el-select:hover .el-select__wrapper,.el-input-group__prepend button.el-button,.el-input-group__prepend button.el-button:hover,.el-input-group__prepend div.el-select .el-select__wrapper,.el-input-group__prepend div.el-select:hover .el-select__wrapper{background-color:transparent;border-color:transparent;color:inherit}.el-input-group__append .el-button,.el-input-group__append .el-input,.el-input-group__prepend .el-button,.el-input-group__prepend .el-input{font-size:inherit}.el-input-group__prepend{border-bottom-right-radius:0;border-right:0;border-top-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group__append{border-bottom-left-radius:0;border-left:0;border-top-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--prepend>.el-input__wrapper{border-bottom-left-radius:0;border-top-left-radius:0}.el-input-group--prepend .el-input-group__prepend .el-select .el-select__wrapper{border-bottom-right-radius:0;border-top-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group--append>.el-input__wrapper{border-bottom-right-radius:0;border-top-right-radius:0}.el-input-group--append .el-input-group__append .el-select .el-select__wrapper{border-bottom-left-radius:0;border-top-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-hidden{display:none!important}.el-table{--el-table-border-color:var(--el-border-color-lighter);--el-table-border:1px solid var(--el-table-border-color);--el-table-text-color:var(--el-text-color-regular);--el-table-header-text-color:var(--el-text-color-secondary);--el-table-row-hover-bg-color:var(--el-fill-color-light);--el-table-current-row-bg-color:var(--el-color-primary-light-9);--el-table-header-bg-color:var(--el-bg-color);--el-table-fixed-box-shadow:var(--el-box-shadow-light);--el-table-bg-color:var(--el-fill-color-blank);--el-table-tr-bg-color:var(--el-bg-color);--el-table-expanded-cell-bg-color:var(--el-fill-color-blank);--el-table-fixed-left-column:inset 10px 0 10px -10px rgba(0,0,0,.15);--el-table-fixed-right-column:inset -10px 0 10px -10px rgba(0,0,0,.15);--el-table-index:var(--el-index-normal);background-color:var(--el-table-bg-color);box-sizing:border-box;color:var(--el-table-text-color);font-size:14px;height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;max-width:100%;overflow:hidden;position:relative;width:100%}.el-table__inner-wrapper{display:flex;flex-direction:column;height:100%;position:relative}.el-table__inner-wrapper:before{bottom:0;height:1px;left:0;width:100%}.el-table tbody:focus-visible{outline:none}.el-table.has-footer.el-table--fluid-height tr:last-child td.el-table__cell,.el-table.has-footer.el-table--scrollable-y tr:last-child td.el-table__cell{border-bottom-color:transparent}.el-table__empty-block{align-items:center;display:flex;justify-content:center;left:0;min-height:60px;position:-webkit-sticky;position:sticky;text-align:center;width:100%}.el-table__empty-text{color:var(--el-text-color-secondary);line-height:60px;width:50%}.el-table__expand-column .cell{padding:0;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-table__expand-icon{color:var(--el-text-color-regular);cursor:pointer;font-size:12px;height:20px;position:relative;transition:transform var(--el-transition-duration-fast) ease-in-out}.el-table__expand-icon--expanded{transform:rotate(90deg)}.el-table__expand-icon>.el-icon{font-size:12px}.el-table__expanded-cell{background-color:var(--el-table-expanded-cell-bg-color)}.el-table__expanded-cell[class*=cell]{padding:20px 50px}.el-table__expanded-cell:hover{background-color:transparent!important}.el-table__placeholder{display:inline-block;width:20px}.el-table__append-wrapper{overflow:hidden}.el-table--fit{border-bottom:0;border-right:0}.el-table--fit .el-table__cell.gutter{border-right-width:1px}.el-table thead{color:var(--el-table-header-text-color)}.el-table thead th{font-weight:600}.el-table thead.is-group th.el-table__cell{background:var(--el-fill-color-light)}.el-table .el-table__cell{box-sizing:border-box;min-width:0;padding:8px 0;position:relative;text-align:left;text-overflow:ellipsis;vertical-align:middle;z-index:var(--el-table-index)}.el-table .el-table__cell.is-center{text-align:center}.el-table .el-table__cell.is-right{text-align:right}.el-table .el-table__cell.gutter{border-bottom-width:0;border-right-width:0;padding:0;width:15px}.el-table .el-table__cell.is-hidden>*{visibility:hidden}.el-table .cell{box-sizing:border-box;line-height:23px;overflow:hidden;overflow-wrap:break-word;padding:0 12px;text-overflow:ellipsis;white-space:normal}.el-table .cell.el-tooltip{min-width:50px;white-space:nowrap}.el-table--large{font-size:var(--el-font-size-base)}.el-table--large .el-table__cell{padding:12px 0}.el-table--large .cell{padding:0 16px}.el-table--default{font-size:14px}.el-table--default .el-table__cell{padding:8px 0}.el-table--default .cell{padding:0 12px}.el-table--small{font-size:12px}.el-table--small .el-table__cell{padding:4px 0}.el-table--small .cell{padding:0 8px}.el-table tr{background-color:var(--el-table-tr-bg-color)}.el-table tr input[type=checkbox]{margin:0}.el-table td.el-table__cell,.el-table th.el-table__cell.is-leaf{border-bottom:var(--el-table-border)}.el-table th.el-table__cell.is-sortable{cursor:pointer}.el-table th.el-table__cell{background-color:var(--el-table-header-bg-color);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-table th.el-table__cell>.cell.highlight{color:var(--el-color-primary)}.el-table th.el-table__cell.required>div:before{background:#ff4d51;border-radius:50%;content:"";display:inline-block;height:8px;margin-right:5px;vertical-align:middle;width:8px}.el-table td.el-table__cell div{box-sizing:border-box}.el-table td.el-table__cell.gutter{width:0}.el-table--border .el-table__inner-wrapper:after,.el-table--border:after,.el-table--border:before,.el-table__inner-wrapper:before{background-color:var(--el-table-border-color);content:"";position:absolute;z-index:calc(var(--el-table-index) + 2)}.el-table--border .el-table__inner-wrapper:after{height:1px;left:0;top:0;width:100%;z-index:calc(var(--el-table-index) + 2)}.el-table--border:before{height:100%;left:0;top:-1px;width:1px}.el-table--border:after{height:100%;right:0;top:-1px;width:1px}.el-table--border .el-table__inner-wrapper{border-bottom:none;border-right:none}.el-table--border .el-table__footer-wrapper{flex-shrink:0;position:relative}.el-table--border .el-table__cell{border-right:var(--el-table-border)}.el-table--border th.el-table__cell.gutter:last-of-type{border-bottom:var(--el-table-border);border-bottom-width:1px}.el-table--border th.el-table__cell{border-bottom:var(--el-table-border)}.el-table--hidden{visibility:hidden}.el-table__body-wrapper,.el-table__footer-wrapper,.el-table__header-wrapper{width:100%}.el-table__body-wrapper tr td.el-table-fixed-column--left,.el-table__body-wrapper tr td.el-table-fixed-column--right,.el-table__body-wrapper tr th.el-table-fixed-column--left,.el-table__body-wrapper tr th.el-table-fixed-column--right,.el-table__footer-wrapper tr td.el-table-fixed-column--left,.el-table__footer-wrapper tr td.el-table-fixed-column--right,.el-table__footer-wrapper tr th.el-table-fixed-column--left,.el-table__footer-wrapper tr th.el-table-fixed-column--right,.el-table__header-wrapper tr td.el-table-fixed-column--left,.el-table__header-wrapper tr td.el-table-fixed-column--right,.el-table__header-wrapper tr th.el-table-fixed-column--left,.el-table__header-wrapper tr th.el-table-fixed-column--right{background:inherit;position:-webkit-sticky!important;position:sticky!important;z-index:calc(var(--el-table-index) + 1)}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-last-column:before{bottom:-1px;box-shadow:none;content:"";overflow-x:hidden;overflow-y:hidden;pointer-events:none;position:absolute;top:0;touch-action:none;width:10px}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-first-column:before{left:-10px}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-last-column:before{box-shadow:none;right:-10px}.el-table__body-wrapper tr td.el-table__fixed-right-patch,.el-table__body-wrapper tr th.el-table__fixed-right-patch,.el-table__footer-wrapper tr td.el-table__fixed-right-patch,.el-table__footer-wrapper tr th.el-table__fixed-right-patch,.el-table__header-wrapper tr td.el-table__fixed-right-patch,.el-table__header-wrapper tr th.el-table__fixed-right-patch{background:#fff;position:-webkit-sticky!important;position:sticky!important;right:0;z-index:calc(var(--el-table-index) + 1)}.el-table__header-wrapper{flex-shrink:0}.el-table__header-wrapper tr th.el-table-fixed-column--left,.el-table__header-wrapper tr th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table__body,.el-table__footer,.el-table__header{border-collapse:separate;table-layout:fixed}.el-table__header-wrapper{overflow:hidden}.el-table__header-wrapper tbody td.el-table__cell{background-color:var(--el-table-row-hover-bg-color);color:var(--el-table-text-color)}.el-table__footer-wrapper{flex-shrink:0;overflow:hidden}.el-table__footer-wrapper tfoot td.el-table__cell{background-color:var(--el-table-row-hover-bg-color);color:var(--el-table-text-color)}.el-table__body-wrapper .el-table-column--selection>.cell,.el-table__header-wrapper .el-table-column--selection>.cell{align-items:center;display:inline-flex;height:23px}.el-table__body-wrapper .el-table-column--selection .el-checkbox,.el-table__header-wrapper .el-table-column--selection .el-checkbox{height:unset}.el-table.is-scrolling-left .el-table-fixed-column--right.is-first-column:before{box-shadow:var(--el-table-fixed-right-column)}.el-table.is-scrolling-left.el-table--border .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:var(--el-table-border)}.el-table.is-scrolling-left th.el-table-fixed-column--left{background-color:var(--el-table-header-bg-color)}.el-table.is-scrolling-right .el-table-fixed-column--left.is-last-column:before{box-shadow:var(--el-table-fixed-left-column)}.el-table.is-scrolling-right .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:none}.el-table.is-scrolling-right th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table.is-scrolling-middle .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:none}.el-table.is-scrolling-middle .el-table-fixed-column--right.is-first-column:before{box-shadow:var(--el-table-fixed-right-column)}.el-table.is-scrolling-middle .el-table-fixed-column--left.is-last-column:before{box-shadow:var(--el-table-fixed-left-column)}.el-table.is-scrolling-none .el-table-fixed-column--left.is-first-column:before,.el-table.is-scrolling-none .el-table-fixed-column--left.is-last-column:before,.el-table.is-scrolling-none .el-table-fixed-column--right.is-first-column:before,.el-table.is-scrolling-none .el-table-fixed-column--right.is-last-column:before{box-shadow:none}.el-table.is-scrolling-none th.el-table-fixed-column--left,.el-table.is-scrolling-none th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table__body-wrapper{flex:1;overflow:hidden;position:relative}.el-table__body-wrapper .el-scrollbar__bar{z-index:calc(var(--el-table-index) + 2)}.el-table .caret-wrapper{align-items:center;cursor:pointer;display:inline-flex;flex-direction:column;height:14px;overflow:initial;position:relative;vertical-align:middle;width:24px}.el-table .sort-caret{border:5px solid transparent;height:0;left:7px;position:absolute;width:0}.el-table .sort-caret.ascending{border-bottom-color:var(--el-text-color-placeholder);top:-5px}.el-table .sort-caret.descending{border-top-color:var(--el-text-color-placeholder);bottom:-3px}.el-table .ascending .sort-caret.ascending{border-bottom-color:var(--el-color-primary)}.el-table .descending .sort-caret.descending{border-top-color:var(--el-color-primary)}.el-table .hidden-columns{position:absolute;visibility:hidden;z-index:-1}.el-table--striped .el-table__body tr.el-table__row--striped td.el-table__cell{background:var(--el-fill-color-lighter)}.el-table--striped .el-table__body tr.el-table__row--striped.current-row td.el-table__cell{background-color:var(--el-table-current-row-bg-color)}.el-table__body tr.hover-row.current-row>td.el-table__cell,.el-table__body tr.hover-row.el-table__row--striped.current-row>td.el-table__cell,.el-table__body tr.hover-row.el-table__row--striped>td.el-table__cell,.el-table__body tr.hover-row>td.el-table__cell{background-color:var(--el-table-row-hover-bg-color)}.el-table__body tr>td.hover-cell{background-color:var(--el-table-row-hover-bg-color)}.el-table__body tr.current-row>td.el-table__cell{background-color:var(--el-table-current-row-bg-color)}.el-table.el-table--scrollable-y .el-table__body-header{position:-webkit-sticky;position:sticky;top:0;z-index:calc(var(--el-table-index) + 2)}.el-table.el-table--scrollable-y .el-table__body-footer{bottom:0;position:-webkit-sticky;position:sticky;z-index:calc(var(--el-table-index) + 2)}.el-table__column-resize-proxy{border-left:var(--el-table-border);bottom:0;left:200px;position:absolute;top:0;width:0;z-index:calc(var(--el-table-index) + 9)}.el-table__column-filter-trigger{cursor:pointer;display:inline-block}.el-table__column-filter-trigger i{color:var(--el-color-info);font-size:14px;vertical-align:middle}.el-table__border-left-patch{height:100%;top:0;width:1px}.el-table__border-bottom-patch,.el-table__border-left-patch{background-color:var(--el-table-border-color);left:0;position:absolute;z-index:calc(var(--el-table-index) + 2)}.el-table__border-bottom-patch{height:1px}.el-table__border-right-patch{background-color:var(--el-table-border-color);height:100%;position:absolute;top:0;width:1px;z-index:calc(var(--el-table-index) + 2)}.el-table--enable-row-transition .el-table__body td.el-table__cell{transition:background-color .25s ease}.el-table--enable-row-hover .el-table__body tr:hover>td.el-table__cell{background-color:var(--el-table-row-hover-bg-color)}.el-table [class*=el-table__row--level] .el-table__expand-icon{display:inline-block;height:12px;line-height:12px;margin-right:8px;text-align:center;width:12px}.el-table .el-table.el-table--border .el-table__cell{border-right:var(--el-table-border)}.el-table:not(.el-table--border) .el-table__cell{border-right:none}.el-table:not(.el-table--border)>.el-table__inner-wrapper:after{content:none}.el-checkbox{--el-checkbox-font-size:14px;--el-checkbox-font-weight:var(--el-font-weight-primary);--el-checkbox-text-color:var(--el-text-color-regular);--el-checkbox-input-height:14px;--el-checkbox-input-width:14px;--el-checkbox-border-radius:var(--el-border-radius-small);--el-checkbox-bg-color:var(--el-fill-color-blank);--el-checkbox-input-border:var(--el-border);--el-checkbox-disabled-border-color:var(--el-border-color);--el-checkbox-disabled-input-fill:var(--el-fill-color-light);--el-checkbox-disabled-icon-color:var(--el-text-color-placeholder);--el-checkbox-disabled-checked-input-fill:var(--el-border-color-extra-light);--el-checkbox-disabled-checked-input-border-color:var(--el-border-color);--el-checkbox-disabled-checked-icon-color:var(--el-text-color-placeholder);--el-checkbox-checked-text-color:var(--el-color-primary);--el-checkbox-checked-input-border-color:var(--el-color-primary);--el-checkbox-checked-bg-color:var(--el-color-primary);--el-checkbox-checked-icon-color:var(--el-color-white);--el-checkbox-input-border-color-hover:var(--el-color-primary);align-items:center;color:var(--el-checkbox-text-color);cursor:pointer;display:inline-flex;font-size:var(--el-font-size-base);font-weight:var(--el-checkbox-font-weight);height:var(--el-checkbox-height,32px);margin-right:30px;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;white-space:nowrap}.el-checkbox.is-disabled{cursor:not-allowed}.el-checkbox.is-bordered{border:var(--el-border);border-radius:var(--el-border-radius-base);box-sizing:border-box;padding:0 15px 0 9px}.el-checkbox.is-bordered.is-checked{border-color:var(--el-color-primary)}.el-checkbox.is-bordered.is-disabled{border-color:var(--el-border-color-lighter)}.el-checkbox.is-bordered.el-checkbox--large{border-radius:var(--el-border-radius-base);padding:0 19px 0 11px}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__label{font-size:var(--el-font-size-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__inner{height:14px;width:14px}.el-checkbox.is-bordered.el-checkbox--small{border-radius:calc(var(--el-border-radius-base) - 1px);padding:0 11px 0 7px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner{height:12px;width:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner:after{height:6px;width:2px}.el-checkbox input:focus-visible+.el-checkbox__inner{border-radius:var(--el-checkbox-border-radius);outline:2px solid var(--el-checkbox-input-border-color-hover);outline-offset:1px}.el-checkbox__input{cursor:pointer;display:inline-flex;outline:none;position:relative;white-space:nowrap}.el-checkbox__input.is-disabled .el-checkbox__inner{background-color:var(--el-checkbox-disabled-input-fill);border-color:var(--el-checkbox-disabled-border-color);cursor:not-allowed}.el-checkbox__input.is-disabled .el-checkbox__inner:after{border-color:var(--el-checkbox-disabled-icon-color);cursor:not-allowed}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner:after{border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner:before{background-color:var(--el-checkbox-disabled-checked-icon-color);border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled+span.el-checkbox__label{color:var(--el-disabled-text-color);cursor:not-allowed}.el-checkbox__input.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-checked .el-checkbox__inner:after{border-color:var(--el-checkbox-checked-icon-color);transform:rotate(45deg) scaleY(1)}.el-checkbox__input.is-checked+.el-checkbox__label{color:var(--el-checkbox-checked-text-color)}.el-checkbox__input.is-focus:not(.is-checked) .el-checkbox__original:not(:focus-visible){border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__input.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-indeterminate .el-checkbox__inner:before{background-color:var(--el-checkbox-checked-icon-color);content:"";display:block;height:2px;left:0;position:absolute;right:0;top:5px;transform:scale(.5)}.el-checkbox__input.is-indeterminate .el-checkbox__inner:after{display:none}.el-checkbox__inner{background-color:var(--el-checkbox-bg-color);border:var(--el-checkbox-input-border);border-radius:var(--el-checkbox-border-radius);box-sizing:border-box;display:inline-block;height:var(--el-checkbox-input-height);position:relative;transition:border-color .25s cubic-bezier(.71,-.46,.29,1.46),background-color .25s cubic-bezier(.71,-.46,.29,1.46),outline .25s cubic-bezier(.71,-.46,.29,1.46);width:var(--el-checkbox-input-width);z-index:var(--el-index-normal)}.el-checkbox__inner:hover{border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__inner:after{border:1px solid transparent;border-left:0;border-top:0;box-sizing:content-box;content:"";height:7px;left:4px;position:absolute;top:1px;transform:rotate(45deg) scaleY(0);transform-origin:center;transition:transform .15s ease-in .05s;width:3px}.el-checkbox__original{height:0;margin:0;opacity:0;outline:none;position:absolute;width:0;z-index:-1}.el-checkbox__label{display:inline-block;font-size:var(--el-checkbox-font-size);line-height:1;padding-left:8px}.el-checkbox.el-checkbox--large{height:40px}.el-checkbox.el-checkbox--large .el-checkbox__label{font-size:14px}.el-checkbox.el-checkbox--large .el-checkbox__inner{height:14px;width:14px}.el-checkbox.el-checkbox--small{height:24px}.el-checkbox.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.el-checkbox--small .el-checkbox__inner{height:12px;width:12px}.el-checkbox.el-checkbox--small .el-checkbox__input.is-indeterminate .el-checkbox__inner:before{top:4px}.el-checkbox.el-checkbox--small .el-checkbox__inner:after{height:6px;width:2px}.el-checkbox:last-of-type{margin-right:0}.el-popper{--el-popper-border-radius:var(--el-popover-border-radius,4px);border-radius:var(--el-popper-border-radius);font-size:12px;line-height:20px;min-width:10px;overflow-wrap:break-word;padding:5px 11px;position:absolute;visibility:visible;z-index:2000}.el-popper.is-dark{background:var(--el-text-color-primary);border:1px solid var(--el-text-color-primary);color:var(--el-bg-color)}.el-popper.is-dark .el-popper__arrow:before{background:var(--el-text-color-primary);border:1px solid var(--el-text-color-primary);right:0}.el-popper.is-light{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light)}.el-popper.is-light .el-popper__arrow:before{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);right:0}.el-popper.is-pure{padding:0}.el-popper__arrow{height:10px;position:absolute;width:10px;z-index:-1}.el-popper__arrow:before{background:var(--el-text-color-primary);box-sizing:border-box;content:" ";height:10px;position:absolute;transform:rotate(45deg);width:10px;z-index:-1}.el-popper[data-popper-placement^=top]>.el-popper__arrow{bottom:-5px}.el-popper[data-popper-placement^=top]>.el-popper__arrow:before{border-bottom-right-radius:2px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow{top:-5px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow:before{border-top-left-radius:2px}.el-popper[data-popper-placement^=left]>.el-popper__arrow{right:-5px}.el-popper[data-popper-placement^=left]>.el-popper__arrow:before{border-top-right-radius:2px}.el-popper[data-popper-placement^=right]>.el-popper__arrow{left:-5px}.el-popper[data-popper-placement^=right]>.el-popper__arrow:before{border-bottom-left-radius:2px}.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-left-color:transparent!important;border-top-color:transparent!important}.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent!important;border-right-color:transparent!important}.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-bottom-color:transparent!important;border-left-color:transparent!important}.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent!important;border-top-color:transparent!important}.el-scrollbar{--el-scrollbar-opacity:.3;--el-scrollbar-bg-color:var(--el-text-color-secondary);--el-scrollbar-hover-opacity:.5;--el-scrollbar-hover-bg-color:var(--el-text-color-secondary);height:100%;overflow:hidden;position:relative}.el-scrollbar__wrap{height:100%;overflow:auto}.el-scrollbar__wrap--hidden-default{scrollbar-width:none}.el-scrollbar__wrap--hidden-default::-webkit-scrollbar{display:none}.el-scrollbar__thumb{background-color:var(--el-scrollbar-bg-color,var(--el-text-color-secondary));border-radius:inherit;cursor:pointer;display:block;height:0;opacity:var(--el-scrollbar-opacity,.3);position:relative;transition:var(--el-transition-duration) background-color;width:0}.el-scrollbar__thumb:hover{background-color:var(--el-scrollbar-hover-bg-color,var(--el-text-color-secondary));opacity:var(--el-scrollbar-hover-opacity,.5)}.el-scrollbar__bar{border-radius:4px;bottom:2px;position:absolute;right:2px;z-index:1}.el-scrollbar__bar.is-vertical{top:2px;width:6px}.el-scrollbar__bar.is-vertical>div{width:100%}.el-scrollbar__bar.is-horizontal{height:6px;left:2px}.el-scrollbar__bar.is-horizontal>div{height:100%}.el-scrollbar-fade-enter-active{transition:opacity .34s ease-out}.el-scrollbar-fade-leave-active{transition:opacity .12s ease-out}.el-scrollbar-fade-enter-from,.el-scrollbar-fade-leave-active{opacity:0}.el-tag{--el-tag-font-size:12px;--el-tag-border-radius:4px;--el-tag-border-radius-rounded:9999px;--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary);align-items:center;background-color:var(--el-tag-bg-color);border-color:var(--el-tag-border-color);border-radius:var(--el-tag-border-radius);border-style:solid;border-width:1px;box-sizing:border-box;color:var(--el-tag-text-color);display:inline-flex;font-size:var(--el-tag-font-size);height:24px;justify-content:center;line-height:1;padding:0 9px;vertical-align:middle;white-space:nowrap;--el-icon-size:14px}.el-tag.el-tag--primary{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-bg-color:var(--el-color-success-light-9);--el-tag-border-color:var(--el-color-success-light-8);--el-tag-hover-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-bg-color:var(--el-color-warning-light-9);--el-tag-border-color:var(--el-color-warning-light-8);--el-tag-hover-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-bg-color:var(--el-color-danger-light-9);--el-tag-border-color:var(--el-color-danger-light-8);--el-tag-hover-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-bg-color:var(--el-color-error-light-9);--el-tag-border-color:var(--el-color-error-light-8);--el-tag-hover-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-bg-color:var(--el-color-info-light-9);--el-tag-border-color:var(--el-color-info-light-8);--el-tag-hover-color:var(--el-color-info)}.el-tag.el-tag--primary{--el-tag-text-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-text-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-text-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-text-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-text-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-text-color:var(--el-color-info)}.el-tag.is-hit{border-color:var(--el-color-primary)}.el-tag.is-round{border-radius:var(--el-tag-border-radius-rounded)}.el-tag .el-tag__close{color:var(--el-tag-text-color);flex-shrink:0}.el-tag .el-tag__close:hover{background-color:var(--el-tag-hover-color);color:var(--el-color-white)}.el-tag .el-icon{border-radius:50%;cursor:pointer;font-size:calc(var(--el-icon-size) - 2px);height:var(--el-icon-size);width:var(--el-icon-size)}.el-tag .el-tag__close{margin-left:6px}.el-tag--dark{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3);--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--primary{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3)}.el-tag--dark.el-tag--success{--el-tag-bg-color:var(--el-color-success);--el-tag-border-color:var(--el-color-success);--el-tag-hover-color:var(--el-color-success-light-3)}.el-tag--dark.el-tag--warning{--el-tag-bg-color:var(--el-color-warning);--el-tag-border-color:var(--el-color-warning);--el-tag-hover-color:var(--el-color-warning-light-3)}.el-tag--dark.el-tag--danger{--el-tag-bg-color:var(--el-color-danger);--el-tag-border-color:var(--el-color-danger);--el-tag-hover-color:var(--el-color-danger-light-3)}.el-tag--dark.el-tag--error{--el-tag-bg-color:var(--el-color-error);--el-tag-border-color:var(--el-color-error);--el-tag-hover-color:var(--el-color-error-light-3)}.el-tag--dark.el-tag--info{--el-tag-bg-color:var(--el-color-info);--el-tag-border-color:var(--el-color-info);--el-tag-hover-color:var(--el-color-info-light-3)}.el-tag--dark.el-tag--danger,.el-tag--dark.el-tag--error,.el-tag--dark.el-tag--info,.el-tag--dark.el-tag--primary,.el-tag--dark.el-tag--success,.el-tag--dark.el-tag--warning{--el-tag-text-color:var(--el-color-white)}.el-tag--plain{--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary);--el-tag-bg-color:var(--el-fill-color-blank)}.el-tag--plain.el-tag--primary{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary)}.el-tag--plain.el-tag--success{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-success-light-5);--el-tag-hover-color:var(--el-color-success)}.el-tag--plain.el-tag--warning{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-warning-light-5);--el-tag-hover-color:var(--el-color-warning)}.el-tag--plain.el-tag--danger{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-danger-light-5);--el-tag-hover-color:var(--el-color-danger)}.el-tag--plain.el-tag--error{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-error-light-5);--el-tag-hover-color:var(--el-color-error)}.el-tag--plain.el-tag--info{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-info-light-5);--el-tag-hover-color:var(--el-color-info)}.el-tag.is-closable{padding-right:5px}.el-tag--large{height:32px;padding:0 11px;--el-icon-size:16px}.el-tag--large .el-tag__close{margin-left:8px}.el-tag--large.is-closable{padding-right:7px}.el-tag--small{height:20px;padding:0 7px;--el-icon-size:12px}.el-tag--small .el-tag__close{margin-left:4px}.el-tag--small.is-closable{padding-right:3px}.el-tag--small .el-icon-close{transform:scale(.8)}.el-tag.el-tag--primary.is-hit{border-color:var(--el-color-primary)}.el-tag.el-tag--success.is-hit{border-color:var(--el-color-success)}.el-tag.el-tag--warning.is-hit{border-color:var(--el-color-warning)}.el-tag.el-tag--danger.is-hit{border-color:var(--el-color-danger)}.el-tag.el-tag--error.is-hit{border-color:var(--el-color-error)}.el-tag.el-tag--info.is-hit{border-color:var(--el-color-info)}.el-table-column--selection .cell{padding-left:14px;padding-right:14px}.el-table-filter{background-color:#fff;border:1px solid var(--el-border-color-lighter);border-radius:2px;box-shadow:var(--el-box-shadow-light);box-sizing:border-box}.el-table-filter__list{list-style:none;margin:0;min-width:100px;padding:5px 0}.el-table-filter__list-item{cursor:pointer;font-size:var(--el-font-size-base);line-height:36px;padding:0 10px}.el-table-filter__list-item:hover{background-color:var(--el-color-primary-light-9);color:var(--el-color-primary)}.el-table-filter__list-item.is-active{background-color:var(--el-color-primary);color:#fff}.el-table-filter__content{min-width:100px}.el-table-filter__bottom{border-top:1px solid var(--el-border-color-lighter);padding:8px}.el-table-filter__bottom button{background:transparent;border:none;color:var(--el-text-color-regular);cursor:pointer;font-size:var(--el-font-size-small);padding:0 3px}.el-table-filter__bottom button:hover{color:var(--el-color-primary)}.el-table-filter__bottom button:focus{outline:none}.el-table-filter__bottom button.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-table-filter__wrap{max-height:280px}.el-table-filter__checkbox-group{padding:10px}.el-table-filter__checkbox-group label.el-checkbox{align-items:center;display:flex;height:unset;margin-bottom:12px;margin-left:5px;margin-right:5px}.el-table-filter__checkbox-group .el-checkbox:last-child{margin-bottom:0}.el-button{--el-button-font-weight:var(--el-font-weight-primary);--el-button-border-color:var(--el-border-color);--el-button-bg-color:var(--el-fill-color-blank);--el-button-text-color:var(--el-text-color-regular);--el-button-disabled-text-color:var(--el-disabled-text-color);--el-button-disabled-bg-color:var(--el-fill-color-blank);--el-button-disabled-border-color:var(--el-border-color-light);--el-button-divide-border-color:rgba(255,255,255,.5);--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-color-primary-light-9);--el-button-hover-border-color:var(--el-color-primary-light-7);--el-button-active-text-color:var(--el-button-hover-text-color);--el-button-active-border-color:var(--el-color-primary);--el-button-active-bg-color:var(--el-button-hover-bg-color);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-hover-link-text-color:var(--el-color-info);--el-button-active-color:var(--el-text-color-primary);align-items:center;-webkit-appearance:none;background-color:var(--el-button-bg-color);border:var(--el-border);border-color:var(--el-button-border-color);border-radius:var(--el-border-radius-base);box-sizing:border-box;color:var(--el-button-text-color);cursor:pointer;display:inline-flex;font-size:var(--el-font-size-base);font-weight:var(--el-button-font-weight);height:32px;justify-content:center;line-height:1;outline:none;padding:8px 15px;text-align:center;transition:.1s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;white-space:nowrap}.el-button:hover{background-color:var(--el-button-hover-bg-color);border-color:var(--el-button-hover-border-color);color:var(--el-button-hover-text-color);outline:none}.el-button:active{background-color:var(--el-button-active-bg-color);border-color:var(--el-button-active-border-color);color:var(--el-button-active-text-color);outline:none}.el-button:focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px;transition:outline-offset 0s,outline 0s}.el-button>span{align-items:center;display:inline-flex}.el-button+.el-button{margin-left:12px}.el-button.is-round{padding:8px 15px}.el-button::-moz-focus-inner{border:0}.el-button [class*=el-icon]+span{margin-left:6px}.el-button [class*=el-icon] svg{vertical-align:bottom}.el-button.is-plain{--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-fill-color-blank);--el-button-hover-border-color:var(--el-color-primary)}.el-button.is-active{background-color:var(--el-button-active-bg-color);border-color:var(--el-button-active-border-color);color:var(--el-button-active-text-color);outline:none}.el-button.is-disabled,.el-button.is-disabled:hover{background-color:var(--el-button-disabled-bg-color);background-image:none;border-color:var(--el-button-disabled-border-color);color:var(--el-button-disabled-text-color);cursor:not-allowed}.el-button.is-loading{pointer-events:none;position:relative}.el-button.is-loading:before{background-color:var(--el-mask-color-extra-light);border-radius:inherit;bottom:-1px;content:"";left:-1px;pointer-events:none;position:absolute;right:-1px;top:-1px;z-index:1}.el-button.is-round{border-radius:var(--el-border-radius-round)}.el-button.is-circle{border-radius:50%;padding:8px;width:32px}.el-button.is-text{background-color:transparent;border:0 solid transparent;color:var(--el-button-text-color)}.el-button.is-text.is-disabled{background-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button.is-text:not(.is-disabled):hover{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled):focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px;transition:outline-offset 0s,outline 0s}.el-button.is-text:not(.is-disabled):active{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled).is-has-bg:hover{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg:active{background-color:var(--el-fill-color-dark)}.el-button__text--expand{letter-spacing:.3em;margin-right:-.3em}.el-button.is-link{background:transparent;border-color:transparent;color:var(--el-button-text-color);height:auto;padding:2px}.el-button.is-link:hover{color:var(--el-button-hover-link-text-color)}.el-button.is-link.is-disabled{background-color:transparent!important;border-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button.is-link:not(.is-disabled):hover{background-color:transparent;border-color:transparent}.el-button.is-link:not(.is-disabled):active{background-color:transparent;border-color:transparent;color:var(--el-button-active-color)}.el-button--text{background:transparent;border-color:transparent;color:var(--el-color-primary);padding-left:0;padding-right:0}.el-button--text.is-disabled{background-color:transparent!important;border-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button--text:not(.is-disabled):hover{background-color:transparent;border-color:transparent;color:var(--el-color-primary-light-3)}.el-button--text:not(.is-disabled):active{background-color:transparent;border-color:transparent;color:var(--el-color-primary-dark-2)}.el-button__link--expand{letter-spacing:.3em;margin-right:-.3em}.el-button--primary{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-primary);--el-button-border-color:var(--el-color-primary);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-active-color:var(--el-color-primary-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-primary-light-5);--el-button-hover-bg-color:var(--el-color-primary-light-3);--el-button-hover-border-color:var(--el-color-primary-light-3);--el-button-active-bg-color:var(--el-color-primary-dark-2);--el-button-active-border-color:var(--el-color-primary-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-primary-light-5);--el-button-disabled-border-color:var(--el-color-primary-light-5)}.el-button--primary.is-link,.el-button--primary.is-plain,.el-button--primary.is-text{--el-button-text-color:var(--el-color-primary);--el-button-bg-color:var(--el-color-primary-light-9);--el-button-border-color:var(--el-color-primary-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-primary);--el-button-hover-border-color:var(--el-color-primary);--el-button-active-text-color:var(--el-color-white)}.el-button--primary.is-link.is-disabled,.el-button--primary.is-link.is-disabled:active,.el-button--primary.is-link.is-disabled:focus,.el-button--primary.is-link.is-disabled:hover,.el-button--primary.is-plain.is-disabled,.el-button--primary.is-plain.is-disabled:active,.el-button--primary.is-plain.is-disabled:focus,.el-button--primary.is-plain.is-disabled:hover,.el-button--primary.is-text.is-disabled,.el-button--primary.is-text.is-disabled:active,.el-button--primary.is-text.is-disabled:focus,.el-button--primary.is-text.is-disabled:hover{background-color:var(--el-color-primary-light-9);border-color:var(--el-color-primary-light-8);color:var(--el-color-primary-light-5)}.el-button--success{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-success);--el-button-border-color:var(--el-color-success);--el-button-outline-color:var(--el-color-success-light-5);--el-button-active-color:var(--el-color-success-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-success-light-5);--el-button-hover-bg-color:var(--el-color-success-light-3);--el-button-hover-border-color:var(--el-color-success-light-3);--el-button-active-bg-color:var(--el-color-success-dark-2);--el-button-active-border-color:var(--el-color-success-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-success-light-5);--el-button-disabled-border-color:var(--el-color-success-light-5)}.el-button--success.is-link,.el-button--success.is-plain,.el-button--success.is-text{--el-button-text-color:var(--el-color-success);--el-button-bg-color:var(--el-color-success-light-9);--el-button-border-color:var(--el-color-success-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-success);--el-button-hover-border-color:var(--el-color-success);--el-button-active-text-color:var(--el-color-white)}.el-button--success.is-link.is-disabled,.el-button--success.is-link.is-disabled:active,.el-button--success.is-link.is-disabled:focus,.el-button--success.is-link.is-disabled:hover,.el-button--success.is-plain.is-disabled,.el-button--success.is-plain.is-disabled:active,.el-button--success.is-plain.is-disabled:focus,.el-button--success.is-plain.is-disabled:hover,.el-button--success.is-text.is-disabled,.el-button--success.is-text.is-disabled:active,.el-button--success.is-text.is-disabled:focus,.el-button--success.is-text.is-disabled:hover{background-color:var(--el-color-success-light-9);border-color:var(--el-color-success-light-8);color:var(--el-color-success-light-5)}.el-button--warning{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-warning);--el-button-border-color:var(--el-color-warning);--el-button-outline-color:var(--el-color-warning-light-5);--el-button-active-color:var(--el-color-warning-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-warning-light-5);--el-button-hover-bg-color:var(--el-color-warning-light-3);--el-button-hover-border-color:var(--el-color-warning-light-3);--el-button-active-bg-color:var(--el-color-warning-dark-2);--el-button-active-border-color:var(--el-color-warning-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-warning-light-5);--el-button-disabled-border-color:var(--el-color-warning-light-5)}.el-button--warning.is-link,.el-button--warning.is-plain,.el-button--warning.is-text{--el-button-text-color:var(--el-color-warning);--el-button-bg-color:var(--el-color-warning-light-9);--el-button-border-color:var(--el-color-warning-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-warning);--el-button-hover-border-color:var(--el-color-warning);--el-button-active-text-color:var(--el-color-white)}.el-button--warning.is-link.is-disabled,.el-button--warning.is-link.is-disabled:active,.el-button--warning.is-link.is-disabled:focus,.el-button--warning.is-link.is-disabled:hover,.el-button--warning.is-plain.is-disabled,.el-button--warning.is-plain.is-disabled:active,.el-button--warning.is-plain.is-disabled:focus,.el-button--warning.is-plain.is-disabled:hover,.el-button--warning.is-text.is-disabled,.el-button--warning.is-text.is-disabled:active,.el-button--warning.is-text.is-disabled:focus,.el-button--warning.is-text.is-disabled:hover{background-color:var(--el-color-warning-light-9);border-color:var(--el-color-warning-light-8);color:var(--el-color-warning-light-5)}.el-button--danger{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-danger);--el-button-border-color:var(--el-color-danger);--el-button-outline-color:var(--el-color-danger-light-5);--el-button-active-color:var(--el-color-danger-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-danger-light-5);--el-button-hover-bg-color:var(--el-color-danger-light-3);--el-button-hover-border-color:var(--el-color-danger-light-3);--el-button-active-bg-color:var(--el-color-danger-dark-2);--el-button-active-border-color:var(--el-color-danger-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-danger-light-5);--el-button-disabled-border-color:var(--el-color-danger-light-5)}.el-button--danger.is-link,.el-button--danger.is-plain,.el-button--danger.is-text{--el-button-text-color:var(--el-color-danger);--el-button-bg-color:var(--el-color-danger-light-9);--el-button-border-color:var(--el-color-danger-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-danger);--el-button-hover-border-color:var(--el-color-danger);--el-button-active-text-color:var(--el-color-white)}.el-button--danger.is-link.is-disabled,.el-button--danger.is-link.is-disabled:active,.el-button--danger.is-link.is-disabled:focus,.el-button--danger.is-link.is-disabled:hover,.el-button--danger.is-plain.is-disabled,.el-button--danger.is-plain.is-disabled:active,.el-button--danger.is-plain.is-disabled:focus,.el-button--danger.is-plain.is-disabled:hover,.el-button--danger.is-text.is-disabled,.el-button--danger.is-text.is-disabled:active,.el-button--danger.is-text.is-disabled:focus,.el-button--danger.is-text.is-disabled:hover{background-color:var(--el-color-danger-light-9);border-color:var(--el-color-danger-light-8);color:var(--el-color-danger-light-5)}.el-button--info{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-info);--el-button-border-color:var(--el-color-info);--el-button-outline-color:var(--el-color-info-light-5);--el-button-active-color:var(--el-color-info-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-info-light-5);--el-button-hover-bg-color:var(--el-color-info-light-3);--el-button-hover-border-color:var(--el-color-info-light-3);--el-button-active-bg-color:var(--el-color-info-dark-2);--el-button-active-border-color:var(--el-color-info-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-info-light-5);--el-button-disabled-border-color:var(--el-color-info-light-5)}.el-button--info.is-link,.el-button--info.is-plain,.el-button--info.is-text{--el-button-text-color:var(--el-color-info);--el-button-bg-color:var(--el-color-info-light-9);--el-button-border-color:var(--el-color-info-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-info);--el-button-hover-border-color:var(--el-color-info);--el-button-active-text-color:var(--el-color-white)}.el-button--info.is-link.is-disabled,.el-button--info.is-link.is-disabled:active,.el-button--info.is-link.is-disabled:focus,.el-button--info.is-link.is-disabled:hover,.el-button--info.is-plain.is-disabled,.el-button--info.is-plain.is-disabled:active,.el-button--info.is-plain.is-disabled:focus,.el-button--info.is-plain.is-disabled:hover,.el-button--info.is-text.is-disabled,.el-button--info.is-text.is-disabled:active,.el-button--info.is-text.is-disabled:focus,.el-button--info.is-text.is-disabled:hover{background-color:var(--el-color-info-light-9);border-color:var(--el-color-info-light-8);color:var(--el-color-info-light-5)}.el-button--large{--el-button-size:40px;border-radius:var(--el-border-radius-base);font-size:var(--el-font-size-base);height:var(--el-button-size);padding:12px 19px}.el-button--large [class*=el-icon]+span{margin-left:8px}.el-button--large.is-round{padding:12px 19px}.el-button--large.is-circle{padding:12px;width:var(--el-button-size)}.el-button--small{--el-button-size:24px;border-radius:calc(var(--el-border-radius-base) - 1px);font-size:12px;height:var(--el-button-size);padding:5px 11px}.el-button--small [class*=el-icon]+span{margin-left:4px}.el-button--small.is-round{padding:5px 11px}.el-button--small.is-circle{padding:5px;width:var(--el-button-size)}.el-text{--el-text-font-size:var(--el-font-size-base);--el-text-color:var(--el-text-color-regular);align-self:center;color:var(--el-text-color);font-size:var(--el-text-font-size);margin:0;overflow-wrap:break-word;padding:0}.el-text.is-truncated{display:inline-block;max-width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-text.is-line-clamp{display:-webkit-inline-box;-webkit-box-orient:vertical;overflow:hidden}.el-text--large{--el-text-font-size:var(--el-font-size-medium)}.el-text--default{--el-text-font-size:var(--el-font-size-base)}.el-text--small{--el-text-font-size:var(--el-font-size-extra-small)}.el-text.el-text--primary{--el-text-color:var(--el-color-primary)}.el-text.el-text--success{--el-text-color:var(--el-color-success)}.el-text.el-text--warning{--el-text-color:var(--el-color-warning)}.el-text.el-text--danger{--el-text-color:var(--el-color-danger)}.el-text.el-text--error{--el-text-color:var(--el-color-error)}.el-text.el-text--info{--el-text-color:var(--el-color-info)}.el-text>.el-icon{vertical-align:-2px}.my-header[data-v-5cadd0bd]{display:flex;flex-direction:row;justify-content:space-between;gap:16px}.batch-send-btn[data-v-251fd5d8]:hover{background-color:#337ecc!important}.batch-checkbox[data-v-251fd5d8]{margin-right:8px;transform:scale(1.2)}.batch-send-item[data-v-251fd5d8]{background-color:#f0f9ff!important;border:2px solid #409eff!important}.batch-send-float[data-v-251fd5d8]{position:fixed;right:24px;bottom:24px;width:480px;padding:16px;background:#fff;box-shadow:0 6px 16px #00000026;border-radius:8px;z-index:9999}:root{--el-menu-active-color:var(--el-color-primary);--el-menu-text-color:var(--el-text-color-primary);--el-menu-hover-text-color:var(--el-color-primary);--el-menu-bg-color:var(--el-fill-color-blank);--el-menu-hover-bg-color:var(--el-color-primary-light-9);--el-menu-item-height:56px;--el-menu-sub-item-height:calc(var(--el-menu-item-height) - 6px);--el-menu-horizontal-height:60px;--el-menu-horizontal-sub-item-height:36px;--el-menu-item-font-size:var(--el-font-size-base);--el-menu-item-hover-fill:var(--el-color-primary-light-9);--el-menu-border-color:var(--el-border-color);--el-menu-base-level-padding:20px;--el-menu-level-padding:20px;--el-menu-icon-width:24px}.el-menu{background-color:var(--el-menu-bg-color);border-right:1px solid var(--el-menu-border-color);box-sizing:border-box;list-style:none;margin:0;padding-left:0;position:relative}.el-menu--vertical:not(.el-menu--collapse):not(.el-menu--popup-container) .el-menu-item,.el-menu--vertical:not(.el-menu--collapse):not(.el-menu--popup-container) .el-menu-item-group__title,.el-menu--vertical:not(.el-menu--collapse):not(.el-menu--popup-container) .el-sub-menu__title{padding-left:calc(var(--el-menu-base-level-padding) + var(--el-menu-level)*var(--el-menu-level-padding));white-space:nowrap}.el-menu:not(.el-menu--collapse) .el-sub-menu__title{padding-right:calc(var(--el-menu-base-level-padding) + var(--el-menu-icon-width))}.el-menu--horizontal{border-right:none;display:flex;flex-wrap:nowrap;height:var(--el-menu-horizontal-height)}.el-menu--horizontal.el-menu--popup-container{height:unset}.el-menu--horizontal.el-menu{border-bottom:1px solid var(--el-menu-border-color)}.el-menu--horizontal>.el-menu-item{align-items:center;border-bottom:2px solid transparent;color:var(--el-menu-text-color);display:inline-flex;height:100%;justify-content:center;margin:0}.el-menu--horizontal>.el-menu-item a,.el-menu--horizontal>.el-menu-item a:hover{color:inherit}.el-menu--horizontal>.el-sub-menu:focus,.el-menu--horizontal>.el-sub-menu:hover{outline:none}.el-menu--horizontal>.el-sub-menu:hover .el-sub-menu__title{color:var(--el-menu-hover-text-color)}.el-menu--horizontal>.el-sub-menu.is-active .el-sub-menu__title{border-bottom:2px solid var(--el-menu-active-color);color:var(--el-menu-active-color)}.el-menu--horizontal>.el-sub-menu .el-sub-menu__title{border-bottom:2px solid transparent;color:var(--el-menu-text-color);height:100%}.el-menu--horizontal>.el-sub-menu .el-sub-menu__title:hover{background-color:var(--el-menu-bg-color)}.el-menu--horizontal .el-menu .el-menu-item,.el-menu--horizontal .el-menu .el-sub-menu__title{align-items:center;background-color:var(--el-menu-bg-color);color:var(--el-menu-text-color);display:flex;height:var(--el-menu-horizontal-sub-item-height);line-height:var(--el-menu-horizontal-sub-item-height);padding:0 10px}.el-menu--horizontal .el-menu .el-sub-menu__title{padding-right:40px}.el-menu--horizontal .el-menu .el-menu-item.is-active,.el-menu--horizontal .el-menu .el-sub-menu.is-active>.el-sub-menu__title{color:var(--el-menu-active-color)}.el-menu--horizontal .el-menu-item:not(.is-disabled):focus,.el-menu--horizontal .el-menu-item:not(.is-disabled):hover{background-color:var(--el-menu-hover-bg-color);color:var(--el-menu-hover-text-color);outline:none}.el-menu--horizontal>.el-menu-item.is-active{border-bottom:2px solid var(--el-menu-active-color);color:var(--el-menu-active-color)!important}.el-menu--collapse{width:calc(var(--el-menu-icon-width) + var(--el-menu-base-level-padding)*2)}.el-menu--collapse>.el-menu-item [class^=el-icon],.el-menu--collapse>.el-menu-item-group>ul>.el-sub-menu>.el-sub-menu__title [class^=el-icon],.el-menu--collapse>.el-sub-menu>.el-sub-menu__title [class^=el-icon]{margin:0;text-align:center;vertical-align:middle;width:var(--el-menu-icon-width)}.el-menu--collapse>.el-menu-item .el-sub-menu__icon-arrow,.el-menu--collapse>.el-menu-item-group>ul>.el-sub-menu>.el-sub-menu__title .el-sub-menu__icon-arrow,.el-menu--collapse>.el-sub-menu>.el-sub-menu__title .el-sub-menu__icon-arrow{display:none}.el-menu--collapse>.el-menu-item-group>ul>.el-sub-menu>.el-sub-menu__title>span,.el-menu--collapse>.el-menu-item>span,.el-menu--collapse>.el-sub-menu>.el-sub-menu__title>span{display:inline-block;height:0;overflow:hidden;visibility:hidden;width:0}.el-menu--collapse>.el-menu-item.is-active i{color:inherit}.el-menu--collapse .el-menu .el-sub-menu{min-width:200px}.el-menu--collapse .el-sub-menu.is-active .el-sub-menu__title{color:var(--el-menu-active-color)}.el-menu--popup{border:none;border-radius:var(--el-border-radius-small);box-shadow:var(--el-box-shadow-light);min-width:200px;padding:5px 0;z-index:100}.el-menu .el-icon{flex-shrink:0}.el-menu-item{align-items:center;box-sizing:border-box;color:var(--el-menu-text-color);cursor:pointer;display:flex;font-size:var(--el-menu-item-font-size);height:var(--el-menu-item-height);line-height:var(--el-menu-item-height);list-style:none;padding:0 var(--el-menu-base-level-padding);position:relative;transition:border-color var(--el-transition-duration),background-color var(--el-transition-duration),color var(--el-transition-duration);white-space:nowrap}.el-menu-item *{vertical-align:bottom}.el-menu-item i{color:inherit}.el-menu-item:focus,.el-menu-item:hover{outline:none}.el-menu-item:hover{background-color:var(--el-menu-hover-bg-color)}.el-menu-item.is-disabled{background:none!important;cursor:not-allowed;opacity:.25}.el-menu-item [class^=el-icon]{font-size:18px;margin-right:5px;text-align:center;vertical-align:middle;width:var(--el-menu-icon-width)}.el-menu-item.is-active{color:var(--el-menu-active-color)}.el-menu-item.is-active i{color:inherit}.el-menu-item .el-menu-tooltip__trigger{align-items:center;box-sizing:border-box;display:inline-flex;height:100%;left:0;padding:0 var(--el-menu-base-level-padding);position:absolute;top:0;width:100%}.el-sub-menu{list-style:none;margin:0;padding-left:0}.el-sub-menu__title{align-items:center;box-sizing:border-box;color:var(--el-menu-text-color);cursor:pointer;display:flex;font-size:var(--el-menu-item-font-size);height:var(--el-menu-item-height);line-height:var(--el-menu-item-height);list-style:none;padding:0 var(--el-menu-base-level-padding);position:relative;transition:border-color var(--el-transition-duration),background-color var(--el-transition-duration),color var(--el-transition-duration);white-space:nowrap}.el-sub-menu__title *{vertical-align:bottom}.el-sub-menu__title i{color:inherit}.el-sub-menu__title:focus,.el-sub-menu__title:hover{outline:none}.el-sub-menu__title.is-disabled{background:none!important;cursor:not-allowed;opacity:.25}.el-sub-menu__title:hover{background-color:var(--el-menu-hover-bg-color)}.el-sub-menu .el-menu{border:none}.el-sub-menu .el-menu-item{height:var(--el-menu-sub-item-height);line-height:var(--el-menu-sub-item-height)}.el-sub-menu__hide-arrow .el-sub-menu__icon-arrow{display:none!important}.el-sub-menu.is-active .el-sub-menu__title{border-bottom-color:var(--el-menu-active-color)}.el-sub-menu.is-disabled .el-menu-item,.el-sub-menu.is-disabled .el-sub-menu__title{background:none!important;cursor:not-allowed;opacity:.25}.el-sub-menu .el-icon{font-size:18px;margin-right:5px;text-align:center;vertical-align:middle;width:var(--el-menu-icon-width)}.el-sub-menu .el-icon.el-sub-menu__icon-more{margin-right:0!important}.el-sub-menu .el-sub-menu__icon-arrow{font-size:12px;margin-right:0;margin-top:-6px;position:absolute;right:var(--el-menu-base-level-padding);top:50%;transition:transform var(--el-transition-duration);width:inherit}.el-menu-item-group>ul{padding:0}.el-menu-item-group__title{color:var(--el-text-color-secondary);font-size:12px;line-height:normal;padding:7px 0 7px var(--el-menu-base-level-padding)}.horizontal-collapse-transition .el-sub-menu__title .el-sub-menu__icon-arrow{opacity:0;transition:var(--el-transition-duration-fast)}:root{--el-loading-spinner-size:42px;--el-loading-fullscreen-spinner-size:50px}.el-loading-parent--relative{position:relative!important}.el-loading-parent--hidden{overflow:hidden!important}.el-loading-mask{background-color:var(--el-mask-color);bottom:0;left:0;margin:0;position:absolute;right:0;top:0;transition:opacity var(--el-transition-duration);z-index:2000}.el-loading-mask.is-fullscreen{position:fixed}.el-loading-mask.is-fullscreen .el-loading-spinner{margin-top:calc((0px - var(--el-loading-fullscreen-spinner-size))/2)}.el-loading-mask.is-fullscreen .el-loading-spinner .circular{height:var(--el-loading-fullscreen-spinner-size);width:var(--el-loading-fullscreen-spinner-size)}.el-loading-spinner{margin-top:calc((0px - var(--el-loading-spinner-size))/2);position:absolute;text-align:center;top:50%;width:100%}.el-loading-spinner .el-loading-text{color:var(--el-color-primary);font-size:14px;margin:3px 0}.el-loading-spinner .circular{-webkit-animation:loading-rotate 2s linear infinite;animation:loading-rotate 2s linear infinite;display:inline;height:var(--el-loading-spinner-size);width:var(--el-loading-spinner-size)}.el-loading-spinner .path{-webkit-animation:loading-dash 1.5s ease-in-out infinite;animation:loading-dash 1.5s ease-in-out infinite;stroke-dasharray:90,150;stroke-dashoffset:0;stroke-width:2;stroke:var(--el-color-primary);stroke-linecap:round}.el-loading-spinner i{color:var(--el-color-primary)}.el-loading-fade-enter-from,.el-loading-fade-leave-to{opacity:0}@-webkit-keyframes loading-rotate{to{transform:rotate(1turn)}}@keyframes loading-rotate{to{transform:rotate(1turn)}}@-webkit-keyframes loading-dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-40px}to{stroke-dasharray:90,150;stroke-dashoffset:-120px}}@keyframes loading-dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-40px}to{stroke-dasharray:90,150;stroke-dashoffset:-120px}}.el-empty{--el-empty-padding:40px 0;--el-empty-image-width:160px;--el-empty-description-margin-top:20px;--el-empty-bottom-margin-top:20px;--el-empty-fill-color-0:var(--el-color-white);--el-empty-fill-color-1:#fcfcfd;--el-empty-fill-color-2:#f8f9fb;--el-empty-fill-color-3:#f7f8fc;--el-empty-fill-color-4:#eeeff3;--el-empty-fill-color-5:#edeef2;--el-empty-fill-color-6:#e9ebef;--el-empty-fill-color-7:#e5e7e9;--el-empty-fill-color-8:#e0e3e9;--el-empty-fill-color-9:#d5d7de;align-items:center;box-sizing:border-box;display:flex;flex-direction:column;justify-content:center;padding:var(--el-empty-padding);text-align:center}.el-empty__image{width:var(--el-empty-image-width)}.el-empty__image img{height:100%;-o-object-fit:contain;object-fit:contain;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:top;width:100%}.el-empty__image svg{color:var(--el-svg-monochrome-grey);fill:currentColor;height:100%;vertical-align:top;width:100%}.el-empty__description{margin-top:var(--el-empty-description-margin-top)}.el-empty__description p{color:var(--el-text-color-secondary);font-size:var(--el-font-size-base);margin:0}.el-empty__bottom{margin-top:var(--el-empty-bottom-margin-top)}.el-switch{--el-switch-on-color:var(--el-color-primary);--el-switch-off-color:var(--el-border-color);align-items:center;display:inline-flex;font-size:14px;height:32px;line-height:20px;position:relative;vertical-align:middle}.el-switch.is-disabled .el-switch__core,.el-switch.is-disabled .el-switch__label{cursor:not-allowed}.el-switch__label{color:var(--el-text-color-primary);cursor:pointer;display:inline-block;font-size:14px;font-weight:500;height:20px;transition:var(--el-transition-duration-fast);vertical-align:middle}.el-switch__label.is-active{color:var(--el-color-primary)}.el-switch__label--left{margin-right:10px}.el-switch__label--right{margin-left:10px}.el-switch__label *{display:inline-block;font-size:14px;line-height:1}.el-switch__label .el-icon{height:inherit}.el-switch__label .el-icon svg{vertical-align:middle}.el-switch__input{height:0;margin:0;opacity:0;position:absolute;width:0}.el-switch__input:focus-visible~.el-switch__core{outline:2px solid var(--el-switch-on-color);outline-offset:1px}.el-switch__core{align-items:center;background:var(--el-switch-off-color);border:1px solid var(--el-switch-border-color,var(--el-switch-off-color));border-radius:10px;box-sizing:border-box;cursor:pointer;display:inline-flex;height:20px;min-width:40px;outline:none;position:relative;transition:border-color var(--el-transition-duration),background-color var(--el-transition-duration)}.el-switch__core .el-switch__inner{align-items:center;display:flex;height:16px;justify-content:center;overflow:hidden;padding:0 4px 0 18px;transition:all var(--el-transition-duration);width:100%}.el-switch__core .el-switch__inner .is-icon,.el-switch__core .el-switch__inner .is-text{color:var(--el-color-white);font-size:12px;overflow:hidden;text-overflow:ellipsis;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;white-space:nowrap}.el-switch__core .el-switch__action{align-items:center;background-color:var(--el-color-white);border-radius:var(--el-border-radius-circle);color:var(--el-switch-off-color);display:flex;height:16px;justify-content:center;left:1px;position:absolute;transition:all var(--el-transition-duration);width:16px}.el-switch.is-checked .el-switch__core{background-color:var(--el-switch-on-color);border-color:var(--el-switch-border-color,var(--el-switch-on-color))}.el-switch.is-checked .el-switch__core .el-switch__action{color:var(--el-switch-on-color);left:calc(100% - 17px)}.el-switch.is-checked .el-switch__core .el-switch__inner{padding:0 18px 0 4px}.el-switch.is-disabled{opacity:.6}.el-switch--wide .el-switch__label.el-switch__label--left span{left:10px}.el-switch--wide .el-switch__label.el-switch__label--right span{right:10px}.el-switch .label-fade-enter-from,.el-switch .label-fade-leave-active{opacity:0}.el-switch--large{font-size:14px;height:40px;line-height:24px}.el-switch--large .el-switch__label{font-size:14px;height:24px}.el-switch--large .el-switch__label *{font-size:14px}.el-switch--large .el-switch__core{border-radius:12px;height:24px;min-width:50px}.el-switch--large .el-switch__core .el-switch__inner{height:20px;padding:0 6px 0 22px}.el-switch--large .el-switch__core .el-switch__action{height:20px;width:20px}.el-switch--large.is-checked .el-switch__core .el-switch__action{left:calc(100% - 21px)}.el-switch--large.is-checked .el-switch__core .el-switch__inner{padding:0 22px 0 6px}.el-switch--small{font-size:12px;height:24px;line-height:16px}.el-switch--small .el-switch__label{font-size:12px;height:16px}.el-switch--small .el-switch__label *{font-size:12px}.el-switch--small .el-switch__core{border-radius:8px;height:16px;min-width:30px}.el-switch--small .el-switch__core .el-switch__inner{height:12px;padding:0 2px 0 14px}.el-switch--small .el-switch__core .el-switch__action{height:12px;width:12px}.el-switch--small.is-checked .el-switch__core .el-switch__action{left:calc(100% - 13px)}.el-switch--small.is-checked .el-switch__core .el-switch__inner{padding:0 14px 0 2px}.el-input-number{display:inline-flex;line-height:30px;position:relative;width:150px}.el-input-number .el-input__wrapper{padding-left:42px;padding-right:42px}.el-input-number .el-input__inner{-webkit-appearance:none;-moz-appearance:textfield;line-height:1;text-align:center}.el-input-number .el-input__inner::-webkit-inner-spin-button,.el-input-number .el-input__inner::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.el-input-number__decrease,.el-input-number__increase{align-items:center;background:var(--el-fill-color-light);bottom:1px;color:var(--el-text-color-regular);cursor:pointer;display:flex;font-size:13px;height:auto;justify-content:center;position:absolute;top:1px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:32px;z-index:1}.el-input-number__decrease:hover,.el-input-number__increase:hover{color:var(--el-color-primary)}.el-input-number__decrease:hover~.el-input:not(.is-disabled) .el-input__wrapper,.el-input-number__increase:hover~.el-input:not(.is-disabled) .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-border-color,var(--el-color-primary)) inset}.el-input-number__decrease.is-disabled,.el-input-number__increase.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-input-number__increase{border-left:var(--el-border);border-radius:0 var(--el-border-radius-base) var(--el-border-radius-base) 0;right:1px}.el-input-number__decrease{border-radius:var(--el-border-radius-base) 0 0 var(--el-border-radius-base);border-right:var(--el-border);left:1px}.el-input-number.is-disabled .el-input-number__decrease,.el-input-number.is-disabled .el-input-number__increase{border-color:var(--el-disabled-border-color);color:var(--el-disabled-border-color)}.el-input-number.is-disabled .el-input-number__decrease:hover,.el-input-number.is-disabled .el-input-number__increase:hover{color:var(--el-disabled-border-color);cursor:not-allowed}.el-input-number--large{line-height:38px;width:180px}.el-input-number--large .el-input-number__decrease,.el-input-number--large .el-input-number__increase{font-size:14px;width:40px}.el-input-number--large .el-input--large .el-input__wrapper{padding-left:47px;padding-right:47px}.el-input-number--small{line-height:22px;width:120px}.el-input-number--small .el-input-number__decrease,.el-input-number--small .el-input-number__increase{font-size:12px;width:24px}.el-input-number--small .el-input--small .el-input__wrapper{padding-left:31px;padding-right:31px}.el-input-number--small .el-input-number__decrease [class*=el-icon],.el-input-number--small .el-input-number__increase [class*=el-icon]{transform:scale(.9)}.el-input-number.is-without-controls .el-input__wrapper{padding-left:15px;padding-right:15px}.el-input-number.is-controls-right .el-input__wrapper{padding-left:15px;padding-right:42px}.el-input-number.is-controls-right .el-input-number__decrease,.el-input-number.is-controls-right .el-input-number__increase{--el-input-number-controls-height:15px;height:var(--el-input-number-controls-height);line-height:var(--el-input-number-controls-height)}.el-input-number.is-controls-right .el-input-number__decrease [class*=el-icon],.el-input-number.is-controls-right .el-input-number__increase [class*=el-icon]{transform:scale(.8)}.el-input-number.is-controls-right .el-input-number__increase{border-bottom:var(--el-border);border-radius:0 var(--el-border-radius-base) 0 0;bottom:auto;left:auto}.el-input-number.is-controls-right .el-input-number__decrease{border-left:var(--el-border);border-radius:0 0 var(--el-border-radius-base) 0;border-right:none;left:auto;right:1px;top:auto}.el-input-number.is-controls-right[class*=large] [class*=decrease],.el-input-number.is-controls-right[class*=large] [class*=increase]{--el-input-number-controls-height:19px}.el-input-number.is-controls-right[class*=small] [class*=decrease],.el-input-number.is-controls-right[class*=small] [class*=increase]{--el-input-number-controls-height:11px}.my-header[data-v-13350d57]{display:flex;flex-direction:row;justify-content:space-between;gap:16px}.fixed-stop-button[data-v-13350d57]{position:fixed;right:80px;bottom:80px;z-index:9999;background:#fffffff2;padding:8px;border-radius:8px;box-shadow:0 4px 12px #0003;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,.3)}.fixed-stop-button[data-v-13350d57]:hover{background:#fff;box-shadow:0 6px 16px #0000004d}.push-records-container[data-v-13350d57]{margin-bottom:12px;background:#ffffffe6;border-radius:6px;border:1px solid rgba(0,0,0,.1);overflow:hidden;max-width:400px}.push-records-header[data-v-13350d57]{background:linear-gradient(135deg,#667eea,#764ba2);color:#fff;padding:8px 12px;font-size:14px;font-weight:500;text-align:center}.push-records-content[data-v-13350d57]{max-height:200px;overflow-y:auto;padding:8px}.push-record-item[data-v-13350d57]{display:flex;flex-direction:column;margin-bottom:8px;padding:6px 8px;background:#f8fafccc;border-radius:4px;border-left:3px solid #e2e8f0;font-size:12px;line-height:1.4}.push-record-item[data-v-13350d57]:last-child{margin-bottom:0}.record-time[data-v-13350d57]{color:#64748b;font-size:11px;margin-bottom:2px}.record-message[data-v-13350d57]{color:#334155;word-break:break-word}.record-error[data-v-13350d57]{color:#dc2626;border-left-color:#dc2626}.record-warn[data-v-13350d57]{color:#d97706;border-left-color:#d97706}.record-info[data-v-13350d57]{color:#2563eb;border-left-color:#2563eb}.record-debug[data-v-13350d57]{color:#059669;border-left-color:#059669}.record-trace[data-v-13350d57]{color:#7c3aed;border-left-color:#7c3aed}.no-records[data-v-13350d57]{text-align:center;color:#94a3b8;font-size:12px;padding:20px 0}.push-records-content[data-v-13350d57]::-webkit-scrollbar{width:4px}.push-records-content[data-v-13350d57]::-webkit-scrollbar-track{background:#0000000d;border-radius:2px}.push-records-content[data-v-13350d57]::-webkit-scrollbar-thumb{background:#0003;border-radius:2px}.push-records-content[data-v-13350d57]::-webkit-scrollbar-thumb:hover{background:#0000004d}.el-form{--el-form-label-font-size:var(--el-font-size-base);--el-form-inline-content-width:220px}.el-form--label-left .el-form-item__label{justify-content:flex-start}.el-form--label-top .el-form-item{display:block}.el-form--label-top .el-form-item .el-form-item__label{display:block;height:auto;line-height:22px;margin-bottom:8px;text-align:left}.el-form--inline .el-form-item{display:inline-flex;margin-right:32px;vertical-align:middle}.el-form--inline.el-form--label-top{display:flex;flex-wrap:wrap}.el-form--inline.el-form--label-top .el-form-item{display:block}.el-form--large.el-form--label-top .el-form-item .el-form-item__label{line-height:22px;margin-bottom:12px}.el-form--default.el-form--label-top .el-form-item .el-form-item__label{line-height:22px;margin-bottom:8px}.el-form--small.el-form--label-top .el-form-item .el-form-item__label{line-height:20px;margin-bottom:4px}.el-form-item{display:flex;--font-size:14px;margin-bottom:18px}.el-form-item .el-form-item{margin-bottom:0}.el-form-item .el-input__validateIcon{display:none}.el-form-item--large{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:22px}.el-form-item--large .el-form-item__label{height:40px;line-height:40px}.el-form-item--large .el-form-item__content{line-height:40px}.el-form-item--large .el-form-item__error{padding-top:4px}.el-form-item--default{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--default .el-form-item__label{height:32px;line-height:32px}.el-form-item--default .el-form-item__content{line-height:32px}.el-form-item--default .el-form-item__error{padding-top:2px}.el-form-item--small{--font-size:12px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--small .el-form-item__label{height:24px;line-height:24px}.el-form-item--small .el-form-item__content{line-height:24px}.el-form-item--small .el-form-item__error{padding-top:2px}.el-form-item__label-wrap{display:flex}.el-form-item__label{align-items:flex-start;box-sizing:border-box;color:var(--el-text-color-regular);display:inline-flex;flex:0 0 auto;font-size:var(--el-form-label-font-size);height:32px;justify-content:flex-end;line-height:32px;padding:0 12px 0 0}.el-form-item__content{align-items:center;display:flex;flex:1;flex-wrap:wrap;font-size:var(--font-size);line-height:32px;min-width:0;position:relative}.el-form-item__content .el-input-group{vertical-align:top}.el-form-item__error{color:var(--el-color-danger);font-size:12px;left:0;line-height:1;padding-top:2px;position:absolute;top:100%}.el-form-item__error--inline{display:inline-block;left:auto;margin-left:10px;position:relative;top:auto}.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label-wrap>.el-form-item__label:before,.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label:before{color:var(--el-color-danger);content:"*";margin-right:4px}.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label-wrap>.el-form-item__label:after,.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label:after{color:var(--el-color-danger);content:"*";margin-left:4px}.el-form-item.is-error .el-input__wrapper,.el-form-item.is-error .el-input__wrapper.is-focus,.el-form-item.is-error .el-input__wrapper:focus,.el-form-item.is-error .el-input__wrapper:hover,.el-form-item.is-error .el-select__wrapper,.el-form-item.is-error .el-select__wrapper.is-focus,.el-form-item.is-error .el-select__wrapper:focus,.el-form-item.is-error .el-select__wrapper:hover,.el-form-item.is-error .el-textarea__inner,.el-form-item.is-error .el-textarea__inner.is-focus,.el-form-item.is-error .el-textarea__inner:focus,.el-form-item.is-error .el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-form-item.is-error .el-input-group__append .el-input__wrapper,.el-form-item.is-error .el-input-group__prepend .el-input__wrapper{box-shadow:inset 0 0 0 1px transparent}.el-form-item.is-error .el-input__validateIcon{color:var(--el-color-danger)}.el-form-item--feedback .el-input__validateIcon{display:inline-flex}.el-upload{--el-upload-dragger-padding-horizontal:40px;--el-upload-dragger-padding-vertical:10px;align-items:center;cursor:pointer;display:inline-flex;justify-content:center;outline:none}.el-upload__input{display:none}.el-upload__tip{color:var(--el-text-color-regular);font-size:12px;margin-top:7px}.el-upload iframe{filter:alpha(opacity=0);left:0;opacity:0;position:absolute;top:0;z-index:-1}.el-upload--picture-card{--el-upload-picture-card-size:148px;align-items:center;background-color:var(--el-fill-color-lighter);border:1px dashed var(--el-border-color-darker);border-radius:6px;box-sizing:border-box;cursor:pointer;display:inline-flex;height:var(--el-upload-picture-card-size);justify-content:center;vertical-align:top;width:var(--el-upload-picture-card-size)}.el-upload--picture-card>i{color:var(--el-text-color-secondary);font-size:28px}.el-upload--picture-card:hover{border-color:var(--el-color-primary);color:var(--el-color-primary)}.el-upload.is-drag{display:block}.el-upload:focus{border-color:var(--el-color-primary);color:var(--el-color-primary)}.el-upload:focus .el-upload-dragger{border-color:var(--el-color-primary)}.el-upload-dragger{background-color:var(--el-fill-color-blank);border:1px dashed var(--el-border-color);border-radius:6px;box-sizing:border-box;cursor:pointer;overflow:hidden;padding:var(--el-upload-dragger-padding-horizontal) var(--el-upload-dragger-padding-vertical);position:relative;text-align:center}.el-upload-dragger .el-icon--upload{color:var(--el-text-color-placeholder);font-size:67px;line-height:50px;margin-bottom:16px}.el-upload-dragger+.el-upload__tip{text-align:center}.el-upload-dragger~.el-upload__files{border-top:var(--el-border);margin-top:7px;padding-top:5px}.el-upload-dragger .el-upload__text{color:var(--el-text-color-regular);font-size:14px;text-align:center}.el-upload-dragger .el-upload__text em{color:var(--el-color-primary);font-style:normal}.el-upload-dragger:hover{border-color:var(--el-color-primary)}.el-upload-dragger.is-dragover{background-color:var(--el-color-primary-light-9);border:2px dashed var(--el-color-primary);padding:calc(var(--el-upload-dragger-padding-horizontal) - 1px) calc(var(--el-upload-dragger-padding-vertical) - 1px)}.el-upload-list{list-style:none;margin:10px 0 0;padding:0;position:relative}.el-upload-list__item{border-radius:4px;box-sizing:border-box;color:var(--el-text-color-regular);font-size:14px;margin-bottom:5px;position:relative;transition:all .5s cubic-bezier(.55,0,.1,1);width:100%}.el-upload-list__item .el-progress{position:absolute;top:20px;width:100%}.el-upload-list__item .el-progress__text{position:absolute;right:0;top:-13px}.el-upload-list__item .el-progress-bar{margin-right:0;padding-right:0}.el-upload-list__item .el-icon--upload-success{color:var(--el-color-success)}.el-upload-list__item .el-icon--close{color:var(--el-text-color-regular);cursor:pointer;display:none;opacity:.75;position:absolute;right:5px;top:50%;transform:translateY(-50%);transition:opacity var(--el-transition-duration)}.el-upload-list__item .el-icon--close:hover{color:var(--el-color-primary);opacity:1}.el-upload-list__item .el-icon--close-tip{color:var(--el-color-primary);cursor:pointer;display:none;font-size:12px;font-style:normal;opacity:1;position:absolute;right:5px;top:1px}.el-upload-list__item:hover{background-color:var(--el-fill-color-light)}.el-upload-list__item:hover .el-icon--close{display:inline-flex}.el-upload-list__item:hover .el-progress__text{display:none}.el-upload-list__item .el-upload-list__item-info{display:inline-flex;flex-direction:column;justify-content:center;margin-left:4px;width:calc(100% - 30px)}.el-upload-list__item.is-success .el-upload-list__item-status-label{display:inline-flex}.el-upload-list__item.is-success .el-upload-list__item-name:focus,.el-upload-list__item.is-success .el-upload-list__item-name:hover{color:var(--el-color-primary);cursor:pointer}.el-upload-list__item.is-success:focus:not(:hover) .el-icon--close-tip{display:inline-block}.el-upload-list__item.is-success:active,.el-upload-list__item.is-success:not(.focusing):focus{outline-width:0}.el-upload-list__item.is-success:active .el-icon--close-tip,.el-upload-list__item.is-success:not(.focusing):focus .el-icon--close-tip{display:none}.el-upload-list__item.is-success:focus .el-upload-list__item-status-label,.el-upload-list__item.is-success:hover .el-upload-list__item-status-label{display:none;opacity:0}.el-upload-list__item-name{align-items:center;color:var(--el-text-color-regular);display:inline-flex;font-size:var(--el-font-size-base);padding:0 4px;text-align:center;transition:color var(--el-transition-duration)}.el-upload-list__item-name .el-icon{color:var(--el-text-color-secondary);margin-right:6px}.el-upload-list__item-file-name{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-upload-list__item-status-label{align-items:center;display:none;height:100%;justify-content:center;line-height:inherit;position:absolute;right:5px;top:0;transition:opacity var(--el-transition-duration)}.el-upload-list__item-delete{color:var(--el-text-color-regular);display:none;font-size:12px;position:absolute;right:10px;top:0}.el-upload-list__item-delete:hover{color:var(--el-color-primary)}.el-upload-list--picture-card{--el-upload-list-picture-card-size:148px;display:inline-flex;flex-wrap:wrap;margin:0}.el-upload-list--picture-card .el-upload-list__item{background-color:var(--el-fill-color-blank);border:1px solid var(--el-border-color);border-radius:6px;box-sizing:border-box;display:inline-flex;height:var(--el-upload-list-picture-card-size);margin:0 8px 8px 0;overflow:hidden;padding:0;width:var(--el-upload-list-picture-card-size)}.el-upload-list--picture-card .el-upload-list__item .el-icon--check,.el-upload-list--picture-card .el-upload-list__item .el-icon--circle-check{color:#fff}.el-upload-list--picture-card .el-upload-list__item .el-icon--close{display:none}.el-upload-list--picture-card .el-upload-list__item:hover .el-upload-list__item-status-label{display:block;opacity:0}.el-upload-list--picture-card .el-upload-list__item:hover .el-progress__text{display:block}.el-upload-list--picture-card .el-upload-list__item .el-upload-list__item-name{display:none}.el-upload-list--picture-card .el-upload-list__item-thumbnail{height:100%;-o-object-fit:contain;object-fit:contain;width:100%}.el-upload-list--picture-card .el-upload-list__item-status-label{background:var(--el-color-success);height:24px;right:-15px;text-align:center;top:-6px;transform:rotate(45deg);width:40px}.el-upload-list--picture-card .el-upload-list__item-status-label i{font-size:12px;margin-top:11px;transform:rotate(-45deg)}.el-upload-list--picture-card .el-upload-list__item-actions{align-items:center;background-color:var(--el-overlay-color-lighter);color:#fff;cursor:default;display:inline-flex;font-size:20px;height:100%;justify-content:center;left:0;opacity:0;position:absolute;top:0;transition:opacity var(--el-transition-duration);width:100%}.el-upload-list--picture-card .el-upload-list__item-actions span{cursor:pointer;display:none}.el-upload-list--picture-card .el-upload-list__item-actions span+span{margin-left:1rem}.el-upload-list--picture-card .el-upload-list__item-actions .el-upload-list__item-delete{color:inherit;font-size:inherit;position:static}.el-upload-list--picture-card .el-upload-list__item-actions:hover{opacity:1}.el-upload-list--picture-card .el-upload-list__item-actions:hover span{display:inline-flex}.el-upload-list--picture-card .el-progress{bottom:auto;left:50%;top:50%;transform:translate(-50%,-50%);width:126px}.el-upload-list--picture-card .el-progress .el-progress__text{top:50%}.el-upload-list--picture .el-upload-list__item{align-items:center;background-color:var(--el-fill-color-blank);border:1px solid var(--el-border-color);border-radius:6px;box-sizing:border-box;display:flex;margin-top:10px;overflow:hidden;padding:10px;z-index:0}.el-upload-list--picture .el-upload-list__item .el-icon--check,.el-upload-list--picture .el-upload-list__item .el-icon--circle-check{color:#fff}.el-upload-list--picture .el-upload-list__item:hover .el-upload-list__item-status-label{display:inline-flex;opacity:0}.el-upload-list--picture .el-upload-list__item:hover .el-progress__text{display:block}.el-upload-list--picture .el-upload-list__item.is-success .el-upload-list__item-name i{display:none}.el-upload-list--picture .el-upload-list__item .el-icon--close{top:5px;transform:translateY(0)}.el-upload-list--picture .el-upload-list__item-thumbnail{align-items:center;background-color:var(--el-color-white);display:inline-flex;height:70px;justify-content:center;-o-object-fit:contain;object-fit:contain;position:relative;width:70px;z-index:1}.el-upload-list--picture .el-upload-list__item-status-label{background:var(--el-color-success);height:26px;position:absolute;right:-17px;text-align:center;top:-7px;transform:rotate(45deg);width:46px}.el-upload-list--picture .el-upload-list__item-status-label i{font-size:12px;margin-top:12px;transform:rotate(-45deg)}.el-upload-list--picture .el-progress{position:relative;top:-7px}.el-upload-cover{cursor:default;height:100%;left:0;overflow:hidden;position:absolute;top:0;width:100%;z-index:10}.el-upload-cover:after{content:"";display:inline-block;height:100%;vertical-align:middle}.el-upload-cover img{display:block;height:100%;width:100%}.el-upload-cover__label{background:var(--el-color-success);height:24px;right:-15px;text-align:center;top:-6px;transform:rotate(45deg);width:40px}.el-upload-cover__label i{color:#fff;font-size:12px;margin-top:11px;transform:rotate(-45deg)}.el-upload-cover__progress{display:inline-block;position:static;vertical-align:middle;width:243px}.el-upload-cover__progress+.el-upload__inner{opacity:0}.el-upload-cover__content{height:100%;left:0;position:absolute;top:0;width:100%}.el-upload-cover__interact{background-color:var(--el-overlay-color-light);bottom:0;height:100%;left:0;position:absolute;text-align:center;width:100%}.el-upload-cover__interact .btn{color:#fff;cursor:pointer;display:inline-block;font-size:14px;margin-top:60px;transition:var(--el-transition-md-fade);vertical-align:middle}.el-upload-cover__interact .btn i{margin-top:0}.el-upload-cover__interact .btn span{opacity:0;transition:opacity .15s linear}.el-upload-cover__interact .btn:not(:first-child){margin-left:35px}.el-upload-cover__interact .btn:hover{transform:translateY(-13px)}.el-upload-cover__interact .btn:hover span{opacity:1}.el-upload-cover__interact .btn i{color:#fff;display:block;font-size:24px;line-height:inherit;margin:0 auto 5px}.el-upload-cover__title{background-color:#fff;bottom:0;color:var(--el-text-color-primary);font-size:14px;font-weight:400;height:36px;left:0;line-height:36px;margin:0;overflow:hidden;padding:0 10px;position:absolute;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%}.el-upload-cover+.el-upload__inner{opacity:0;position:relative;z-index:1}.el-progress{align-items:center;display:flex;line-height:1;position:relative}.el-progress__text{color:var(--el-text-color-regular);font-size:14px;line-height:1;margin-left:5px;min-width:50px}.el-progress__text i{display:block;vertical-align:middle}.el-progress--circle,.el-progress--dashboard{display:inline-block}.el-progress--circle .el-progress__text,.el-progress--dashboard .el-progress__text{left:0;margin:0;position:absolute;text-align:center;top:50%;transform:translateY(-50%);width:100%}.el-progress--circle .el-progress__text i,.el-progress--dashboard .el-progress__text i{display:inline-block;vertical-align:middle}.el-progress--without-text .el-progress__text{display:none}.el-progress--without-text .el-progress-bar{display:block;margin-right:0;padding-right:0}.el-progress--text-inside .el-progress-bar{margin-right:0;padding-right:0}.el-progress.is-success .el-progress-bar__inner{background-color:var(--el-color-success)}.el-progress.is-success .el-progress__text{color:var(--el-color-success)}.el-progress.is-warning .el-progress-bar__inner{background-color:var(--el-color-warning)}.el-progress.is-warning .el-progress__text{color:var(--el-color-warning)}.el-progress.is-exception .el-progress-bar__inner{background-color:var(--el-color-danger)}.el-progress.is-exception .el-progress__text{color:var(--el-color-danger)}.el-progress-bar{box-sizing:border-box;flex-grow:1}.el-progress-bar__outer{background-color:var(--el-border-color-lighter);border-radius:100px;height:6px;overflow:hidden;position:relative;vertical-align:middle}.el-progress-bar__inner{background-color:var(--el-color-primary);border-radius:100px;height:100%;left:0;line-height:1;position:absolute;text-align:right;top:0;transition:width .6s ease;white-space:nowrap}.el-progress-bar__inner:after{content:"";display:inline-block;height:100%;vertical-align:middle}.el-progress-bar__inner--indeterminate{-webkit-animation:indeterminate 3s infinite;animation:indeterminate 3s infinite;transform:translateZ(0)}.el-progress-bar__inner--striped{background-image:linear-gradient(45deg,rgba(0,0,0,.1) 25%,transparent 0,transparent 50%,rgba(0,0,0,.1) 0,rgba(0,0,0,.1) 75%,transparent 0,transparent);background-size:1.25em 1.25em}.el-progress-bar__inner--striped.el-progress-bar__inner--striped-flow{-webkit-animation:striped-flow 3s linear infinite;animation:striped-flow 3s linear infinite}.el-progress-bar__innerText{color:#fff;display:inline-block;font-size:12px;margin:0 5px;vertical-align:middle}@-webkit-keyframes progress{0%{background-position:0 0}to{background-position:32px 0}}@keyframes progress{0%{background-position:0 0}to{background-position:32px 0}}@-webkit-keyframes indeterminate{0%{left:-100%}to{left:100%}}@keyframes indeterminate{0%{left:-100%}to{left:100%}}@-webkit-keyframes striped-flow{0%{background-position:-100%}to{background-position:100%}}@keyframes striped-flow{0%{background-position:-100%}to{background-position:100%}}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-selected:after{background-color:var(--el-color-primary);background-position:50%;background-repeat:no-repeat;border-right:none;border-top:none;content:"";height:12px;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;position:absolute;right:20px;top:50%;transform:translateY(-50%);width:12px}.el-select-dropdown{border-radius:var(--el-border-radius-base);box-sizing:border-box;z-index:calc(var(--el-index-top) + 1)}.el-select-dropdown .el-scrollbar.is-empty .el-select-dropdown__list{padding:0}.el-select-dropdown__empty,.el-select-dropdown__loading{color:var(--el-text-color-secondary);font-size:var(--el-select-font-size);margin:0;padding:10px 0;text-align:center}.el-select-dropdown__wrap{max-height:274px}.el-select-dropdown__list{box-sizing:border-box;list-style:none;margin:0;padding:6px 0}.el-select-dropdown__list.el-vl__window{margin:6px 0;padding:0}.el-select-dropdown__header{border-bottom:1px solid var(--el-border-color-light);padding:10px}.el-select-dropdown__footer{border-top:1px solid var(--el-border-color-light);padding:10px}.el-select-dropdown__item{box-sizing:border-box;color:var(--el-text-color-regular);cursor:pointer;font-size:var(--el-font-size-base);height:34px;line-height:34px;overflow:hidden;padding:0 32px 0 20px;position:relative;text-overflow:ellipsis;white-space:nowrap}.el-select-dropdown__item.is-hovering{background-color:var(--el-fill-color-light)}.el-select-dropdown__item.is-selected{color:var(--el-color-primary);font-weight:700}.el-select-dropdown__item.is-disabled{background-color:unset;color:var(--el-text-color-placeholder);cursor:not-allowed}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-selected:after{background-color:var(--el-color-primary);background-position:50%;background-repeat:no-repeat;border-right:none;border-top:none;content:"";height:12px;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;position:absolute;right:20px;top:50%;transform:translateY(-50%);width:12px}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-disabled:after{background-color:var(--el-text-color-placeholder)}.el-select-group{margin:0;padding:0}.el-select-group__wrap{list-style:none;margin:0;padding:0;position:relative}.el-select-group__wrap:not(:last-of-type){padding-bottom:24px}.el-select-group__wrap:not(:last-of-type):after{background:var(--el-border-color-light);bottom:12px;content:"";display:block;height:1px;left:20px;position:absolute;right:20px}.el-select-group__split-dash{background:var(--el-border-color-light);height:1px;left:20px;position:absolute;right:20px}.el-select-group__title{color:var(--el-color-info);font-size:12px;line-height:30px;padding-left:20px}.el-select-group .el-select-dropdown__item{padding-left:20px}.el-select{--el-select-border-color-hover:var(--el-border-color-hover);--el-select-disabled-color:var(--el-disabled-text-color);--el-select-disabled-border:var(--el-disabled-border-color);--el-select-font-size:var(--el-font-size-base);--el-select-close-hover-color:var(--el-text-color-secondary);--el-select-input-color:var(--el-text-color-placeholder);--el-select-multiple-input-color:var(--el-text-color-regular);--el-select-input-focus-border-color:var(--el-color-primary);--el-select-input-font-size:14px;--el-select-width:100%;display:inline-block;position:relative;vertical-align:middle;width:var(--el-select-width)}.el-select__wrapper{align-items:center;background-color:var(--el-fill-color-blank);border-radius:var(--el-border-radius-base);box-shadow:0 0 0 1px var(--el-border-color) inset;box-sizing:border-box;cursor:pointer;display:flex;font-size:14px;gap:6px;line-height:24px;min-height:32px;padding:4px 12px;position:relative;text-align:left;transition:var(--el-transition-duration)}.el-select__wrapper:hover{box-shadow:0 0 0 1px var(--el-text-color) inset}.el-select__wrapper.is-filterable{cursor:text}.el-select__wrapper.is-focused{box-shadow:0 0 0 1px var(--el-color-primary) inset}.el-select__wrapper.is-hovering:not(.is-focused){box-shadow:0 0 0 1px var(--el-border-color-hover) inset}.el-select__wrapper.is-disabled{background-color:var(--el-fill-color-light);box-shadow:0 0 0 1px var(--el-select-disabled-border) inset;color:var(--el-text-color-placeholder);cursor:not-allowed}.el-select__wrapper.is-disabled:hover{box-shadow:0 0 0 1px var(--el-select-disabled-border) inset}.el-select__wrapper.is-disabled.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-select__wrapper.is-disabled .el-select__selected-item{color:var(--el-select-disabled-color)}.el-select__wrapper.is-disabled .el-select__caret,.el-select__wrapper.is-disabled .el-tag{cursor:not-allowed}.el-select__prefix,.el-select__suffix{align-items:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:flex;flex-shrink:0;gap:6px}.el-select__caret{color:var(--el-select-input-color);cursor:pointer;font-size:var(--el-select-input-font-size);transform:rotate(0);transition:var(--el-transition-duration)}.el-select__caret.is-reverse{transform:rotate(180deg)}.el-select__selection{align-items:center;display:flex;flex:1;flex-wrap:wrap;gap:6px;min-width:0;position:relative}.el-select__selection.is-near{margin-left:-8px}.el-select__selection .el-tag{border-color:transparent;cursor:pointer}.el-select__selection .el-tag .el-tag__content{min-width:0}.el-select__selected-item{display:flex;flex-wrap:wrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-select__tags-text{line-height:normal}.el-select__placeholder,.el-select__tags-text{display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-select__placeholder{color:var(--el-input-text-color,var(--el-text-color-regular));position:absolute;top:50%;transform:translateY(-50%);width:100%}.el-select__placeholder.is-transparent{color:var(--el-text-color-placeholder);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-select__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-box-shadow-light)}.el-select__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-select__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-left-color:transparent;border-top-color:transparent}.el-select__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-select__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-bottom-color:transparent;border-left-color:transparent}.el-select__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-select__input-wrapper{max-width:100%}.el-select__input-wrapper.is-hidden{opacity:0;position:absolute}.el-select__input{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border:none;color:var(--el-select-multiple-input-color);font-family:inherit;font-size:inherit;height:24px;max-width:100%;outline:none;padding:0}.el-select__input.is-disabled{cursor:not-allowed}.el-select__input-calculator{left:0;max-width:100%;overflow:hidden;position:absolute;top:0;visibility:hidden;white-space:pre}.el-select--large .el-select__wrapper{font-size:14px;gap:6px;line-height:24px;min-height:40px;padding:8px 16px}.el-select--large .el-select__selection{gap:6px}.el-select--large .el-select__selection.is-near{margin-left:-8px}.el-select--large .el-select__prefix,.el-select--large .el-select__suffix{gap:6px}.el-select--large .el-select__input{height:24px}.el-select--small .el-select__wrapper{font-size:12px;gap:4px;line-height:20px;min-height:24px;padding:2px 8px}.el-select--small .el-select__selection{gap:4px}.el-select--small .el-select__selection.is-near{margin-left:-6px}.el-select--small .el-select__prefix,.el-select--small .el-select__suffix{gap:4px}.el-select--small .el-select__input{height:20px}.input-opt[data-v-b36666e5]>:first-child{width:100px}.form-item-upload[data-v-b36666e5]>:first-child{margin-left:0}.el-input-number--small[data-v-b36666e5]{line-height:22px;width:80px}.time-interval[data-v-b36666e5]{margin-top:10px;margin-right:1px;margin-left:1px}.el-pagination{--el-pagination-font-size:14px;--el-pagination-bg-color:var(--el-fill-color-blank);--el-pagination-text-color:var(--el-text-color-primary);--el-pagination-border-radius:2px;--el-pagination-button-color:var(--el-text-color-primary);--el-pagination-button-width:32px;--el-pagination-button-height:32px;--el-pagination-button-disabled-color:var(--el-text-color-placeholder);--el-pagination-button-disabled-bg-color:var(--el-fill-color-blank);--el-pagination-button-bg-color:var(--el-fill-color);--el-pagination-hover-color:var(--el-color-primary);--el-pagination-font-size-small:12px;--el-pagination-button-width-small:24px;--el-pagination-button-height-small:24px;--el-pagination-item-gap:16px;align-items:center;color:var(--el-pagination-text-color);display:flex;font-size:var(--el-pagination-font-size);font-weight:400;white-space:nowrap}.el-pagination .el-input__inner{-moz-appearance:textfield;text-align:center}.el-pagination .el-select{width:128px}.el-pagination button{align-items:center;background:var(--el-pagination-bg-color);border:none;border-radius:var(--el-pagination-border-radius);box-sizing:border-box;color:var(--el-pagination-button-color);cursor:pointer;display:flex;font-size:var(--el-pagination-font-size);height:var(--el-pagination-button-height);justify-content:center;line-height:var(--el-pagination-button-height);min-width:var(--el-pagination-button-width);padding:0 4px;text-align:center}.el-pagination button *{pointer-events:none}.el-pagination button:focus{outline:none}.el-pagination button:hover{color:var(--el-pagination-hover-color)}.el-pagination button.is-active{color:var(--el-pagination-hover-color);cursor:default;font-weight:700}.el-pagination button.is-active.is-disabled{color:var(--el-text-color-secondary);font-weight:700}.el-pagination button.is-disabled,.el-pagination button:disabled{background-color:var(--el-pagination-button-disabled-bg-color);color:var(--el-pagination-button-disabled-color);cursor:not-allowed}.el-pagination button:focus-visible{outline:1px solid var(--el-pagination-hover-color);outline-offset:-1px}.el-pagination .btn-next .el-icon,.el-pagination .btn-prev .el-icon{display:block;font-size:12px;font-weight:700;width:inherit}.el-pagination>.is-first{margin-left:0!important}.el-pagination>.is-last{margin-right:0!important}.el-pagination .btn-prev{margin-left:var(--el-pagination-item-gap)}.el-pagination__sizes,.el-pagination__total{color:var(--el-text-color-regular);font-weight:400;margin-left:var(--el-pagination-item-gap)}.el-pagination__total[disabled=true]{color:var(--el-text-color-placeholder)}.el-pagination__jump{align-items:center;color:var(--el-text-color-regular);display:flex;font-weight:400;margin-left:var(--el-pagination-item-gap)}.el-pagination__jump[disabled=true]{color:var(--el-text-color-placeholder)}.el-pagination__goto{margin-right:8px}.el-pagination__editor{box-sizing:border-box;text-align:center}.el-pagination__editor.el-input{width:56px}.el-pagination__editor .el-input__inner::-webkit-inner-spin-button,.el-pagination__editor .el-input__inner::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.el-pagination__classifier{margin-left:8px}.el-pagination__rightwrapper{align-items:center;display:flex;flex:1;justify-content:flex-end}.el-pagination.is-background .btn-next,.el-pagination.is-background .btn-prev,.el-pagination.is-background .el-pager li{background-color:var(--el-pagination-button-bg-color);margin:0 4px}.el-pagination.is-background .btn-next.is-active,.el-pagination.is-background .btn-prev.is-active,.el-pagination.is-background .el-pager li.is-active{background-color:var(--el-color-primary);color:var(--el-color-white)}.el-pagination.is-background .btn-next.is-disabled,.el-pagination.is-background .btn-next:disabled,.el-pagination.is-background .btn-prev.is-disabled,.el-pagination.is-background .btn-prev:disabled,.el-pagination.is-background .el-pager li.is-disabled,.el-pagination.is-background .el-pager li:disabled{background-color:var(--el-disabled-bg-color);color:var(--el-text-color-placeholder)}.el-pagination.is-background .btn-next.is-disabled.is-active,.el-pagination.is-background .btn-next:disabled.is-active,.el-pagination.is-background .btn-prev.is-disabled.is-active,.el-pagination.is-background .btn-prev:disabled.is-active,.el-pagination.is-background .el-pager li.is-disabled.is-active,.el-pagination.is-background .el-pager li:disabled.is-active{background-color:var(--el-fill-color-dark);color:var(--el-text-color-secondary)}.el-pagination.is-background .btn-prev{margin-left:var(--el-pagination-item-gap)}.el-pagination--small .btn-next,.el-pagination--small .btn-prev,.el-pagination--small .el-pager li{font-size:var(--el-pagination-font-size-small);height:var(--el-pagination-button-height-small);line-height:var(--el-pagination-button-height-small);min-width:var(--el-pagination-button-width-small)}.el-pagination--small button,.el-pagination--small span:not([class*=suffix]){font-size:var(--el-pagination-font-size-small)}.el-pagination--small .el-select{width:100px}.el-pager{font-size:0;list-style:none;margin:0;padding:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-pager,.el-pager li{align-items:center;display:flex}.el-pager li{background:var(--el-pagination-bg-color);border:none;border-radius:var(--el-pagination-border-radius);box-sizing:border-box;color:var(--el-pagination-button-color);cursor:pointer;font-size:var(--el-pagination-font-size);height:var(--el-pagination-button-height);justify-content:center;line-height:var(--el-pagination-button-height);min-width:var(--el-pagination-button-width);padding:0 4px;text-align:center}.el-pager li *{pointer-events:none}.el-pager li:focus{outline:none}.el-pager li:hover{color:var(--el-pagination-hover-color)}.el-pager li.is-active{color:var(--el-pagination-hover-color);cursor:default;font-weight:700}.el-pager li.is-active.is-disabled{color:var(--el-text-color-secondary);font-weight:700}.el-pager li.is-disabled,.el-pager li:disabled{background-color:var(--el-pagination-button-disabled-bg-color);color:var(--el-pagination-button-disabled-color);cursor:not-allowed}.el-pager li:focus-visible{outline:1px solid var(--el-pagination-hover-color);outline-offset:-1px}.el-row{box-sizing:border-box;display:flex;flex-wrap:wrap;position:relative}.el-row.is-justify-center{justify-content:center}.el-row.is-justify-end{justify-content:flex-end}.el-row.is-justify-space-between{justify-content:space-between}.el-row.is-justify-space-around{justify-content:space-around}.el-row.is-justify-space-evenly{justify-content:space-evenly}.el-row.is-align-top{align-items:flex-start}.el-row.is-align-middle{align-items:center}.el-row.is-align-bottom{align-items:flex-end}.el-picker__popper{--el-datepicker-border-color:var(--el-disabled-border-color)}.el-picker__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-datepicker-border-color);box-shadow:var(--el-box-shadow-light)}.el-picker__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-datepicker-border-color)}.el-picker__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-left-color:transparent;border-top-color:transparent}.el-picker__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-picker__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-bottom-color:transparent;border-left-color:transparent}.el-picker__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-date-editor{--el-date-editor-width:220px;--el-date-editor-monthrange-width:300px;--el-date-editor-daterange-width:350px;--el-date-editor-datetimerange-width:400px;--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;position:relative;text-align:left;vertical-align:middle}.el-date-editor.el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset}.el-date-editor.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-date-editor.el-input,.el-date-editor.el-input__wrapper{height:var(--el-input-height,var(--el-component-size));width:var(--el-date-editor-width)}.el-date-editor--monthrange{--el-date-editor-width:var(--el-date-editor-monthrange-width)}.el-date-editor--daterange,.el-date-editor--timerange{--el-date-editor-width:var(--el-date-editor-daterange-width)}.el-date-editor--datetimerange{--el-date-editor-width:var(--el-date-editor-datetimerange-width)}.el-date-editor--dates .el-input__wrapper{text-overflow:ellipsis;white-space:nowrap}.el-date-editor .clear-icon,.el-date-editor .close-icon{cursor:pointer}.el-date-editor .clear-icon:hover{color:var(--el-text-color-secondary)}.el-date-editor .el-range__icon{color:var(--el-text-color-placeholder);float:left;font-size:14px;height:inherit}.el-date-editor .el-range__icon svg{vertical-align:middle}.el-date-editor .el-range-input{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border:none;color:var(--el-text-color-regular);display:inline-block;font-size:var(--el-font-size-base);height:30px;line-height:30px;margin:0;outline:none;padding:0;text-align:center;width:39%}.el-date-editor .el-range-input::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-date-editor .el-range-input:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-date-editor .el-range-input::placeholder{color:var(--el-text-color-placeholder)}.el-date-editor .el-range-separator{align-items:center;color:var(--el-text-color-primary);display:inline-flex;flex:1;font-size:14px;height:100%;justify-content:center;margin:0;overflow-wrap:break-word;padding:0 5px}.el-date-editor .el-range__close-icon{color:var(--el-text-color-placeholder);cursor:pointer;font-size:14px;height:inherit;width:unset}.el-date-editor .el-range__close-icon:hover{color:var(--el-text-color-secondary)}.el-date-editor .el-range__close-icon svg{vertical-align:middle}.el-date-editor .el-range__close-icon--hidden{opacity:0;visibility:hidden}.el-range-editor.el-input__wrapper{align-items:center;display:inline-flex;padding:0 10px}.el-range-editor.is-active,.el-range-editor.is-active:hover{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-range-editor--large{line-height:var(--el-component-size-large)}.el-range-editor--large.el-input__wrapper{height:var(--el-component-size-large)}.el-range-editor--large .el-range-separator{font-size:14px;line-height:40px}.el-range-editor--large .el-range-input{font-size:14px;height:38px;line-height:38px}.el-range-editor--small{line-height:var(--el-component-size-small)}.el-range-editor--small.el-input__wrapper{height:var(--el-component-size-small)}.el-range-editor--small .el-range-separator{font-size:12px;line-height:24px}.el-range-editor--small .el-range-input{font-size:12px;height:22px;line-height:22px}.el-range-editor.is-disabled{background-color:var(--el-disabled-bg-color);border-color:var(--el-disabled-border-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-range-editor.is-disabled:focus,.el-range-editor.is-disabled:hover{border-color:var(--el-disabled-border-color)}.el-range-editor.is-disabled input{background-color:var(--el-disabled-bg-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-range-editor.is-disabled input::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-range-editor.is-disabled input:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-range-editor.is-disabled input::placeholder{color:var(--el-text-color-placeholder)}.el-range-editor.is-disabled .el-range-separator{color:var(--el-disabled-text-color)}.el-picker-panel{background:var(--el-bg-color-overlay);border-radius:var(--el-border-radius-base);color:var(--el-text-color-regular);line-height:30px}.el-picker-panel .el-time-panel{background-color:var(--el-bg-color-overlay);border:1px solid var(--el-datepicker-border-color);box-shadow:var(--el-box-shadow-light);margin:5px 0}.el-picker-panel__body-wrapper:after,.el-picker-panel__body:after{clear:both;content:"";display:table}.el-picker-panel__content{margin:15px;position:relative}.el-picker-panel__footer{background-color:var(--el-bg-color-overlay);border-top:1px solid var(--el-datepicker-inner-border-color);font-size:0;padding:4px 12px;position:relative;text-align:right}.el-picker-panel__shortcut{background-color:transparent;border:0;color:var(--el-datepicker-text-color);cursor:pointer;display:block;font-size:14px;line-height:28px;outline:none;padding-left:12px;text-align:left;width:100%}.el-picker-panel__shortcut:hover{color:var(--el-datepicker-hover-text-color)}.el-picker-panel__shortcut.active{background-color:#e6f1fe;color:var(--el-datepicker-active-color)}.el-picker-panel__btn{background-color:transparent;border:1px solid var(--el-fill-color-darker);border-radius:2px;color:var(--el-text-color-primary);cursor:pointer;font-size:12px;line-height:24px;outline:none;padding:0 20px}.el-picker-panel__btn[disabled]{color:var(--el-text-color-disabled);cursor:not-allowed}.el-picker-panel__icon-btn{background:transparent;border:0;color:var(--el-datepicker-icon-color);cursor:pointer;font-size:12px;margin-top:8px;outline:none}.el-picker-panel__icon-btn:hover{color:var(--el-datepicker-hover-text-color)}.el-picker-panel__icon-btn:focus-visible{color:var(--el-datepicker-hover-text-color)}.el-picker-panel__icon-btn.is-disabled{color:var(--el-text-color-disabled)}.el-picker-panel__icon-btn.is-disabled:hover{cursor:not-allowed}.el-picker-panel__icon-btn .el-icon{cursor:pointer;font-size:inherit}.el-picker-panel__link-btn{vertical-align:middle}.el-picker-panel [slot=sidebar],.el-picker-panel__sidebar{background-color:var(--el-bg-color-overlay);border-right:1px solid var(--el-datepicker-inner-border-color);bottom:0;box-sizing:border-box;overflow:auto;padding-top:6px;position:absolute;top:0;width:110px}.el-picker-panel [slot=sidebar]+.el-picker-panel__body,.el-picker-panel__sidebar+.el-picker-panel__body{margin-left:110px}.el-time-spinner.has-seconds .el-time-spinner__wrapper{width:33.3%}.el-time-spinner__wrapper{display:inline-block;max-height:192px;overflow:auto;position:relative;vertical-align:top;width:50%}.el-time-spinner__wrapper.el-scrollbar__wrap:not(.el-scrollbar__wrap--hidden-default){padding-bottom:15px}.el-time-spinner__wrapper.is-arrow{box-sizing:border-box;overflow:hidden;text-align:center}.el-time-spinner__wrapper.is-arrow .el-time-spinner__list{transform:translateY(-32px)}.el-time-spinner__wrapper.is-arrow .el-time-spinner__item:hover:not(.is-disabled):not(.is-active){background:var(--el-fill-color-light);cursor:default}.el-time-spinner__arrow{color:var(--el-text-color-secondary);cursor:pointer;font-size:12px;height:30px;left:0;line-height:30px;position:absolute;text-align:center;width:100%;z-index:var(--el-index-normal)}.el-time-spinner__arrow:hover{color:var(--el-color-primary)}.el-time-spinner__arrow.arrow-up{top:10px}.el-time-spinner__arrow.arrow-down{bottom:10px}.el-time-spinner__input.el-input{width:70%}.el-time-spinner__input.el-input .el-input__inner,.el-time-spinner__list{padding:0;text-align:center}.el-time-spinner__list{list-style:none;margin:0}.el-time-spinner__list:after,.el-time-spinner__list:before{content:"";display:block;height:80px;width:100%}.el-time-spinner__item{color:var(--el-text-color-regular);font-size:12px;height:32px;line-height:32px}.el-time-spinner__item:hover:not(.is-disabled):not(.is-active){background:var(--el-fill-color-light);cursor:pointer}.el-time-spinner__item.is-active:not(.is-disabled){color:var(--el-text-color-primary);font-weight:700}.el-time-spinner__item.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-time-panel{border-radius:2px;box-sizing:content-box;left:0;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:180px;z-index:var(--el-index-top)}.el-time-panel__content{font-size:0;overflow:hidden;position:relative}.el-time-panel__content:after,.el-time-panel__content:before{box-sizing:border-box;content:"";height:32px;left:0;margin-top:-16px;padding-top:6px;position:absolute;right:0;text-align:left;top:50%;z-index:-1}.el-time-panel__content:after{left:50%;margin-left:12%;margin-right:12%}.el-time-panel__content:before{border-bottom:1px solid var(--el-border-color-light);border-top:1px solid var(--el-border-color-light);margin-left:12%;margin-right:12%;padding-left:50%}.el-time-panel__content.has-seconds:after{left:66.6666666667%}.el-time-panel__content.has-seconds:before{padding-left:33.3333333333%}.el-time-panel__footer{border-top:1px solid var(--el-timepicker-inner-border-color,var(--el-border-color-light));box-sizing:border-box;height:36px;line-height:25px;padding:4px;text-align:right}.el-time-panel__btn{background-color:transparent;border:none;color:var(--el-text-color-primary);cursor:pointer;font-size:12px;line-height:28px;margin:0 5px;outline:none;padding:0 5px}.el-time-panel__btn.confirm{color:var(--el-timepicker-active-color,var(--el-color-primary));font-weight:800}.el-time-range-picker{overflow:visible;width:354px}.el-time-range-picker__content{padding:10px;position:relative;text-align:center;z-index:1}.el-time-range-picker__cell{box-sizing:border-box;display:inline-block;margin:0;padding:4px 7px 7px;width:50%}.el-time-range-picker__header{font-size:14px;margin-bottom:5px;text-align:center}.el-time-range-picker__body{border:1px solid var(--el-datepicker-border-color);border-radius:2px}[class*=el-col-]{box-sizing:border-box}[class*=el-col-].is-guttered{display:block;min-height:1px}.el-col-0,.el-col-0.is-guttered{display:none}.el-col-0{flex:0 0 0%;max-width:0}.el-col-offset-0{margin-left:0}.el-col-pull-0{position:relative;right:0}.el-col-push-0{left:0;position:relative}.el-col-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-offset-1{margin-left:4.1666666667%}.el-col-pull-1{position:relative;right:4.1666666667%}.el-col-push-1{left:4.1666666667%;position:relative}.el-col-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-offset-2{margin-left:8.3333333333%}.el-col-pull-2{position:relative;right:8.3333333333%}.el-col-push-2{left:8.3333333333%;position:relative}.el-col-3{flex:0 0 12.5%;max-width:12.5%}.el-col-offset-3{margin-left:12.5%}.el-col-pull-3{position:relative;right:12.5%}.el-col-push-3{left:12.5%;position:relative}.el-col-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-offset-4{margin-left:16.6666666667%}.el-col-pull-4{position:relative;right:16.6666666667%}.el-col-push-4{left:16.6666666667%;position:relative}.el-col-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-offset-5{margin-left:20.8333333333%}.el-col-pull-5{position:relative;right:20.8333333333%}.el-col-push-5{left:20.8333333333%;position:relative}.el-col-6{flex:0 0 25%;max-width:25%}.el-col-offset-6{margin-left:25%}.el-col-pull-6{position:relative;right:25%}.el-col-push-6{left:25%;position:relative}.el-col-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-offset-7{margin-left:29.1666666667%}.el-col-pull-7{position:relative;right:29.1666666667%}.el-col-push-7{left:29.1666666667%;position:relative}.el-col-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-offset-8{margin-left:33.3333333333%}.el-col-pull-8{position:relative;right:33.3333333333%}.el-col-push-8{left:33.3333333333%;position:relative}.el-col-9{flex:0 0 37.5%;max-width:37.5%}.el-col-offset-9{margin-left:37.5%}.el-col-pull-9{position:relative;right:37.5%}.el-col-push-9{left:37.5%;position:relative}.el-col-10{flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-offset-10{margin-left:41.6666666667%}.el-col-pull-10{position:relative;right:41.6666666667%}.el-col-push-10{left:41.6666666667%;position:relative}.el-col-11{flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-offset-11{margin-left:45.8333333333%}.el-col-pull-11{position:relative;right:45.8333333333%}.el-col-push-11{left:45.8333333333%;position:relative}.el-col-12{flex:0 0 50%;max-width:50%}.el-col-offset-12{margin-left:50%}.el-col-pull-12{position:relative;right:50%}.el-col-push-12{left:50%;position:relative}.el-col-13{flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-offset-13{margin-left:54.1666666667%}.el-col-pull-13{position:relative;right:54.1666666667%}.el-col-push-13{left:54.1666666667%;position:relative}.el-col-14{flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-offset-14{margin-left:58.3333333333%}.el-col-pull-14{position:relative;right:58.3333333333%}.el-col-push-14{left:58.3333333333%;position:relative}.el-col-15{flex:0 0 62.5%;max-width:62.5%}.el-col-offset-15{margin-left:62.5%}.el-col-pull-15{position:relative;right:62.5%}.el-col-push-15{left:62.5%;position:relative}.el-col-16{flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-offset-16{margin-left:66.6666666667%}.el-col-pull-16{position:relative;right:66.6666666667%}.el-col-push-16{left:66.6666666667%;position:relative}.el-col-17{flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-offset-17{margin-left:70.8333333333%}.el-col-pull-17{position:relative;right:70.8333333333%}.el-col-push-17{left:70.8333333333%;position:relative}.el-col-18{flex:0 0 75%;max-width:75%}.el-col-offset-18{margin-left:75%}.el-col-pull-18{position:relative;right:75%}.el-col-push-18{left:75%;position:relative}.el-col-19{flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-offset-19{margin-left:79.1666666667%}.el-col-pull-19{position:relative;right:79.1666666667%}.el-col-push-19{left:79.1666666667%;position:relative}.el-col-20{flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-offset-20{margin-left:83.3333333333%}.el-col-pull-20{position:relative;right:83.3333333333%}.el-col-push-20{left:83.3333333333%;position:relative}.el-col-21{flex:0 0 87.5%;max-width:87.5%}.el-col-offset-21{margin-left:87.5%}.el-col-pull-21{position:relative;right:87.5%}.el-col-push-21{left:87.5%;position:relative}.el-col-22{flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-offset-22{margin-left:91.6666666667%}.el-col-pull-22{position:relative;right:91.6666666667%}.el-col-push-22{left:91.6666666667%;position:relative}.el-col-23{flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-offset-23{margin-left:95.8333333333%}.el-col-pull-23{position:relative;right:95.8333333333%}.el-col-push-23{left:95.8333333333%;position:relative}.el-col-24{flex:0 0 100%;max-width:100%}.el-col-offset-24{margin-left:100%}.el-col-pull-24{position:relative;right:100%}.el-col-push-24{left:100%;position:relative}@media only screen and (max-width:767px){.el-col-xs-0,.el-col-xs-0.is-guttered{display:none}.el-col-xs-0{flex:0 0 0%;max-width:0}.el-col-xs-offset-0{margin-left:0}.el-col-xs-pull-0{position:relative;right:0}.el-col-xs-push-0{left:0;position:relative}.el-col-xs-1{display:block;flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-xs-offset-1{margin-left:4.1666666667%}.el-col-xs-pull-1{position:relative;right:4.1666666667%}.el-col-xs-push-1{left:4.1666666667%;position:relative}.el-col-xs-2{display:block;flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-xs-offset-2{margin-left:8.3333333333%}.el-col-xs-pull-2{position:relative;right:8.3333333333%}.el-col-xs-push-2{left:8.3333333333%;position:relative}.el-col-xs-3{display:block;flex:0 0 12.5%;max-width:12.5%}.el-col-xs-offset-3{margin-left:12.5%}.el-col-xs-pull-3{position:relative;right:12.5%}.el-col-xs-push-3{left:12.5%;position:relative}.el-col-xs-4{display:block;flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-xs-offset-4{margin-left:16.6666666667%}.el-col-xs-pull-4{position:relative;right:16.6666666667%}.el-col-xs-push-4{left:16.6666666667%;position:relative}.el-col-xs-5{display:block;flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-xs-offset-5{margin-left:20.8333333333%}.el-col-xs-pull-5{position:relative;right:20.8333333333%}.el-col-xs-push-5{left:20.8333333333%;position:relative}.el-col-xs-6{display:block;flex:0 0 25%;max-width:25%}.el-col-xs-offset-6{margin-left:25%}.el-col-xs-pull-6{position:relative;right:25%}.el-col-xs-push-6{left:25%;position:relative}.el-col-xs-7{display:block;flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-xs-offset-7{margin-left:29.1666666667%}.el-col-xs-pull-7{position:relative;right:29.1666666667%}.el-col-xs-push-7{left:29.1666666667%;position:relative}.el-col-xs-8{display:block;flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-xs-offset-8{margin-left:33.3333333333%}.el-col-xs-pull-8{position:relative;right:33.3333333333%}.el-col-xs-push-8{left:33.3333333333%;position:relative}.el-col-xs-9{display:block;flex:0 0 37.5%;max-width:37.5%}.el-col-xs-offset-9{margin-left:37.5%}.el-col-xs-pull-9{position:relative;right:37.5%}.el-col-xs-push-9{left:37.5%;position:relative}.el-col-xs-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-xs-offset-10{margin-left:41.6666666667%}.el-col-xs-pull-10{position:relative;right:41.6666666667%}.el-col-xs-push-10{left:41.6666666667%;position:relative}.el-col-xs-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-xs-offset-11{margin-left:45.8333333333%}.el-col-xs-pull-11{position:relative;right:45.8333333333%}.el-col-xs-push-11{left:45.8333333333%;position:relative}.el-col-xs-12{display:block;flex:0 0 50%;max-width:50%}.el-col-xs-offset-12{margin-left:50%}.el-col-xs-pull-12{position:relative;right:50%}.el-col-xs-push-12{left:50%;position:relative}.el-col-xs-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-xs-offset-13{margin-left:54.1666666667%}.el-col-xs-pull-13{position:relative;right:54.1666666667%}.el-col-xs-push-13{left:54.1666666667%;position:relative}.el-col-xs-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-xs-offset-14{margin-left:58.3333333333%}.el-col-xs-pull-14{position:relative;right:58.3333333333%}.el-col-xs-push-14{left:58.3333333333%;position:relative}.el-col-xs-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-xs-offset-15{margin-left:62.5%}.el-col-xs-pull-15{position:relative;right:62.5%}.el-col-xs-push-15{left:62.5%;position:relative}.el-col-xs-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-xs-offset-16{margin-left:66.6666666667%}.el-col-xs-pull-16{position:relative;right:66.6666666667%}.el-col-xs-push-16{left:66.6666666667%;position:relative}.el-col-xs-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-xs-offset-17{margin-left:70.8333333333%}.el-col-xs-pull-17{position:relative;right:70.8333333333%}.el-col-xs-push-17{left:70.8333333333%;position:relative}.el-col-xs-18{display:block;flex:0 0 75%;max-width:75%}.el-col-xs-offset-18{margin-left:75%}.el-col-xs-pull-18{position:relative;right:75%}.el-col-xs-push-18{left:75%;position:relative}.el-col-xs-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-xs-offset-19{margin-left:79.1666666667%}.el-col-xs-pull-19{position:relative;right:79.1666666667%}.el-col-xs-push-19{left:79.1666666667%;position:relative}.el-col-xs-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-xs-offset-20{margin-left:83.3333333333%}.el-col-xs-pull-20{position:relative;right:83.3333333333%}.el-col-xs-push-20{left:83.3333333333%;position:relative}.el-col-xs-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-xs-offset-21{margin-left:87.5%}.el-col-xs-pull-21{position:relative;right:87.5%}.el-col-xs-push-21{left:87.5%;position:relative}.el-col-xs-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-xs-offset-22{margin-left:91.6666666667%}.el-col-xs-pull-22{position:relative;right:91.6666666667%}.el-col-xs-push-22{left:91.6666666667%;position:relative}.el-col-xs-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-xs-offset-23{margin-left:95.8333333333%}.el-col-xs-pull-23{position:relative;right:95.8333333333%}.el-col-xs-push-23{left:95.8333333333%;position:relative}.el-col-xs-24{display:block;flex:0 0 100%;max-width:100%}.el-col-xs-offset-24{margin-left:100%}.el-col-xs-pull-24{position:relative;right:100%}.el-col-xs-push-24{left:100%;position:relative}}@media only screen and (min-width:768px){.el-col-sm-0,.el-col-sm-0.is-guttered{display:none}.el-col-sm-0{flex:0 0 0%;max-width:0}.el-col-sm-offset-0{margin-left:0}.el-col-sm-pull-0{position:relative;right:0}.el-col-sm-push-0{left:0;position:relative}.el-col-sm-1{display:block;flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-sm-offset-1{margin-left:4.1666666667%}.el-col-sm-pull-1{position:relative;right:4.1666666667%}.el-col-sm-push-1{left:4.1666666667%;position:relative}.el-col-sm-2{display:block;flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-sm-offset-2{margin-left:8.3333333333%}.el-col-sm-pull-2{position:relative;right:8.3333333333%}.el-col-sm-push-2{left:8.3333333333%;position:relative}.el-col-sm-3{display:block;flex:0 0 12.5%;max-width:12.5%}.el-col-sm-offset-3{margin-left:12.5%}.el-col-sm-pull-3{position:relative;right:12.5%}.el-col-sm-push-3{left:12.5%;position:relative}.el-col-sm-4{display:block;flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-sm-offset-4{margin-left:16.6666666667%}.el-col-sm-pull-4{position:relative;right:16.6666666667%}.el-col-sm-push-4{left:16.6666666667%;position:relative}.el-col-sm-5{display:block;flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-sm-offset-5{margin-left:20.8333333333%}.el-col-sm-pull-5{position:relative;right:20.8333333333%}.el-col-sm-push-5{left:20.8333333333%;position:relative}.el-col-sm-6{display:block;flex:0 0 25%;max-width:25%}.el-col-sm-offset-6{margin-left:25%}.el-col-sm-pull-6{position:relative;right:25%}.el-col-sm-push-6{left:25%;position:relative}.el-col-sm-7{display:block;flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-sm-offset-7{margin-left:29.1666666667%}.el-col-sm-pull-7{position:relative;right:29.1666666667%}.el-col-sm-push-7{left:29.1666666667%;position:relative}.el-col-sm-8{display:block;flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-sm-offset-8{margin-left:33.3333333333%}.el-col-sm-pull-8{position:relative;right:33.3333333333%}.el-col-sm-push-8{left:33.3333333333%;position:relative}.el-col-sm-9{display:block;flex:0 0 37.5%;max-width:37.5%}.el-col-sm-offset-9{margin-left:37.5%}.el-col-sm-pull-9{position:relative;right:37.5%}.el-col-sm-push-9{left:37.5%;position:relative}.el-col-sm-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-sm-offset-10{margin-left:41.6666666667%}.el-col-sm-pull-10{position:relative;right:41.6666666667%}.el-col-sm-push-10{left:41.6666666667%;position:relative}.el-col-sm-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-sm-offset-11{margin-left:45.8333333333%}.el-col-sm-pull-11{position:relative;right:45.8333333333%}.el-col-sm-push-11{left:45.8333333333%;position:relative}.el-col-sm-12{display:block;flex:0 0 50%;max-width:50%}.el-col-sm-offset-12{margin-left:50%}.el-col-sm-pull-12{position:relative;right:50%}.el-col-sm-push-12{left:50%;position:relative}.el-col-sm-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-sm-offset-13{margin-left:54.1666666667%}.el-col-sm-pull-13{position:relative;right:54.1666666667%}.el-col-sm-push-13{left:54.1666666667%;position:relative}.el-col-sm-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-sm-offset-14{margin-left:58.3333333333%}.el-col-sm-pull-14{position:relative;right:58.3333333333%}.el-col-sm-push-14{left:58.3333333333%;position:relative}.el-col-sm-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-sm-offset-15{margin-left:62.5%}.el-col-sm-pull-15{position:relative;right:62.5%}.el-col-sm-push-15{left:62.5%;position:relative}.el-col-sm-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-sm-offset-16{margin-left:66.6666666667%}.el-col-sm-pull-16{position:relative;right:66.6666666667%}.el-col-sm-push-16{left:66.6666666667%;position:relative}.el-col-sm-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-sm-offset-17{margin-left:70.8333333333%}.el-col-sm-pull-17{position:relative;right:70.8333333333%}.el-col-sm-push-17{left:70.8333333333%;position:relative}.el-col-sm-18{display:block;flex:0 0 75%;max-width:75%}.el-col-sm-offset-18{margin-left:75%}.el-col-sm-pull-18{position:relative;right:75%}.el-col-sm-push-18{left:75%;position:relative}.el-col-sm-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-sm-offset-19{margin-left:79.1666666667%}.el-col-sm-pull-19{position:relative;right:79.1666666667%}.el-col-sm-push-19{left:79.1666666667%;position:relative}.el-col-sm-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-sm-offset-20{margin-left:83.3333333333%}.el-col-sm-pull-20{position:relative;right:83.3333333333%}.el-col-sm-push-20{left:83.3333333333%;position:relative}.el-col-sm-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-sm-offset-21{margin-left:87.5%}.el-col-sm-pull-21{position:relative;right:87.5%}.el-col-sm-push-21{left:87.5%;position:relative}.el-col-sm-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-sm-offset-22{margin-left:91.6666666667%}.el-col-sm-pull-22{position:relative;right:91.6666666667%}.el-col-sm-push-22{left:91.6666666667%;position:relative}.el-col-sm-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-sm-offset-23{margin-left:95.8333333333%}.el-col-sm-pull-23{position:relative;right:95.8333333333%}.el-col-sm-push-23{left:95.8333333333%;position:relative}.el-col-sm-24{display:block;flex:0 0 100%;max-width:100%}.el-col-sm-offset-24{margin-left:100%}.el-col-sm-pull-24{position:relative;right:100%}.el-col-sm-push-24{left:100%;position:relative}}@media only screen and (min-width:992px){.el-col-md-0,.el-col-md-0.is-guttered{display:none}.el-col-md-0{flex:0 0 0%;max-width:0}.el-col-md-offset-0{margin-left:0}.el-col-md-pull-0{position:relative;right:0}.el-col-md-push-0{left:0;position:relative}.el-col-md-1{display:block;flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-md-offset-1{margin-left:4.1666666667%}.el-col-md-pull-1{position:relative;right:4.1666666667%}.el-col-md-push-1{left:4.1666666667%;position:relative}.el-col-md-2{display:block;flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-md-offset-2{margin-left:8.3333333333%}.el-col-md-pull-2{position:relative;right:8.3333333333%}.el-col-md-push-2{left:8.3333333333%;position:relative}.el-col-md-3{display:block;flex:0 0 12.5%;max-width:12.5%}.el-col-md-offset-3{margin-left:12.5%}.el-col-md-pull-3{position:relative;right:12.5%}.el-col-md-push-3{left:12.5%;position:relative}.el-col-md-4{display:block;flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-md-offset-4{margin-left:16.6666666667%}.el-col-md-pull-4{position:relative;right:16.6666666667%}.el-col-md-push-4{left:16.6666666667%;position:relative}.el-col-md-5{display:block;flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-md-offset-5{margin-left:20.8333333333%}.el-col-md-pull-5{position:relative;right:20.8333333333%}.el-col-md-push-5{left:20.8333333333%;position:relative}.el-col-md-6{display:block;flex:0 0 25%;max-width:25%}.el-col-md-offset-6{margin-left:25%}.el-col-md-pull-6{position:relative;right:25%}.el-col-md-push-6{left:25%;position:relative}.el-col-md-7{display:block;flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-md-offset-7{margin-left:29.1666666667%}.el-col-md-pull-7{position:relative;right:29.1666666667%}.el-col-md-push-7{left:29.1666666667%;position:relative}.el-col-md-8{display:block;flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-md-offset-8{margin-left:33.3333333333%}.el-col-md-pull-8{position:relative;right:33.3333333333%}.el-col-md-push-8{left:33.3333333333%;position:relative}.el-col-md-9{display:block;flex:0 0 37.5%;max-width:37.5%}.el-col-md-offset-9{margin-left:37.5%}.el-col-md-pull-9{position:relative;right:37.5%}.el-col-md-push-9{left:37.5%;position:relative}.el-col-md-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-md-offset-10{margin-left:41.6666666667%}.el-col-md-pull-10{position:relative;right:41.6666666667%}.el-col-md-push-10{left:41.6666666667%;position:relative}.el-col-md-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-md-offset-11{margin-left:45.8333333333%}.el-col-md-pull-11{position:relative;right:45.8333333333%}.el-col-md-push-11{left:45.8333333333%;position:relative}.el-col-md-12{display:block;flex:0 0 50%;max-width:50%}.el-col-md-offset-12{margin-left:50%}.el-col-md-pull-12{position:relative;right:50%}.el-col-md-push-12{left:50%;position:relative}.el-col-md-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-md-offset-13{margin-left:54.1666666667%}.el-col-md-pull-13{position:relative;right:54.1666666667%}.el-col-md-push-13{left:54.1666666667%;position:relative}.el-col-md-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-md-offset-14{margin-left:58.3333333333%}.el-col-md-pull-14{position:relative;right:58.3333333333%}.el-col-md-push-14{left:58.3333333333%;position:relative}.el-col-md-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-md-offset-15{margin-left:62.5%}.el-col-md-pull-15{position:relative;right:62.5%}.el-col-md-push-15{left:62.5%;position:relative}.el-col-md-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-md-offset-16{margin-left:66.6666666667%}.el-col-md-pull-16{position:relative;right:66.6666666667%}.el-col-md-push-16{left:66.6666666667%;position:relative}.el-col-md-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-md-offset-17{margin-left:70.8333333333%}.el-col-md-pull-17{position:relative;right:70.8333333333%}.el-col-md-push-17{left:70.8333333333%;position:relative}.el-col-md-18{display:block;flex:0 0 75%;max-width:75%}.el-col-md-offset-18{margin-left:75%}.el-col-md-pull-18{position:relative;right:75%}.el-col-md-push-18{left:75%;position:relative}.el-col-md-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-md-offset-19{margin-left:79.1666666667%}.el-col-md-pull-19{position:relative;right:79.1666666667%}.el-col-md-push-19{left:79.1666666667%;position:relative}.el-col-md-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-md-offset-20{margin-left:83.3333333333%}.el-col-md-pull-20{position:relative;right:83.3333333333%}.el-col-md-push-20{left:83.3333333333%;position:relative}.el-col-md-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-md-offset-21{margin-left:87.5%}.el-col-md-pull-21{position:relative;right:87.5%}.el-col-md-push-21{left:87.5%;position:relative}.el-col-md-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-md-offset-22{margin-left:91.6666666667%}.el-col-md-pull-22{position:relative;right:91.6666666667%}.el-col-md-push-22{left:91.6666666667%;position:relative}.el-col-md-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-md-offset-23{margin-left:95.8333333333%}.el-col-md-pull-23{position:relative;right:95.8333333333%}.el-col-md-push-23{left:95.8333333333%;position:relative}.el-col-md-24{display:block;flex:0 0 100%;max-width:100%}.el-col-md-offset-24{margin-left:100%}.el-col-md-pull-24{position:relative;right:100%}.el-col-md-push-24{left:100%;position:relative}}@media only screen and (min-width:1200px){.el-col-lg-0,.el-col-lg-0.is-guttered{display:none}.el-col-lg-0{flex:0 0 0%;max-width:0}.el-col-lg-offset-0{margin-left:0}.el-col-lg-pull-0{position:relative;right:0}.el-col-lg-push-0{left:0;position:relative}.el-col-lg-1{display:block;flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-lg-offset-1{margin-left:4.1666666667%}.el-col-lg-pull-1{position:relative;right:4.1666666667%}.el-col-lg-push-1{left:4.1666666667%;position:relative}.el-col-lg-2{display:block;flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-lg-offset-2{margin-left:8.3333333333%}.el-col-lg-pull-2{position:relative;right:8.3333333333%}.el-col-lg-push-2{left:8.3333333333%;position:relative}.el-col-lg-3{display:block;flex:0 0 12.5%;max-width:12.5%}.el-col-lg-offset-3{margin-left:12.5%}.el-col-lg-pull-3{position:relative;right:12.5%}.el-col-lg-push-3{left:12.5%;position:relative}.el-col-lg-4{display:block;flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-lg-offset-4{margin-left:16.6666666667%}.el-col-lg-pull-4{position:relative;right:16.6666666667%}.el-col-lg-push-4{left:16.6666666667%;position:relative}.el-col-lg-5{display:block;flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-lg-offset-5{margin-left:20.8333333333%}.el-col-lg-pull-5{position:relative;right:20.8333333333%}.el-col-lg-push-5{left:20.8333333333%;position:relative}.el-col-lg-6{display:block;flex:0 0 25%;max-width:25%}.el-col-lg-offset-6{margin-left:25%}.el-col-lg-pull-6{position:relative;right:25%}.el-col-lg-push-6{left:25%;position:relative}.el-col-lg-7{display:block;flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-lg-offset-7{margin-left:29.1666666667%}.el-col-lg-pull-7{position:relative;right:29.1666666667%}.el-col-lg-push-7{left:29.1666666667%;position:relative}.el-col-lg-8{display:block;flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-lg-offset-8{margin-left:33.3333333333%}.el-col-lg-pull-8{position:relative;right:33.3333333333%}.el-col-lg-push-8{left:33.3333333333%;position:relative}.el-col-lg-9{display:block;flex:0 0 37.5%;max-width:37.5%}.el-col-lg-offset-9{margin-left:37.5%}.el-col-lg-pull-9{position:relative;right:37.5%}.el-col-lg-push-9{left:37.5%;position:relative}.el-col-lg-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-lg-offset-10{margin-left:41.6666666667%}.el-col-lg-pull-10{position:relative;right:41.6666666667%}.el-col-lg-push-10{left:41.6666666667%;position:relative}.el-col-lg-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-lg-offset-11{margin-left:45.8333333333%}.el-col-lg-pull-11{position:relative;right:45.8333333333%}.el-col-lg-push-11{left:45.8333333333%;position:relative}.el-col-lg-12{display:block;flex:0 0 50%;max-width:50%}.el-col-lg-offset-12{margin-left:50%}.el-col-lg-pull-12{position:relative;right:50%}.el-col-lg-push-12{left:50%;position:relative}.el-col-lg-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-lg-offset-13{margin-left:54.1666666667%}.el-col-lg-pull-13{position:relative;right:54.1666666667%}.el-col-lg-push-13{left:54.1666666667%;position:relative}.el-col-lg-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-lg-offset-14{margin-left:58.3333333333%}.el-col-lg-pull-14{position:relative;right:58.3333333333%}.el-col-lg-push-14{left:58.3333333333%;position:relative}.el-col-lg-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-lg-offset-15{margin-left:62.5%}.el-col-lg-pull-15{position:relative;right:62.5%}.el-col-lg-push-15{left:62.5%;position:relative}.el-col-lg-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-lg-offset-16{margin-left:66.6666666667%}.el-col-lg-pull-16{position:relative;right:66.6666666667%}.el-col-lg-push-16{left:66.6666666667%;position:relative}.el-col-lg-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-lg-offset-17{margin-left:70.8333333333%}.el-col-lg-pull-17{position:relative;right:70.8333333333%}.el-col-lg-push-17{left:70.8333333333%;position:relative}.el-col-lg-18{display:block;flex:0 0 75%;max-width:75%}.el-col-lg-offset-18{margin-left:75%}.el-col-lg-pull-18{position:relative;right:75%}.el-col-lg-push-18{left:75%;position:relative}.el-col-lg-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-lg-offset-19{margin-left:79.1666666667%}.el-col-lg-pull-19{position:relative;right:79.1666666667%}.el-col-lg-push-19{left:79.1666666667%;position:relative}.el-col-lg-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-lg-offset-20{margin-left:83.3333333333%}.el-col-lg-pull-20{position:relative;right:83.3333333333%}.el-col-lg-push-20{left:83.3333333333%;position:relative}.el-col-lg-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-lg-offset-21{margin-left:87.5%}.el-col-lg-pull-21{position:relative;right:87.5%}.el-col-lg-push-21{left:87.5%;position:relative}.el-col-lg-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-lg-offset-22{margin-left:91.6666666667%}.el-col-lg-pull-22{position:relative;right:91.6666666667%}.el-col-lg-push-22{left:91.6666666667%;position:relative}.el-col-lg-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-lg-offset-23{margin-left:95.8333333333%}.el-col-lg-pull-23{position:relative;right:95.8333333333%}.el-col-lg-push-23{left:95.8333333333%;position:relative}.el-col-lg-24{display:block;flex:0 0 100%;max-width:100%}.el-col-lg-offset-24{margin-left:100%}.el-col-lg-pull-24{position:relative;right:100%}.el-col-lg-push-24{left:100%;position:relative}}@media only screen and (min-width:1920px){.el-col-xl-0,.el-col-xl-0.is-guttered{display:none}.el-col-xl-0{flex:0 0 0%;max-width:0}.el-col-xl-offset-0{margin-left:0}.el-col-xl-pull-0{position:relative;right:0}.el-col-xl-push-0{left:0;position:relative}.el-col-xl-1{display:block;flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-xl-offset-1{margin-left:4.1666666667%}.el-col-xl-pull-1{position:relative;right:4.1666666667%}.el-col-xl-push-1{left:4.1666666667%;position:relative}.el-col-xl-2{display:block;flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-xl-offset-2{margin-left:8.3333333333%}.el-col-xl-pull-2{position:relative;right:8.3333333333%}.el-col-xl-push-2{left:8.3333333333%;position:relative}.el-col-xl-3{display:block;flex:0 0 12.5%;max-width:12.5%}.el-col-xl-offset-3{margin-left:12.5%}.el-col-xl-pull-3{position:relative;right:12.5%}.el-col-xl-push-3{left:12.5%;position:relative}.el-col-xl-4{display:block;flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-xl-offset-4{margin-left:16.6666666667%}.el-col-xl-pull-4{position:relative;right:16.6666666667%}.el-col-xl-push-4{left:16.6666666667%;position:relative}.el-col-xl-5{display:block;flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-xl-offset-5{margin-left:20.8333333333%}.el-col-xl-pull-5{position:relative;right:20.8333333333%}.el-col-xl-push-5{left:20.8333333333%;position:relative}.el-col-xl-6{display:block;flex:0 0 25%;max-width:25%}.el-col-xl-offset-6{margin-left:25%}.el-col-xl-pull-6{position:relative;right:25%}.el-col-xl-push-6{left:25%;position:relative}.el-col-xl-7{display:block;flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-xl-offset-7{margin-left:29.1666666667%}.el-col-xl-pull-7{position:relative;right:29.1666666667%}.el-col-xl-push-7{left:29.1666666667%;position:relative}.el-col-xl-8{display:block;flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-xl-offset-8{margin-left:33.3333333333%}.el-col-xl-pull-8{position:relative;right:33.3333333333%}.el-col-xl-push-8{left:33.3333333333%;position:relative}.el-col-xl-9{display:block;flex:0 0 37.5%;max-width:37.5%}.el-col-xl-offset-9{margin-left:37.5%}.el-col-xl-pull-9{position:relative;right:37.5%}.el-col-xl-push-9{left:37.5%;position:relative}.el-col-xl-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-xl-offset-10{margin-left:41.6666666667%}.el-col-xl-pull-10{position:relative;right:41.6666666667%}.el-col-xl-push-10{left:41.6666666667%;position:relative}.el-col-xl-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-xl-offset-11{margin-left:45.8333333333%}.el-col-xl-pull-11{position:relative;right:45.8333333333%}.el-col-xl-push-11{left:45.8333333333%;position:relative}.el-col-xl-12{display:block;flex:0 0 50%;max-width:50%}.el-col-xl-offset-12{margin-left:50%}.el-col-xl-pull-12{position:relative;right:50%}.el-col-xl-push-12{left:50%;position:relative}.el-col-xl-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-xl-offset-13{margin-left:54.1666666667%}.el-col-xl-pull-13{position:relative;right:54.1666666667%}.el-col-xl-push-13{left:54.1666666667%;position:relative}.el-col-xl-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-xl-offset-14{margin-left:58.3333333333%}.el-col-xl-pull-14{position:relative;right:58.3333333333%}.el-col-xl-push-14{left:58.3333333333%;position:relative}.el-col-xl-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-xl-offset-15{margin-left:62.5%}.el-col-xl-pull-15{position:relative;right:62.5%}.el-col-xl-push-15{left:62.5%;position:relative}.el-col-xl-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-xl-offset-16{margin-left:66.6666666667%}.el-col-xl-pull-16{position:relative;right:66.6666666667%}.el-col-xl-push-16{left:66.6666666667%;position:relative}.el-col-xl-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-xl-offset-17{margin-left:70.8333333333%}.el-col-xl-pull-17{position:relative;right:70.8333333333%}.el-col-xl-push-17{left:70.8333333333%;position:relative}.el-col-xl-18{display:block;flex:0 0 75%;max-width:75%}.el-col-xl-offset-18{margin-left:75%}.el-col-xl-pull-18{position:relative;right:75%}.el-col-xl-push-18{left:75%;position:relative}.el-col-xl-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-xl-offset-19{margin-left:79.1666666667%}.el-col-xl-pull-19{position:relative;right:79.1666666667%}.el-col-xl-push-19{left:79.1666666667%;position:relative}.el-col-xl-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-xl-offset-20{margin-left:83.3333333333%}.el-col-xl-pull-20{position:relative;right:83.3333333333%}.el-col-xl-push-20{left:83.3333333333%;position:relative}.el-col-xl-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-xl-offset-21{margin-left:87.5%}.el-col-xl-pull-21{position:relative;right:87.5%}.el-col-xl-push-21{left:87.5%;position:relative}.el-col-xl-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-xl-offset-22{margin-left:91.6666666667%}.el-col-xl-pull-22{position:relative;right:91.6666666667%}.el-col-xl-push-22{left:91.6666666667%;position:relative}.el-col-xl-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-xl-offset-23{margin-left:95.8333333333%}.el-col-xl-pull-23{position:relative;right:95.8333333333%}.el-col-xl-push-23{left:95.8333333333%;position:relative}.el-col-xl-24{display:block;flex:0 0 100%;max-width:100%}.el-col-xl-offset-24{margin-left:100%}.el-col-xl-pull-24{position:relative;right:100%}.el-col-xl-push-24{left:100%;position:relative}}.filter-bar[data-v-de025004]{margin-bottom:20px}.markdown-container[data-v-65b48a9b]{padding:16px;background-color:#f9f9f9;border-radius:8px;font-family:Arial,sans-serif;line-height:1.6;color:#333}.markdown-container h1[data-v-65b48a9b]{font-size:2em;margin-bottom:.5em;color:#222}.markdown-container h2[data-v-65b48a9b]{font-size:1.5em;margin-bottom:.5em;color:#333}.markdown-container h3[data-v-65b48a9b]{font-size:1.25em;margin-bottom:.5em;color:#444}.markdown-container p[data-v-65b48a9b]{margin:.5em 0}.markdown-container ul[data-v-65b48a9b]{padding-left:20px;list-style-type:disc}.markdown-container ol[data-v-65b48a9b]{padding-left:20px;list-style-type:decimal}.markdown-container li[data-v-65b48a9b]{margin:.5em 0}.markdown-container code[data-v-65b48a9b]{background-color:#f4f4f4;padding:.2em .4em;border-radius:4px;font-family:Courier New,Courier,monospace}.markdown-container pre[data-v-65b48a9b]{background-color:#f4f4f4;padding:16px;border-radius:8px;overflow-x:auto}.markdown-container blockquote[data-v-65b48a9b]{margin:1em 0;padding:.5em 1em;background-color:#f9f9f9;border-left:4px solid #ccc;color:#666;font-style:italic}.el-card{--el-card-border-color:var(--el-border-color-light);--el-card-border-radius:4px;--el-card-padding:20px;--el-card-bg-color:var(--el-fill-color-blank);background-color:var(--el-card-bg-color);border:1px solid var(--el-card-border-color);border-radius:var(--el-card-border-radius);color:var(--el-text-color-primary);overflow:hidden;transition:var(--el-transition-duration)}.el-card.is-always-shadow{box-shadow:var(--el-box-shadow-light)}.el-card.is-hover-shadow:focus,.el-card.is-hover-shadow:hover{box-shadow:var(--el-box-shadow-light)}.el-card__header{border-bottom:1px solid var(--el-card-border-color);box-sizing:border-box;padding:calc(var(--el-card-padding) - 2px) var(--el-card-padding)}.el-card__body{padding:var(--el-card-padding)}.el-card__footer{border-top:1px solid var(--el-card-border-color);box-sizing:border-box;padding:calc(var(--el-card-padding) - 2px) var(--el-card-padding)}.el-button-group{display:inline-block;vertical-align:middle}.el-button-group:after,.el-button-group:before{content:"";display:table}.el-button-group:after{clear:both}.el-button-group>.el-button{float:left;position:relative}.el-button-group>.el-button+.el-button{margin-left:0}.el-button-group>.el-button:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.el-button-group>.el-button:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.el-button-group>.el-button:first-child:last-child{border-bottom-left-radius:var(--el-border-radius-base);border-bottom-right-radius:var(--el-border-radius-base);border-top-left-radius:var(--el-border-radius-base);border-top-right-radius:var(--el-border-radius-base)}.el-button-group>.el-button:first-child:last-child.is-round{border-radius:var(--el-border-radius-round)}.el-button-group>.el-button:first-child:last-child.is-circle{border-radius:50%}.el-button-group>.el-button:not(:first-child):not(:last-child){border-radius:0}.el-button-group>.el-button:not(:last-child){margin-right:-1px}.el-button-group>.el-button:active,.el-button-group>.el-button:focus,.el-button-group>.el-button:hover{z-index:1}.el-button-group>.el-button.is-active{z-index:1}.el-button-group>.el-dropdown>.el-button{border-bottom-left-radius:0;border-left-color:var(--el-button-divide-border-color);border-top-left-radius:0}.el-button-group .el-button--primary:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--primary:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--primary:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-popconfirm__main{align-items:center;display:flex}.el-popconfirm__icon{margin-right:5px}.el-popconfirm__action{margin-top:8px;text-align:right}.el-popover{--el-popover-bg-color:var(--el-bg-color-overlay);--el-popover-font-size:var(--el-font-size-base);--el-popover-border-color:var(--el-border-color-lighter);--el-popover-padding:12px;--el-popover-padding-large:18px 20px;--el-popover-title-font-size:16px;--el-popover-title-text-color:var(--el-text-color-primary);--el-popover-border-radius:4px}.el-popover.el-popper{background:var(--el-popover-bg-color);border:1px solid var(--el-popover-border-color);border-radius:var(--el-popover-border-radius);box-shadow:var(--el-box-shadow-light);box-sizing:border-box;color:var(--el-text-color-regular);font-size:var(--el-popover-font-size);line-height:1.4;min-width:150px;overflow-wrap:break-word;padding:var(--el-popover-padding);z-index:var(--el-index-popper)}.el-popover.el-popper--plain{padding:var(--el-popover-padding-large)}.el-popover__title{color:var(--el-popover-title-text-color);font-size:var(--el-popover-title-font-size);line-height:1;margin-bottom:12px}.el-popover__reference:focus:hover,.el-popover__reference:focus:not(.focusing){outline-width:0}.el-popover.el-popper.is-dark{--el-popover-bg-color:var(--el-text-color-primary);--el-popover-border-color:var(--el-text-color-primary);--el-popover-title-text-color:var(--el-bg-color);color:var(--el-bg-color)}.el-popover.el-popper:focus,.el-popover.el-popper:focus:active{outline-width:0}.container[data-v-41595ce0]{max-width:1200px;margin:0 auto;padding:0}.box-card[data-v-41595ce0]{margin-bottom:20px}.card-header[data-v-41595ce0]{display:flex;justify-content:space-between;align-items:center}.bind-form[data-v-41595ce0]{margin-top:20px}.info-item[data-v-41595ce0]{font-size:16px;margin-bottom:10px;display:block}.exchange-group[data-v-41595ce0]{display:flex;gap:10px}@media (max-width: 768px){.container[data-v-41595ce0]{padding:10px}.exchange-group[data-v-41595ce0]{flex-direction:column}.el-form--inline .el-form-item[data-v-41595ce0]{margin-right:0;margin-bottom:10px}}.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.fade-in-linear-enter-from,.fade-in-linear-leave-to{opacity:0}.el-fade-in-linear-enter-active,.el-fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.el-fade-in-linear-enter-from,.el-fade-in-linear-leave-to{opacity:0}.el-fade-in-enter-active,.el-fade-in-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-fade-in-enter-from,.el-fade-in-leave-active{opacity:0}.el-zoom-in-center-enter-active,.el-zoom-in-center-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-zoom-in-center-enter-from,.el-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.el-zoom-in-top-enter-active,.el-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transform-origin:center top;transition:var(--el-transition-md-fade)}.el-zoom-in-top-enter-active[data-popper-placement^=top],.el-zoom-in-top-leave-active[data-popper-placement^=top]{transform-origin:center bottom}.el-zoom-in-top-enter-from,.el-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-bottom-enter-active,.el-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transform-origin:center bottom;transition:var(--el-transition-md-fade)}.el-zoom-in-bottom-enter-from,.el-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-left-enter-active,.el-zoom-in-left-leave-active{opacity:1;transform:scale(1);transform-origin:top left;transition:var(--el-transition-md-fade)}.el-zoom-in-left-enter-from,.el-zoom-in-left-leave-active{opacity:0;transform:scale(.45)}.collapse-transition{transition:var(--el-transition-duration) height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.el-collapse-transition-enter-active,.el-collapse-transition-leave-active{transition:var(--el-transition-duration) max-height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.horizontal-collapse-transition{transition:var(--el-transition-duration) width ease-in-out,var(--el-transition-duration) padding-left ease-in-out,var(--el-transition-duration) padding-right ease-in-out}.el-list-enter-active,.el-list-leave-active{transition:all 1s}.el-list-enter-from,.el-list-leave-to{opacity:0;transform:translateY(-30px)}.el-list-leave-active{position:absolute!important}.el-opacity-transition{transition:opacity var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-collapse{--el-collapse-border-color:var(--el-border-color-lighter);--el-collapse-header-height:48px;--el-collapse-header-bg-color:var(--el-fill-color-blank);--el-collapse-header-text-color:var(--el-text-color-primary);--el-collapse-header-font-size:13px;--el-collapse-content-bg-color:var(--el-fill-color-blank);--el-collapse-content-font-size:13px;--el-collapse-content-text-color:var(--el-text-color-primary);border-bottom:1px solid var(--el-collapse-border-color);border-top:1px solid var(--el-collapse-border-color)}.el-collapse-item.is-disabled .el-collapse-item__header{color:var(--el-text-color-disabled);cursor:not-allowed}.el-collapse-item__header{align-items:center;background-color:var(--el-collapse-header-bg-color);border:none;border-bottom:1px solid var(--el-collapse-border-color);color:var(--el-collapse-header-text-color);cursor:pointer;display:flex;font-size:var(--el-collapse-header-font-size);font-weight:500;height:var(--el-collapse-header-height);line-height:var(--el-collapse-header-height);outline:none;padding:0;transition:border-bottom-color var(--el-transition-duration);width:100%}.el-collapse-item__arrow{font-weight:300;margin:0 8px 0 auto;transition:transform var(--el-transition-duration)}.el-collapse-item__arrow.is-active{transform:rotate(90deg)}.el-collapse-item__header.focusing:focus:not(:hover){color:var(--el-color-primary)}.el-collapse-item__header.is-active{border-bottom-color:transparent}.el-collapse-item__wrap{background-color:var(--el-collapse-content-bg-color);border-bottom:1px solid var(--el-collapse-border-color);box-sizing:border-box;overflow:hidden;will-change:height}.el-collapse-item__content{color:var(--el-collapse-content-text-color);font-size:var(--el-collapse-content-font-size);line-height:1.7692307692;padding-bottom:25px}.el-collapse-item:last-child{margin-bottom:-1px}.ai-config[data-v-c984eb47]{padding:15px 1px 1px;background:#fff}.config-form[data-v-c984eb47]{margin:0}.unit[data-v-c984eb47]{margin-left:8px}.select-opt-item[data-v-c984eb47]{width:400px}.test-failed-notification{width:600px!important}.tune-form[data-v-c984eb47],.debug-form[data-v-c984eb47]{margin-bottom:10px}.chat-history[data-v-c984eb47]{max-height:420px;overflow-y:auto;padding:8px 4px;background:#fafafa;border:1px solid #eee;border-radius:6px}.chat-composer[data-v-c984eb47]{display:flex;gap:10px;margin-top:10px}.composer-input[data-v-c984eb47]{position:relative;width:100%}.composer-input[data-v-c984eb47] .el-textarea__inner{padding-right:84px;padding-bottom:50px}.composer-input[data-v-c984eb47] .el-input__count{bottom:40px;right:8px}.send-btn[data-v-c984eb47]{position:absolute;right:8px;bottom:8px}.chat-row[data-v-c984eb47]{display:flex;margin:8px 0}.chat-row.from-user[data-v-c984eb47]{justify-content:flex-start}.chat-row.from-ai[data-v-c984eb47]{justify-content:flex-end}.bubble[data-v-c984eb47]{max-width:80%;padding:8px 10px;border-radius:8px;background:#fff;box-shadow:0 1px 2px #0000000f}.from-user .bubble[data-v-c984eb47]{background:#f5f7fa}.from-ai .bubble[data-v-c984eb47]{background:#e8f6f3}.bubble .content[data-v-c984eb47]{white-space:pre-wrap;word-break:break-word;font-size:13px}.bubble .meta[data-v-c984eb47]{font-size:12px;color:#909399;margin-bottom:4px}.bubble .tags[data-v-c984eb47]{margin-top:6px;display:flex;gap:6px;flex-wrap:wrap}.tune-form[data-v-c984eb47]{padding:0 10px;font-weight:700}.container[data-v-3c51f398]{max-width:1200px;margin:0 auto}.show-component[data-v-3c51f398]{padding:30px} `);

System.addImportMap({ imports: {"vue":"user:vue","pinia":"user:pinia","element-plus":"user:element-plus","protobufjs":"user:protobufjs","event-source-polyfill":"user:event-source-polyfill"} });
System.set("user:vue", (()=>{const _=Vue;('default' in _)||(_.default=_);return _})());
System.set("user:pinia", (()=>{const _=Pinia;('default' in _)||(_.default=_);return _})());
System.set("user:element-plus", (()=>{const _=ElementPlus;('default' in _)||(_.default=_);return _})());
System.set("user:protobufjs", (()=>{const _=protobuf;('default' in _)||(_.default=_);return _})());
System.set("user:event-source-polyfill", (()=>{const _=EventSourcePolyfill;('default' in _)||(_.default=_);return _})());

System.register("./__entry.js", ['./__monkey.entry-C6x6oyrg.js'], (function (exports, module) {
	'use strict';
	return {
		setters: [null],
		execute: (function () {



		})
	};
}));

System.register("./__monkey.entry-C6x6oyrg.js", ['vue', 'protobufjs', 'pinia', 'element-plus', 'event-source-polyfill'], (function (exports, module) {
  'use strict';
  var ref, reactive, defineComponent, computed$1, openBlock, createElementBlock, mergeProps, unref, renderSlot, useAttrs$1, useSlots, shallowRef, watch, nextTick, onMounted, toRef, createCommentVNode, Fragment, normalizeClass, createElementVNode, createBlock, withCtx, resolveDynamicComponent, withModifiers, createVNode, toDisplayString, normalizeStyle, provide, onUpdated, inject, onBeforeUnmount, withDirectives, cloneVNode, Text$1, Comment, Teleport, Transition, vShow, readonly, onDeactivated, isRef, vModelCheckbox, createTextVNode, toRefs, h$1, createSlots, markRaw, effectScope, renderList, getCurrentInstance, onUnmounted, onBeforeMount, createApp, warn, watchEffect, getCurrentScope, onScopeDispose, toRaw$1, resolveComponent, resolveDirective, render, isVNode, pushScopeId, popScopeId, protobuf, defineStore, createPinia, ElMessage$1, ElementPlus, ElNotification, EventSourcePolyfillDefault;
  return {
    setters: [module => {
      ref = module.ref;
      reactive = module.reactive;
      defineComponent = module.defineComponent;
      computed$1 = module.computed;
      openBlock = module.openBlock;
      createElementBlock = module.createElementBlock;
      mergeProps = module.mergeProps;
      unref = module.unref;
      renderSlot = module.renderSlot;
      useAttrs$1 = module.useAttrs;
      useSlots = module.useSlots;
      shallowRef = module.shallowRef;
      watch = module.watch;
      nextTick = module.nextTick;
      onMounted = module.onMounted;
      toRef = module.toRef;
      createCommentVNode = module.createCommentVNode;
      Fragment = module.Fragment;
      normalizeClass = module.normalizeClass;
      createElementVNode = module.createElementVNode;
      createBlock = module.createBlock;
      withCtx = module.withCtx;
      resolveDynamicComponent = module.resolveDynamicComponent;
      withModifiers = module.withModifiers;
      createVNode = module.createVNode;
      toDisplayString = module.toDisplayString;
      normalizeStyle = module.normalizeStyle;
      provide = module.provide;
      onUpdated = module.onUpdated;
      inject = module.inject;
      onBeforeUnmount = module.onBeforeUnmount;
      withDirectives = module.withDirectives;
      cloneVNode = module.cloneVNode;
      Text$1 = module.Text;
      Comment = module.Comment;
      Teleport = module.Teleport;
      Transition = module.Transition;
      vShow = module.vShow;
      readonly = module.readonly;
      onDeactivated = module.onDeactivated;
      isRef = module.isRef;
      vModelCheckbox = module.vModelCheckbox;
      createTextVNode = module.createTextVNode;
      toRefs = module.toRefs;
      h$1 = module.h;
      createSlots = module.createSlots;
      markRaw = module.markRaw;
      effectScope = module.effectScope;
      renderList = module.renderList;
      getCurrentInstance = module.getCurrentInstance;
      onUnmounted = module.onUnmounted;
      onBeforeMount = module.onBeforeMount;
      createApp = module.createApp;
      warn = module.warn;
      watchEffect = module.watchEffect;
      getCurrentScope = module.getCurrentScope;
      onScopeDispose = module.onScopeDispose;
      toRaw$1 = module.toRaw;
      resolveComponent = module.resolveComponent;
      resolveDirective = module.resolveDirective;
      render = module.render;
      isVNode = module.isVNode;
      pushScopeId = module.pushScopeId;
      popScopeId = module.popScopeId;
    }, module => {
      protobuf = module.default;
    }, module => {
      defineStore = module.defineStore;
      createPinia = module.createPinia;
    }, module => {
      ElMessage$1 = module.ElMessage;
      ElementPlus = module.default;
      ElNotification = module.ElNotification;
    }, module => {
      EventSourcePolyfillDefault = module.default;
    }],
    execute: (function () {

      exports({
        J: isEqual,
        N: onClickOutside,
        Y: isNil,
        a$: copyObject,
        aF: useTimeoutFn,
        aG: get,
        aH: useFocusController,
        aL: debounce,
        aP: useVModel,
        aQ: isObject,
        aR: copyArray,
        aU: cloneBuffer,
        aV: initCloneObject,
        aW: Stack,
        aX: cacheHas,
        a_: scrollIntoView,
        ad: useMutationObserver,
        aw: SetCache,
        ax: useGlobalConfig,
        b0: keys,
        b1: keysIn,
        b3: cloneTypedArray,
        b4: cloneArrayBuffer,
        b5: baseUnary,
        b6: getAllKeys,
        b7: assignValue,
        b9: stubArray,
        bF: toNumber,
        bH: useGlobalComponentSettings,
        ba: arrayPush,
        bc: baseGetAllKeys,
        bd: isObjectLike,
        be: baseIteratee,
        bu: fetchWithGM_request,
        d: baseRest,
        e: baseFlatten,
        i: isArrayLikeObject,
        l: debugWarn,
        p: useResizeObserver,
        r: refDebounced,
        s: setToArray,
        t: throwError,
        v: addUnit
      });

      var __defProp2 = Object.defineProperty;
      var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __publicField = (obj, key, value) => {
        __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
        return value;
      };
      const cssLoader = (e) => {
        const t = GM_getResourceText(e);
        return GM_addStyle(t), t;
      };
      cssLoader("element-plus/dist/index.css");
      const scriptRel = function detectScriptRel() {
        const relList = typeof document !== "undefined" && document.createElement("link").relList;
        return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
      }();
      const assetsURL = function(dep) {
        return "/" + dep;
      };
      const seen = {};
      const __vitePreload = function preload(baseModule, deps, importerUrl) {
        let promise = Promise.resolve();
        if (deps && deps.length > 0) {
          const links = document.getElementsByTagName("link");
          const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
          const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
          promise = Promise.all(deps.map((dep) => {
            dep = assetsURL(dep);
            if (dep in seen)
              return;
            seen[dep] = true;
            const isCss = dep.endsWith(".css");
            const cssSelector = isCss ? '[rel="stylesheet"]' : "";
            const isBaseRelative = !!importerUrl;
            if (isBaseRelative) {
              for (let i = links.length - 1; i >= 0; i--) {
                const link2 = links[i];
                if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
                  return;
                }
              }
            } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
              return;
            }
            const link = document.createElement("link");
            link.rel = isCss ? "stylesheet" : scriptRel;
            if (!isCss) {
              link.as = "script";
              link.crossOrigin = "";
            }
            link.href = dep;
            if (cspNonce) {
              link.setAttribute("nonce", cspNonce);
            }
            document.head.appendChild(link);
            if (isCss) {
              return new Promise((res, rej) => {
                link.addEventListener("load", res);
                link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
              });
            }
          }));
        }
        return promise.then(() => baseModule()).catch((err) => {
          const e = new Event("vite:preloadError", { cancelable: true });
          e.payload = err;
          window.dispatchEvent(e);
          if (!e.defaultPrevented) {
            throw err;
          }
        });
      };
      class AIJobHuntingError extends Error {
        constructor(message) {
          super(message);
        }
      }
      class PlatformError extends AIJobHuntingError {
        constructor(platformType, message) {
          super(message);
          __publicField(this, "platform");
          this.platform = platformType;
        }
      }
      class PushException extends AIJobHuntingError {
      }
      class NotMatchException extends PushException {
        constructor(jobTitle, data, message = "") {
          super(message);
          __publicField(this, "jobTitle");
          __publicField(this, "data");
          this.jobTitle = jobTitle;
          this.data = data;
        }
      }
      class PushReqException extends PushException {
        constructor(jobTitle, message = "") {
          super(message);
          __publicField(this, "jobTitle");
          this.jobTitle = jobTitle;
        }
      }
      class FetchJobBossFailExp extends PushException {
        constructor(jobTitle, message = "") {
          super(message);
          __publicField(this, "jobTitle");
          this.jobTitle = jobTitle;
        }
      }
      class PublishStopExp extends PushException {
      }
      class PublishLimitExp extends PushException {
      }
      var _GM_addValueChangeListener = /* @__PURE__ */ (() => typeof GM_addValueChangeListener != "undefined" ? GM_addValueChangeListener : void 0)();
      var _GM_getValue = /* @__PURE__ */ (() => typeof GM_getValue != "undefined" ? GM_getValue : void 0)();
      var _GM_notification = /* @__PURE__ */ (() => typeof GM_notification != "undefined" ? GM_notification : void 0)();
      var _GM_setValue = /* @__PURE__ */ (() => typeof GM_setValue != "undefined" ? GM_setValue : void 0)();
      var _GM_xmlhttpRequest = /* @__PURE__ */ (() => typeof GM_xmlhttpRequest != "undefined" ? GM_xmlhttpRequest : void 0)();
      var _unsafeWindow = /* @__PURE__ */ (() => typeof unsafeWindow != "undefined" ? unsafeWindow : void 0)();
      class Tools {
        /**
         * 模糊匹配
         * @param arr
         * @param input
         * @param emptyStatus
         * @returns {boolean|*}
         */
        static fuzzyMatch(arr, input, emptyStatus) {
          if (arr.length === 0) {
            return emptyStatus;
          }
          input = input.toLowerCase();
          let emptyEle = false;
          for (let i = 0; i < arr.length; i++) {
            let arrEleStr = arr[i].toLowerCase();
            if (arrEleStr.length === 0) {
              emptyEle = true;
              continue;
            }
            if (arrEleStr.includes(input) || input.includes(arrEleStr)) {
              return true;
            }
          }
          if (emptyEle) {
            return emptyStatus;
          }
          return false;
        }
        // 范围匹配
        static isRangeOverlap(range, input) {
          const parseRange = (str2) => {
            const match = str2.match(/(\d+)(?:\s*-\s*(\d+))?/);
            if (!match) {
              throw new Error("Invalid range format");
            }
            const start = parseFloat(match[1]);
            const end = match[2] ? parseFloat(match[2]) : Number.POSITIVE_INFINITY;
            return [start, end];
          };
          const [rangeStart, rangeEnd] = parseRange(range);
          const [inputStart, inputEnd] = parseRange(input);
          return !(rangeEnd < inputStart || inputEnd < rangeStart);
        }
        static getRandomNumber(startMs, endMs) {
          return Math.floor(Math.random() * (endMs - startMs + 1)) + startMs;
        }
        static getCookieValue(key) {
          const cookies2 = document.cookie.split(";");
          for (const cookie of cookies2) {
            const [cookieKey, cookieValue] = cookie.trim().split("=");
            if (cookieKey === key) {
              return decodeURIComponent(cookieValue);
            }
          }
          return null;
        }
        static parseURL(url) {
          const urlObj = new URL(url);
          const pathSegments = urlObj.pathname.split("/");
          const jobId = pathSegments[2].replace(".html", "");
          const lid = urlObj.searchParams.get("lid");
          const securityId = urlObj.searchParams.get("securityId");
          return {
            securityId,
            jobId,
            lid
          };
        }
        static queryString(baseURL, queryParams) {
          const queryString = Object.entries(queryParams).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join("&");
          return `${baseURL}?${queryString}`;
        }
        static getCurDay() {
          const currentDate = /* @__PURE__ */ new Date();
          const year = currentDate.getFullYear();
          const month = String(currentDate.getMonth() + 1).padStart(2, "0");
          const day = String(currentDate.getDate()).padStart(2, "0");
          return `${year}-${month}-${day}`;
        }
        // 等待一段时间的函数
        static sleep(ms) {
          return new Promise((resolve) => setTimeout(resolve, ms));
        }
        static getEndChar() {
          return String.fromCharCode(0);
        }
      } exports("T", Tools);
      __publicField(Tools, "window", _unsafeWindow);
      const _TampermonkeyApi = class _TampermonkeyApi {
        constructor() {
          _TampermonkeyApi.CUR_CK = _GM_getValue("ck_cur", "");
        }
        static GmSetValue(key, val) {
          return _GM_setValue(_TampermonkeyApi.CUR_CK + key, val);
        }
        static GmGetValue(key, defVal) {
          return _GM_getValue(_TampermonkeyApi.CUR_CK + key, defVal);
        }
        static GMXmlHttpRequest(options) {
          return _GM_xmlhttpRequest(options);
        }
        static GmAddValueChangeListener(key, func) {
          return _GM_addValueChangeListener(_TampermonkeyApi.CUR_CK + key, func);
        }
        static GmNotification(content) {
          _GM_notification({
            title: "Boss直聘批量投简历",
            image: "https://img.bosszhipin.com/beijin/mcs/banner/3e9d37e9effaa2b6daf43f3f03f7cb15cfcd208495d565ef66e7dff9f98764da.jpg",
            text: content,
            highlight: true,
            // 布尔值，是否突出显示发送通知的选项卡
            silent: true,
            // 布尔值，是否播放声音
            timeout: 1e4,
            // 设置通知隐藏时间
            onclick: function() {
            },
            ondone() {
            }
            // 在通知关闭（无论这是由超时还是单击触发）或突出显示选项卡时调用
          });
        }
      };
      __publicField(_TampermonkeyApi, "CUR_CK", "");
      __publicField(_TampermonkeyApi, "LOCAL_CONFIG", "config");
      __publicField(_TampermonkeyApi, "PUSH_SUCCESS_COUNT", "pushSuccessCount:" + Tools.getCurDay());
      __publicField(_TampermonkeyApi, "PUSH_FAIL_COUNT", "pushFailCount:" + Tools.getCurDay());
      __publicField(_TampermonkeyApi, "ACTIVE_ENABLE", "activeEnable");
      __publicField(_TampermonkeyApi, "PUSH_LIMIT", "push_limit" + Tools.getCurDay());
      // 投递锁是否被占用，可重入；value表示当前正在投递的job
      __publicField(_TampermonkeyApi, "PUSH_LOCK", "push_lock");
      // 公司名包含输入框lab
      __publicField(_TampermonkeyApi, "cnInKey", "companyNameInclude");
      // 公司名排除输入框lab
      __publicField(_TampermonkeyApi, "cnExKey", "companyNameExclude");
      // job名称包含输入框lab
      __publicField(_TampermonkeyApi, "jnInKey", "jobNameInclude");
      // job内容排除输入框lab
      __publicField(_TampermonkeyApi, "jcExKey", "jobContentExclude");
      // 薪资范围输入框lab
      __publicField(_TampermonkeyApi, "srInKey", "salaryRange");
      // 公司规模范围输入框lab
      __publicField(_TampermonkeyApi, "csrInKey", "companyScaleRange");
      // 自定义招呼语输入框
      __publicField(_TampermonkeyApi, "sgInKey", "sendSelfGreet");
      __publicField(_TampermonkeyApi, "SEND_SELF_GREET_MEMORY", "sendSelfGreetMemory");
      let TampermonkeyApi = _TampermonkeyApi;
      const _MessageCache = class _MessageCache {
        // GM存储键
        /**
         * 获取当前缓存数据
         */
        getCache() {
          const rawCache = _GM_getValue(_MessageCache.CACHE_KEY, "{}");
          return JSON.parse(rawCache);
        }
        /**
         * 保存缓存数据
         */
        saveCache(cache) {
          _GM_setValue(_MessageCache.CACHE_KEY, JSON.stringify(cache));
        }
        /**
         * 清理过期的缓存
         */
        cleanExpiredCache(cache) {
          const now2 = Date.now();
          const validCache = {};
          Object.entries(cache).forEach(([key, entry]) => {
            if (entry.expiration > now2) {
              validCache[key] = entry;
            }
          });
          return validCache;
        }
        /**
         * 检查是否处理过消息
         * @param bossId - Boss ID
         * @param text - 消息内容，仅前 10 位参与计算
         * @returns 是否已处理
         */
        isMessageProcessed(bossId, text) {
          const key = this.generateKey(bossId, text);
          const cache = this.getCache();
          const validCache = this.cleanExpiredCache(cache);
          this.saveCache(validCache);
          return key in validCache;
        }
        /**
         * 标记消息为已处理
         * @param bossId - Boss ID
         * @param text - 消息内容，仅前 10 位参与计算
         * @param expiration - 过期时间，单位毫秒（可选，默认 1 分钟）
         */
        markMessageAsProcessed(bossId, text, expiration) {
          const key = this.generateKey(bossId, text);
          const cache = this.getCache();
          cache[key] = {
            expiration: Date.now() + (expiration || _MessageCache.DEFAULT_EXPIRATION)
          };
          this.saveCache(cache);
        }
        /**
         * 生成唯一键
         * @param bossId - Boss ID
         * @param text - 消息内容
         * @returns 唯一键
         */
        generateKey(bossId, text) {
          const trimmedText = text.slice(0, 10);
          return `${bossId}:${trimmedText}`;
        }
      };
      __publicField(_MessageCache, "DEFAULT_EXPIRATION", 60 * 1e3);
      // 默认过期时间：1分钟
      __publicField(_MessageCache, "CACHE_KEY", "messageCache");
      let MessageCache = _MessageCache;
      const simulateScrollToEnd = async (platform2) => {
        const isMac = platform2 === "mac" || navigator.platform.toUpperCase().includes("MAC");
        const modifierKey = isMac ? "Meta" : "Control";
        try {
          const activeElement = document.activeElement;
          const eventOptions = {
            key: "End",
            code: "End",
            [modifierKey.toLowerCase() + "Key"]: true,
            bubbles: true,
            cancelable: true,
            composed: true,
            view: window
          };
          const downEvent = new KeyboardEvent("keydown", eventOptions);
          const upEvent = new KeyboardEvent("keyup", eventOptions);
          document.dispatchEvent(downEvent);
          document.dispatchEvent(upEvent);
          if (activeElement) {
            activeElement.dispatchEvent(downEvent);
            activeElement.dispatchEvent(upEvent);
          }
          await new Promise((resolve) => requestAnimationFrame(resolve));
        } catch (error) {
          console.warn("键盘事件触发失败，使用备选方案");
        }
        const getMaxScroll = () => {
          const documentElement = document.documentElement;
          return Math.max(
            document.body.scrollHeight,
            documentElement.scrollHeight,
            document.body.offsetHeight,
            documentElement.offsetHeight,
            document.body.clientHeight,
            documentElement.clientHeight
          ) - window.innerHeight;
        };
        const maxScroll = getMaxScroll();
        if (window.scrollY !== maxScroll) {
          window.scrollTo({
            top: maxScroll,
            behavior: "smooth"
          });
        }
      };
      var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
        LogLevel2[LogLevel2["Error"] = 1] = "Error";
        LogLevel2[LogLevel2["Warn"] = 2] = "Warn";
        LogLevel2[LogLevel2["Info"] = 3] = "Info";
        LogLevel2[LogLevel2["Debug"] = 4] = "Debug";
        LogLevel2[LogLevel2["Trace"] = 5] = "Trace";
        LogLevel2[LogLevel2["OriginalTrace"] = 6] = "OriginalTrace";
        return LogLevel2;
      })(LogLevel || {});
      let globalLogLevel = 3;
      const loggerInstances = [];
      const logStyles = {
        // 30 - 黑色
        // 31 - 红色
        // 32 - 绿色
        // 33 - 黄色
        // 34 - 蓝色
        // 35 - 紫色
        // 36 - 青色
        // 37 - 白色
        error: "\x1B[31m%s\x1B[0m",
        // 红色
        warn: "\x1B[33m%s\x1B[0m",
        // 黄色
        info: "\x1B[32m%s\x1B[0m",
        // 绿色
        debug: "\x1B[36m%s\x1B[0m",
        // 青色
        trace: "\x1B[34m%s\x1B[0m"
        // 蓝色
      };
      const _Logger = class _Logger {
        constructor(name = "", logLevel = globalLogLevel) {
          __publicField(this, "name");
          __publicField(this, "logLevel");
          this.name = name;
          this.logLevel = logLevel;
          loggerInstances.push(this);
        }
        static setGlobalLogLevel(logLevel) {
          globalLogLevel = logLevel;
          loggerInstances.forEach((logger2) => logger2.setLogLevel(logLevel));
        }
        setLogLevel(logLevel) {
          this.logLevel = logLevel;
        }
        getLogLevel() {
          return this.logLevel;
        }
        error(...messages) {
          if (this.logLevel >= 1) {
            console.error(logStyles.error, `[${this.name}][ERROR]`, ...messages);
          }
        }
        warn(...messages) {
          if (this.logLevel >= 2) {
            console.warn(logStyles.warn, `[${this.name}][WARN]`, ...messages);
          }
        }
        info(...messages) {
          if (this.logLevel >= 3) {
            console.log(logStyles.info, `[${this.name}][INFO]`, ...messages);
          }
        }
        debug(...messages) {
          if (this.logLevel >= 4) {
            console.debug(logStyles.debug, `[${this.name}][DEBUG]`, ...messages);
          }
        }
        trace(...messages) {
          if (this.logLevel >= 5) {
            console.debug(logStyles.trace, `[${this.name}][TRACE]`, ...messages);
          }
        }
        originalTrace(...messages) {
          if (this.logLevel >= 6) {
            console.trace(logStyles.trace, `[${this.name}][ORIGINAL_TRACE]`, ...messages);
          }
        }
      };
      __publicField(_Logger, "rootLogger", new _Logger("root"));
      let Logger = _Logger;
      const logger$1 = exports("bl", Logger.rootLogger);
      function bind(fn2, thisArg) {
        return function wrap() {
          return fn2.apply(thisArg, arguments);
        };
      }
      const { toString: toString$1 } = Object.prototype;
      const { getPrototypeOf } = Object;
      const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
        const str2 = toString$1.call(thing);
        return cache[str2] || (cache[str2] = str2.slice(8, -1).toLowerCase());
      })(/* @__PURE__ */ Object.create(null));
      const kindOfTest = (type) => {
        type = type.toLowerCase();
        return (thing) => kindOf(thing) === type;
      };
      const typeOfTest = (type) => (thing) => typeof thing === type;
      const { isArray: isArray$2 } = Array;
      const isUndefined$2 = typeOfTest("undefined");
      function isBuffer$1(val) {
        return val !== null && !isUndefined$2(val) && val.constructor !== null && !isUndefined$2(val.constructor) && isFunction$3(val.constructor.isBuffer) && val.constructor.isBuffer(val);
      }
      const isArrayBuffer = kindOfTest("ArrayBuffer");
      function isArrayBufferView(val) {
        let result;
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          result = ArrayBuffer.isView(val);
        } else {
          result = val && val.buffer && isArrayBuffer(val.buffer);
        }
        return result;
      }
      const isString$2 = typeOfTest("string");
      const isFunction$3 = typeOfTest("function");
      const isNumber$1 = typeOfTest("number");
      const isObject$2 = (thing) => thing !== null && typeof thing === "object";
      const isBoolean$1 = (thing) => thing === true || thing === false;
      const isPlainObject$2 = (val) => {
        if (kindOf(val) !== "object") {
          return false;
        }
        const prototype2 = getPrototypeOf(val);
        return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
      };
      const isDate$1 = kindOfTest("Date");
      const isFile = kindOfTest("File");
      const isBlob = kindOfTest("Blob");
      const isFileList = kindOfTest("FileList");
      const isStream = (val) => isObject$2(val) && isFunction$3(val.pipe);
      const isFormData = (thing) => {
        let kind;
        return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$3(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
        kind === "object" && isFunction$3(thing.toString) && thing.toString() === "[object FormData]"));
      };
      const isURLSearchParams = kindOfTest("URLSearchParams");
      const trim = (str2) => str2.trim ? str2.trim() : str2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
      function forEach(obj, fn2, { allOwnKeys = false } = {}) {
        if (obj === null || typeof obj === "undefined") {
          return;
        }
        let i;
        let l2;
        if (typeof obj !== "object") {
          obj = [obj];
        }
        if (isArray$2(obj)) {
          for (i = 0, l2 = obj.length; i < l2; i++) {
            fn2.call(null, obj[i], i, obj);
          }
        } else {
          const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
          const len = keys2.length;
          let key;
          for (i = 0; i < len; i++) {
            key = keys2[i];
            fn2.call(null, obj[key], key, obj);
          }
        }
      }
      function findKey(obj, key) {
        key = key.toLowerCase();
        const keys2 = Object.keys(obj);
        let i = keys2.length;
        let _key;
        while (i-- > 0) {
          _key = keys2[i];
          if (key === _key.toLowerCase()) {
            return _key;
          }
        }
        return null;
      }
      const _global$1 = (() => {
        if (typeof globalThis !== "undefined")
          return globalThis;
        return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
      })();
      const isContextDefined = (context) => !isUndefined$2(context) && context !== _global$1;
      function merge$2() {
        const { caseless } = isContextDefined(this) && this || {};
        const result = {};
        const assignValue2 = (val, key) => {
          const targetKey = caseless && findKey(result, key) || key;
          if (isPlainObject$2(result[targetKey]) && isPlainObject$2(val)) {
            result[targetKey] = merge$2(result[targetKey], val);
          } else if (isPlainObject$2(val)) {
            result[targetKey] = merge$2({}, val);
          } else if (isArray$2(val)) {
            result[targetKey] = val.slice();
          } else {
            result[targetKey] = val;
          }
        };
        for (let i = 0, l2 = arguments.length; i < l2; i++) {
          arguments[i] && forEach(arguments[i], assignValue2);
        }
        return result;
      }
      const extend = (a2, b2, thisArg, { allOwnKeys } = {}) => {
        forEach(b2, (val, key) => {
          if (thisArg && isFunction$3(val)) {
            a2[key] = bind(val, thisArg);
          } else {
            a2[key] = val;
          }
        }, { allOwnKeys });
        return a2;
      };
      const stripBOM = (content) => {
        if (content.charCodeAt(0) === 65279) {
          content = content.slice(1);
        }
        return content;
      };
      const inherits = (constructor, superConstructor, props, descriptors2) => {
        constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
        constructor.prototype.constructor = constructor;
        Object.defineProperty(constructor, "super", {
          value: superConstructor.prototype
        });
        props && Object.assign(constructor.prototype, props);
      };
      const toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
        let props;
        let i;
        let prop;
        const merged = {};
        destObj = destObj || {};
        if (sourceObj == null)
          return destObj;
        do {
          props = Object.getOwnPropertyNames(sourceObj);
          i = props.length;
          while (i-- > 0) {
            prop = props[i];
            if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
              destObj[prop] = sourceObj[prop];
              merged[prop] = true;
            }
          }
          sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
        } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
        return destObj;
      };
      const endsWith = (str2, searchString, position) => {
        str2 = String(str2);
        if (position === void 0 || position > str2.length) {
          position = str2.length;
        }
        position -= searchString.length;
        const lastIndex = str2.indexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
      };
      const toArray = (thing) => {
        if (!thing)
          return null;
        if (isArray$2(thing))
          return thing;
        let i = thing.length;
        if (!isNumber$1(i))
          return null;
        const arr = new Array(i);
        while (i-- > 0) {
          arr[i] = thing[i];
        }
        return arr;
      };
      const isTypedArray$1 = /* @__PURE__ */ ((TypedArray) => {
        return (thing) => {
          return TypedArray && thing instanceof TypedArray;
        };
      })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
      const forEachEntry = (obj, fn2) => {
        const generator = obj && obj[Symbol.iterator];
        const iterator = generator.call(obj);
        let result;
        while ((result = iterator.next()) && !result.done) {
          const pair = result.value;
          fn2.call(obj, pair[0], pair[1]);
        }
      };
      const matchAll = (regExp, str2) => {
        let matches;
        const arr = [];
        while ((matches = regExp.exec(str2)) !== null) {
          arr.push(matches);
        }
        return arr;
      };
      const isHTMLForm = kindOfTest("HTMLFormElement");
      const toCamelCase = (str2) => {
        return str2.toLowerCase().replace(
          /[-_\s]([a-z\d])(\w*)/g,
          function replacer(m2, p1, p2) {
            return p1.toUpperCase() + p2;
          }
        );
      };
      const hasOwnProperty$d = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
      const isRegExp = kindOfTest("RegExp");
      const reduceDescriptors = (obj, reducer) => {
        const descriptors2 = Object.getOwnPropertyDescriptors(obj);
        const reducedDescriptors = {};
        forEach(descriptors2, (descriptor, name) => {
          let ret;
          if ((ret = reducer(descriptor, name, obj)) !== false) {
            reducedDescriptors[name] = ret || descriptor;
          }
        });
        Object.defineProperties(obj, reducedDescriptors);
      };
      const freezeMethods = (obj) => {
        reduceDescriptors(obj, (descriptor, name) => {
          if (isFunction$3(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
            return false;
          }
          const value = obj[name];
          if (!isFunction$3(value))
            return;
          descriptor.enumerable = false;
          if ("writable" in descriptor) {
            descriptor.writable = false;
            return;
          }
          if (!descriptor.set) {
            descriptor.set = () => {
              throw Error("Can not rewrite read-only method '" + name + "'");
            };
          }
        });
      };
      const toObjectSet = (arrayOrString, delimiter) => {
        const obj = {};
        const define = (arr) => {
          arr.forEach((value) => {
            obj[value] = true;
          });
        };
        isArray$2(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
        return obj;
      };
      const noop$1 = () => {
      };
      const toFiniteNumber = (value, defaultValue) => {
        value = +value;
        return Number.isFinite(value) ? value : defaultValue;
      };
      const ALPHA = "abcdefghijklmnopqrstuvwxyz";
      const DIGIT = "0123456789";
      const ALPHABET = {
        DIGIT,
        ALPHA,
        ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
      };
      const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
        let str2 = "";
        const { length } = alphabet;
        while (size--) {
          str2 += alphabet[Math.random() * length | 0];
        }
        return str2;
      };
      function isSpecCompliantForm(thing) {
        return !!(thing && isFunction$3(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
      }
      const toJSONObject = (obj) => {
        const stack = new Array(10);
        const visit = (source, i) => {
          if (isObject$2(source)) {
            if (stack.indexOf(source) >= 0) {
              return;
            }
            if (!("toJSON" in source)) {
              stack[i] = source;
              const target = isArray$2(source) ? [] : {};
              forEach(source, (value, key) => {
                const reducedValue = visit(value, i + 1);
                !isUndefined$2(reducedValue) && (target[key] = reducedValue);
              });
              stack[i] = void 0;
              return target;
            }
          }
          return source;
        };
        return visit(obj, 0);
      };
      const isAsyncFn = kindOfTest("AsyncFunction");
      const isThenable = (thing) => thing && (isObject$2(thing) || isFunction$3(thing)) && isFunction$3(thing.then) && isFunction$3(thing.catch);
      const utils$1 = {
        isArray: isArray$2,
        isArrayBuffer,
        isBuffer: isBuffer$1,
        isFormData,
        isArrayBufferView,
        isString: isString$2,
        isNumber: isNumber$1,
        isBoolean: isBoolean$1,
        isObject: isObject$2,
        isPlainObject: isPlainObject$2,
        isUndefined: isUndefined$2,
        isDate: isDate$1,
        isFile,
        isBlob,
        isRegExp,
        isFunction: isFunction$3,
        isStream,
        isURLSearchParams,
        isTypedArray: isTypedArray$1,
        isFileList,
        forEach,
        merge: merge$2,
        extend,
        trim,
        stripBOM,
        inherits,
        toFlatObject,
        kindOf,
        kindOfTest,
        endsWith,
        toArray,
        forEachEntry,
        matchAll,
        isHTMLForm,
        hasOwnProperty: hasOwnProperty$d,
        hasOwnProp: hasOwnProperty$d,
        // an alias to avoid ESLint no-prototype-builtins detection
        reduceDescriptors,
        freezeMethods,
        toObjectSet,
        toCamelCase,
        noop: noop$1,
        toFiniteNumber,
        findKey,
        global: _global$1,
        isContextDefined,
        ALPHABET,
        generateString,
        isSpecCompliantForm,
        toJSONObject,
        isAsyncFn,
        isThenable
      };
      function AxiosError(message, code2, config, request2, response) {
        Error.call(this);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        } else {
          this.stack = new Error().stack;
        }
        this.message = message;
        this.name = "AxiosError";
        code2 && (this.code = code2);
        config && (this.config = config);
        request2 && (this.request = request2);
        response && (this.response = response);
      }
      utils$1.inherits(AxiosError, Error, {
        toJSON: function toJSON() {
          return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: utils$1.toJSONObject(this.config),
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
          };
        }
      });
      const prototype$1 = AxiosError.prototype;
      const descriptors = {};
      [
        "ERR_BAD_OPTION_VALUE",
        "ERR_BAD_OPTION",
        "ECONNABORTED",
        "ETIMEDOUT",
        "ERR_NETWORK",
        "ERR_FR_TOO_MANY_REDIRECTS",
        "ERR_DEPRECATED",
        "ERR_BAD_RESPONSE",
        "ERR_BAD_REQUEST",
        "ERR_CANCELED",
        "ERR_NOT_SUPPORT",
        "ERR_INVALID_URL"
        // eslint-disable-next-line func-names
      ].forEach((code2) => {
        descriptors[code2] = { value: code2 };
      });
      Object.defineProperties(AxiosError, descriptors);
      Object.defineProperty(prototype$1, "isAxiosError", { value: true });
      AxiosError.from = (error, code2, config, request2, response, customProps) => {
        const axiosError = Object.create(prototype$1);
        utils$1.toFlatObject(error, axiosError, function filter3(obj) {
          return obj !== Error.prototype;
        }, (prop) => {
          return prop !== "isAxiosError";
        });
        AxiosError.call(axiosError, error.message, code2, config, request2, response);
        axiosError.cause = error;
        axiosError.name = error.name;
        customProps && Object.assign(axiosError, customProps);
        return axiosError;
      };
      const httpAdapter = null;
      function isVisitable(thing) {
        return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
      }
      function removeBrackets(key) {
        return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
      }
      function renderKey(path, key, dots) {
        if (!path)
          return key;
        return path.concat(key).map(function each(token, i) {
          token = removeBrackets(token);
          return !dots && i ? "[" + token + "]" : token;
        }).join(dots ? "." : "");
      }
      function isFlatArray(arr) {
        return utils$1.isArray(arr) && !arr.some(isVisitable);
      }
      const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter2(prop) {
        return /^is[A-Z]/.test(prop);
      });
      function toFormData(obj, formData, options) {
        if (!utils$1.isObject(obj)) {
          throw new TypeError("target must be an object");
        }
        formData = formData || new FormData();
        options = utils$1.toFlatObject(options, {
          metaTokens: true,
          dots: false,
          indexes: false
        }, false, function defined(option, source) {
          return !utils$1.isUndefined(source[option]);
        });
        const metaTokens = options.metaTokens;
        const visitor = options.visitor || defaultVisitor;
        const dots = options.dots;
        const indexes = options.indexes;
        const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
        const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
        if (!utils$1.isFunction(visitor)) {
          throw new TypeError("visitor must be a function");
        }
        function convertValue(value) {
          if (value === null)
            return "";
          if (utils$1.isDate(value)) {
            return value.toISOString();
          }
          if (!useBlob && utils$1.isBlob(value)) {
            throw new AxiosError("Blob is not supported. Use a Buffer instead.");
          }
          if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
            return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
          }
          return value;
        }
        function defaultVisitor(value, key, path) {
          let arr = value;
          if (value && !path && typeof value === "object") {
            if (utils$1.endsWith(key, "{}")) {
              key = metaTokens ? key : key.slice(0, -2);
              value = JSON.stringify(value);
            } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
              key = removeBrackets(key);
              arr.forEach(function each(el, index) {
                !(utils$1.isUndefined(el) || el === null) && formData.append(
                  // eslint-disable-next-line no-nested-ternary
                  indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                  convertValue(el)
                );
              });
              return false;
            }
          }
          if (isVisitable(value)) {
            return true;
          }
          formData.append(renderKey(path, key, dots), convertValue(value));
          return false;
        }
        const stack = [];
        const exposedHelpers = Object.assign(predicates, {
          defaultVisitor,
          convertValue,
          isVisitable
        });
        function build(value, path) {
          if (utils$1.isUndefined(value))
            return;
          if (stack.indexOf(value) !== -1) {
            throw Error("Circular reference detected in " + path.join("."));
          }
          stack.push(value);
          utils$1.forEach(value, function each(el, key) {
            const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
              formData,
              el,
              utils$1.isString(key) ? key.trim() : key,
              path,
              exposedHelpers
            );
            if (result === true) {
              build(el, path ? path.concat(key) : [key]);
            }
          });
          stack.pop();
        }
        if (!utils$1.isObject(obj)) {
          throw new TypeError("data must be an object");
        }
        build(obj);
        return formData;
      }
      function encode$1(str2) {
        const charMap = {
          "!": "%21",
          "'": "%27",
          "(": "%28",
          ")": "%29",
          "~": "%7E",
          "%20": "+",
          "%00": "\0"
        };
        return encodeURIComponent(str2).replace(/[!'()~]|%20|%00/g, function replacer(match) {
          return charMap[match];
        });
      }
      function AxiosURLSearchParams(params, options) {
        this._pairs = [];
        params && toFormData(params, this, options);
      }
      const prototype = AxiosURLSearchParams.prototype;
      prototype.append = function append(name, value) {
        this._pairs.push([name, value]);
      };
      prototype.toString = function toString2(encoder) {
        const _encode = encoder ? function(value) {
          return encoder.call(this, value, encode$1);
        } : encode$1;
        return this._pairs.map(function each(pair) {
          return _encode(pair[0]) + "=" + _encode(pair[1]);
        }, "").join("&");
      };
      function encode(val) {
        return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      function buildURL(url, params, options) {
        if (!params) {
          return url;
        }
        const _encode = options && options.encode || encode;
        const serializeFn = options && options.serialize;
        let serializedParams;
        if (serializeFn) {
          serializedParams = serializeFn(params, options);
        } else {
          serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
        }
        if (serializedParams) {
          const hashmarkIndex = url.indexOf("#");
          if (hashmarkIndex !== -1) {
            url = url.slice(0, hashmarkIndex);
          }
          url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
        }
        return url;
      }
      class InterceptorManager {
        constructor() {
          this.handlers = [];
        }
        /**
         * Add a new interceptor to the stack
         *
         * @param {Function} fulfilled The function to handle `then` for a `Promise`
         * @param {Function} rejected The function to handle `reject` for a `Promise`
         *
         * @return {Number} An ID used to remove interceptor later
         */
        use(fulfilled, rejected, options) {
          this.handlers.push({
            fulfilled,
            rejected,
            synchronous: options ? options.synchronous : false,
            runWhen: options ? options.runWhen : null
          });
          return this.handlers.length - 1;
        }
        /**
         * Remove an interceptor from the stack
         *
         * @param {Number} id The ID that was returned by `use`
         *
         * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
         */
        eject(id) {
          if (this.handlers[id]) {
            this.handlers[id] = null;
          }
        }
        /**
         * Clear all interceptors from the stack
         *
         * @returns {void}
         */
        clear() {
          if (this.handlers) {
            this.handlers = [];
          }
        }
        /**
         * Iterate over all the registered interceptors
         *
         * This method is particularly useful for skipping over any
         * interceptors that may have become `null` calling `eject`.
         *
         * @param {Function} fn The function to call for each interceptor
         *
         * @returns {void}
         */
        forEach(fn2) {
          utils$1.forEach(this.handlers, function forEachHandler(h2) {
            if (h2 !== null) {
              fn2(h2);
            }
          });
        }
      }
      const transitionalDefaults = {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      };
      const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
      const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
      const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
      const platform$2 = {
        isBrowser: true,
        classes: {
          URLSearchParams: URLSearchParams$1,
          FormData: FormData$1,
          Blob: Blob$1
        },
        protocols: ["http", "https", "file", "blob", "url", "data"]
      };
      const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
      const hasStandardBrowserEnv = ((product) => {
        return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
      })(typeof navigator !== "undefined" && navigator.product);
      const hasStandardBrowserWebWorkerEnv = (() => {
        return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
        self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
      })();
      const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        hasBrowserEnv,
        hasStandardBrowserEnv,
        hasStandardBrowserWebWorkerEnv
      }, Symbol.toStringTag, { value: "Module" }));
      const platform$1 = {
        ...utils,
        ...platform$2
      };
      function toURLEncodedForm(data, options) {
        return toFormData(data, new platform$1.classes.URLSearchParams(), Object.assign({
          visitor: function(value, key, path, helpers) {
            if (platform$1.isNode && utils$1.isBuffer(value)) {
              this.append(key, value.toString("base64"));
              return false;
            }
            return helpers.defaultVisitor.apply(this, arguments);
          }
        }, options));
      }
      function parsePropPath(name) {
        return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
          return match[0] === "[]" ? "" : match[1] || match[0];
        });
      }
      function arrayToObject(arr) {
        const obj = {};
        const keys2 = Object.keys(arr);
        let i;
        const len = keys2.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys2[i];
          obj[key] = arr[key];
        }
        return obj;
      }
      function formDataToJSON(formData) {
        function buildPath(path, value, target, index) {
          let name = path[index++];
          if (name === "__proto__")
            return true;
          const isNumericKey = Number.isFinite(+name);
          const isLast = index >= path.length;
          name = !name && utils$1.isArray(target) ? target.length : name;
          if (isLast) {
            if (utils$1.hasOwnProp(target, name)) {
              target[name] = [target[name], value];
            } else {
              target[name] = value;
            }
            return !isNumericKey;
          }
          if (!target[name] || !utils$1.isObject(target[name])) {
            target[name] = [];
          }
          const result = buildPath(path, value, target[name], index);
          if (result && utils$1.isArray(target[name])) {
            target[name] = arrayToObject(target[name]);
          }
          return !isNumericKey;
        }
        if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
          const obj = {};
          utils$1.forEachEntry(formData, (name, value) => {
            buildPath(parsePropPath(name), value, obj, 0);
          });
          return obj;
        }
        return null;
      }
      function stringifySafely(rawValue, parser, encoder) {
        if (utils$1.isString(rawValue)) {
          try {
            (parser || JSON.parse)(rawValue);
            return utils$1.trim(rawValue);
          } catch (e) {
            if (e.name !== "SyntaxError") {
              throw e;
            }
          }
        }
        return (encoder || JSON.stringify)(rawValue);
      }
      const defaults = {
        transitional: transitionalDefaults,
        adapter: ["xhr", "http"],
        transformRequest: [function transformRequest(data, headers) {
          const contentType = headers.getContentType() || "";
          const hasJSONContentType = contentType.indexOf("application/json") > -1;
          const isObjectPayload = utils$1.isObject(data);
          if (isObjectPayload && utils$1.isHTMLForm(data)) {
            data = new FormData(data);
          }
          const isFormData2 = utils$1.isFormData(data);
          if (isFormData2) {
            return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
          }
          if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data)) {
            return data;
          }
          if (utils$1.isArrayBufferView(data)) {
            return data.buffer;
          }
          if (utils$1.isURLSearchParams(data)) {
            headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
            return data.toString();
          }
          let isFileList2;
          if (isObjectPayload) {
            if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
              return toURLEncodedForm(data, this.formSerializer).toString();
            }
            if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
              const _FormData = this.env && this.env.FormData;
              return toFormData(
                isFileList2 ? { "files[]": data } : data,
                _FormData && new _FormData(),
                this.formSerializer
              );
            }
          }
          if (isObjectPayload || hasJSONContentType) {
            headers.setContentType("application/json", false);
            return stringifySafely(data);
          }
          return data;
        }],
        transformResponse: [function transformResponse(data) {
          const transitional2 = this.transitional || defaults.transitional;
          const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
          const JSONRequested = this.responseType === "json";
          if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
            const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
            const strictJSONParsing = !silentJSONParsing && JSONRequested;
            try {
              return JSON.parse(data);
            } catch (e) {
              if (strictJSONParsing) {
                if (e.name === "SyntaxError") {
                  throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
                }
                throw e;
              }
            }
          }
          return data;
        }],
        /**
         * A timeout in milliseconds to abort a request. If set to 0 (default) a
         * timeout is not created.
         */
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        env: {
          FormData: platform$1.classes.FormData,
          Blob: platform$1.classes.Blob
        },
        validateStatus: function validateStatus(status) {
          return status >= 200 && status < 300;
        },
        headers: {
          common: {
            "Accept": "application/json, text/plain, */*",
            "Content-Type": void 0
          }
        }
      };
      utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
        defaults.headers[method] = {};
      });
      const defaults$1 = defaults;
      const ignoreDuplicateOf = utils$1.toObjectSet([
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent"
      ]);
      const parseHeaders = (rawHeaders) => {
        const parsed = {};
        let key;
        let val;
        let i;
        rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
          i = line.indexOf(":");
          key = line.substring(0, i).trim().toLowerCase();
          val = line.substring(i + 1).trim();
          if (!key || parsed[key] && ignoreDuplicateOf[key]) {
            return;
          }
          if (key === "set-cookie") {
            if (parsed[key]) {
              parsed[key].push(val);
            } else {
              parsed[key] = [val];
            }
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        });
        return parsed;
      };
      const $internals = Symbol("internals");
      function normalizeHeader(header) {
        return header && String(header).trim().toLowerCase();
      }
      function normalizeValue(value) {
        if (value === false || value == null) {
          return value;
        }
        return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
      }
      function parseTokens(str2) {
        const tokens = /* @__PURE__ */ Object.create(null);
        const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
        let match;
        while (match = tokensRE.exec(str2)) {
          tokens[match[1]] = match[2];
        }
        return tokens;
      }
      const isValidHeaderName = (str2) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str2.trim());
      function matchHeaderValue(context, value, header, filter3, isHeaderNameFilter) {
        if (utils$1.isFunction(filter3)) {
          return filter3.call(this, value, header);
        }
        if (isHeaderNameFilter) {
          value = header;
        }
        if (!utils$1.isString(value))
          return;
        if (utils$1.isString(filter3)) {
          return value.indexOf(filter3) !== -1;
        }
        if (utils$1.isRegExp(filter3)) {
          return filter3.test(value);
        }
      }
      function formatHeader(header) {
        return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str2) => {
          return char.toUpperCase() + str2;
        });
      }
      function buildAccessors(obj, header) {
        const accessorName = utils$1.toCamelCase(" " + header);
        ["get", "set", "has"].forEach((methodName) => {
          Object.defineProperty(obj, methodName + accessorName, {
            value: function(arg1, arg2, arg3) {
              return this[methodName].call(this, header, arg1, arg2, arg3);
            },
            configurable: true
          });
        });
      }
      class AxiosHeaders {
        constructor(headers) {
          headers && this.set(headers);
        }
        set(header, valueOrRewrite, rewrite) {
          const self2 = this;
          function setHeader(_value, _header, _rewrite) {
            const lHeader = normalizeHeader(_header);
            if (!lHeader) {
              throw new Error("header name must be a non-empty string");
            }
            const key = utils$1.findKey(self2, lHeader);
            if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
              self2[key || _header] = normalizeValue(_value);
            }
          }
          const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
          if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
            setHeaders(header, valueOrRewrite);
          } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
            setHeaders(parseHeaders(header), valueOrRewrite);
          } else {
            header != null && setHeader(valueOrRewrite, header, rewrite);
          }
          return this;
        }
        get(header, parser) {
          header = normalizeHeader(header);
          if (header) {
            const key = utils$1.findKey(this, header);
            if (key) {
              const value = this[key];
              if (!parser) {
                return value;
              }
              if (parser === true) {
                return parseTokens(value);
              }
              if (utils$1.isFunction(parser)) {
                return parser.call(this, value, key);
              }
              if (utils$1.isRegExp(parser)) {
                return parser.exec(value);
              }
              throw new TypeError("parser must be boolean|regexp|function");
            }
          }
        }
        has(header, matcher) {
          header = normalizeHeader(header);
          if (header) {
            const key = utils$1.findKey(this, header);
            return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
          }
          return false;
        }
        delete(header, matcher) {
          const self2 = this;
          let deleted = false;
          function deleteHeader(_header) {
            _header = normalizeHeader(_header);
            if (_header) {
              const key = utils$1.findKey(self2, _header);
              if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
                delete self2[key];
                deleted = true;
              }
            }
          }
          if (utils$1.isArray(header)) {
            header.forEach(deleteHeader);
          } else {
            deleteHeader(header);
          }
          return deleted;
        }
        clear(matcher) {
          const keys2 = Object.keys(this);
          let i = keys2.length;
          let deleted = false;
          while (i--) {
            const key = keys2[i];
            if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
              delete this[key];
              deleted = true;
            }
          }
          return deleted;
        }
        normalize(format) {
          const self2 = this;
          const headers = {};
          utils$1.forEach(this, (value, header) => {
            const key = utils$1.findKey(headers, header);
            if (key) {
              self2[key] = normalizeValue(value);
              delete self2[header];
              return;
            }
            const normalized = format ? formatHeader(header) : String(header).trim();
            if (normalized !== header) {
              delete self2[header];
            }
            self2[normalized] = normalizeValue(value);
            headers[normalized] = true;
          });
          return this;
        }
        concat(...targets) {
          return this.constructor.concat(this, ...targets);
        }
        toJSON(asStrings) {
          const obj = /* @__PURE__ */ Object.create(null);
          utils$1.forEach(this, (value, header) => {
            value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
          });
          return obj;
        }
        [Symbol.iterator]() {
          return Object.entries(this.toJSON())[Symbol.iterator]();
        }
        toString() {
          return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
        }
        get [Symbol.toStringTag]() {
          return "AxiosHeaders";
        }
        static from(thing) {
          return thing instanceof this ? thing : new this(thing);
        }
        static concat(first, ...targets) {
          const computed2 = new this(first);
          targets.forEach((target) => computed2.set(target));
          return computed2;
        }
        static accessor(header) {
          const internals = this[$internals] = this[$internals] = {
            accessors: {}
          };
          const accessors = internals.accessors;
          const prototype2 = this.prototype;
          function defineAccessor(_header) {
            const lHeader = normalizeHeader(_header);
            if (!accessors[lHeader]) {
              buildAccessors(prototype2, _header);
              accessors[lHeader] = true;
            }
          }
          utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
          return this;
        }
      }
      AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
      utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
        let mapped = key[0].toUpperCase() + key.slice(1);
        return {
          get: () => value,
          set(headerValue) {
            this[mapped] = headerValue;
          }
        };
      });
      utils$1.freezeMethods(AxiosHeaders);
      const AxiosHeaders$1 = AxiosHeaders;
      function transformData(fns, response) {
        const config = this || defaults$1;
        const context = response || config;
        const headers = AxiosHeaders$1.from(context.headers);
        let data = context.data;
        utils$1.forEach(fns, function transform(fn2) {
          data = fn2.call(config, data, headers.normalize(), response ? response.status : void 0);
        });
        headers.normalize();
        return data;
      }
      function isCancel(value) {
        return !!(value && value.__CANCEL__);
      }
      function CanceledError(message, config, request2) {
        AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request2);
        this.name = "CanceledError";
      }
      utils$1.inherits(CanceledError, AxiosError, {
        __CANCEL__: true
      });
      function settle(resolve, reject, response) {
        const validateStatus2 = response.config.validateStatus;
        if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
          resolve(response);
        } else {
          reject(new AxiosError(
            "Request failed with status code " + response.status,
            [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
            response.config,
            response.request,
            response
          ));
        }
      }
      const cookies = platform$1.hasStandardBrowserEnv ? (
        // Standard browser envs support document.cookie
        {
          write(name, value, expires, path, domain, secure) {
            const cookie = [name + "=" + encodeURIComponent(value)];
            utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
            utils$1.isString(path) && cookie.push("path=" + path);
            utils$1.isString(domain) && cookie.push("domain=" + domain);
            secure === true && cookie.push("secure");
            document.cookie = cookie.join("; ");
          },
          read(name) {
            const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        }
      ) : (
        // Non-standard browser env (web workers, react-native) lack needed support.
        {
          write() {
          },
          read() {
            return null;
          },
          remove() {
          }
        }
      );
      function isAbsoluteURL(url) {
        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
      }
      function combineURLs(baseURL, relativeURL) {
        return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
      }
      function buildFullPath(baseURL, requestedURL) {
        if (baseURL && !isAbsoluteURL(requestedURL)) {
          return combineURLs(baseURL, requestedURL);
        }
        return requestedURL;
      }
      const isURLSameOrigin = platform$1.hasStandardBrowserEnv ? (
        // Standard browser envs have full support of the APIs needed to test
        // whether the request URL is of the same origin as current location.
        function standardBrowserEnv() {
          const msie = /(msie|trident)/i.test(navigator.userAgent);
          const urlParsingNode = document.createElement("a");
          let originURL;
          function resolveURL(url) {
            let href = url;
            if (msie) {
              urlParsingNode.setAttribute("href", href);
              href = urlParsingNode.href;
            }
            urlParsingNode.setAttribute("href", href);
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
            };
          }
          originURL = resolveURL(window.location.href);
          return function isURLSameOrigin2(requestURL) {
            const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
            return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
          };
        }()
      ) : (
        // Non standard browser envs (web workers, react-native) lack needed support.
        /* @__PURE__ */ function nonStandardBrowserEnv() {
          return function isURLSameOrigin2() {
            return true;
          };
        }()
      );
      function parseProtocol(url) {
        const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
        return match && match[1] || "";
      }
      function speedometer(samplesCount, min) {
        samplesCount = samplesCount || 10;
        const bytes = new Array(samplesCount);
        const timestamps = new Array(samplesCount);
        let head = 0;
        let tail = 0;
        let firstSampleTS;
        min = min !== void 0 ? min : 1e3;
        return function push(chunkLength) {
          const now2 = Date.now();
          const startedAt = timestamps[tail];
          if (!firstSampleTS) {
            firstSampleTS = now2;
          }
          bytes[head] = chunkLength;
          timestamps[head] = now2;
          let i = tail;
          let bytesCount = 0;
          while (i !== head) {
            bytesCount += bytes[i++];
            i = i % samplesCount;
          }
          head = (head + 1) % samplesCount;
          if (head === tail) {
            tail = (tail + 1) % samplesCount;
          }
          if (now2 - firstSampleTS < min) {
            return;
          }
          const passed = startedAt && now2 - startedAt;
          return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
        };
      }
      function progressEventReducer(listener, isDownloadStream) {
        let bytesNotified = 0;
        const _speedometer = speedometer(50, 250);
        return (e) => {
          const loaded = e.loaded;
          const total = e.lengthComputable ? e.total : void 0;
          const progressBytes = loaded - bytesNotified;
          const rate = _speedometer(progressBytes);
          const inRange = loaded <= total;
          bytesNotified = loaded;
          const data = {
            loaded,
            total,
            progress: total ? loaded / total : void 0,
            bytes: progressBytes,
            rate: rate ? rate : void 0,
            estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
            event: e
          };
          data[isDownloadStream ? "download" : "upload"] = true;
          listener(data);
        };
      }
      const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
      const xhrAdapter = isXHRAdapterSupported && function(config) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
          let requestData = config.data;
          const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
          let { responseType, withXSRFToken } = config;
          let onCanceled;
          function done() {
            if (config.cancelToken) {
              config.cancelToken.unsubscribe(onCanceled);
            }
            if (config.signal) {
              config.signal.removeEventListener("abort", onCanceled);
            }
          }
          let contentType;
          if (utils$1.isFormData(requestData)) {
            if (platform$1.hasStandardBrowserEnv || platform$1.hasStandardBrowserWebWorkerEnv) {
              requestHeaders.setContentType(false);
            } else if ((contentType = requestHeaders.getContentType()) !== false) {
              const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
              requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
            }
          }
          let request2 = new XMLHttpRequest();
          if (config.auth) {
            const username = config.auth.username || "";
            const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
            requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
          }
          const fullPath = buildFullPath(config.baseURL, config.url);
          request2.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
          request2.timeout = config.timeout;
          function onloadend() {
            if (!request2) {
              return;
            }
            const responseHeaders = AxiosHeaders$1.from(
              "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
            );
            const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
            const response = {
              data: responseData,
              status: request2.status,
              statusText: request2.statusText,
              headers: responseHeaders,
              config,
              request: request2
            };
            settle(function _resolve(value) {
              resolve(value);
              done();
            }, function _reject(err) {
              reject(err);
              done();
            }, response);
            request2 = null;
          }
          if ("onloadend" in request2) {
            request2.onloadend = onloadend;
          } else {
            request2.onreadystatechange = function handleLoad() {
              if (!request2 || request2.readyState !== 4) {
                return;
              }
              if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
                return;
              }
              setTimeout(onloadend);
            };
          }
          request2.onabort = function handleAbort() {
            if (!request2) {
              return;
            }
            reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request2));
            request2 = null;
          };
          request2.onerror = function handleError() {
            reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request2));
            request2 = null;
          };
          request2.ontimeout = function handleTimeout() {
            let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            const transitional2 = config.transitional || transitionalDefaults;
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject(new AxiosError(
              timeoutErrorMessage,
              transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
              config,
              request2
            ));
            request2 = null;
          };
          if (platform$1.hasStandardBrowserEnv) {
            withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
            if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(fullPath)) {
              const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
              if (xsrfValue) {
                requestHeaders.set(config.xsrfHeaderName, xsrfValue);
              }
            }
          }
          requestData === void 0 && requestHeaders.setContentType(null);
          if ("setRequestHeader" in request2) {
            utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
              request2.setRequestHeader(key, val);
            });
          }
          if (!utils$1.isUndefined(config.withCredentials)) {
            request2.withCredentials = !!config.withCredentials;
          }
          if (responseType && responseType !== "json") {
            request2.responseType = config.responseType;
          }
          if (typeof config.onDownloadProgress === "function") {
            request2.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
          }
          if (typeof config.onUploadProgress === "function" && request2.upload) {
            request2.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
          }
          if (config.cancelToken || config.signal) {
            onCanceled = (cancel) => {
              if (!request2) {
                return;
              }
              reject(!cancel || cancel.type ? new CanceledError(null, config, request2) : cancel);
              request2.abort();
              request2 = null;
            };
            config.cancelToken && config.cancelToken.subscribe(onCanceled);
            if (config.signal) {
              config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
            }
          }
          const protocol = parseProtocol(fullPath);
          if (protocol && platform$1.protocols.indexOf(protocol) === -1) {
            reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
            return;
          }
          request2.send(requestData || null);
        });
      };
      const knownAdapters = {
        http: httpAdapter,
        xhr: xhrAdapter
      };
      utils$1.forEach(knownAdapters, (fn2, value) => {
        if (fn2) {
          try {
            Object.defineProperty(fn2, "name", { value });
          } catch (e) {
          }
          Object.defineProperty(fn2, "adapterName", { value });
        }
      });
      const renderReason = (reason) => `- ${reason}`;
      const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
      const adapters = {
        getAdapter: (adapters2) => {
          adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
          const { length } = adapters2;
          let nameOrAdapter;
          let adapter;
          const rejectedReasons = {};
          for (let i = 0; i < length; i++) {
            nameOrAdapter = adapters2[i];
            let id;
            adapter = nameOrAdapter;
            if (!isResolvedHandle(nameOrAdapter)) {
              adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
              if (adapter === void 0) {
                throw new AxiosError(`Unknown adapter '${id}'`);
              }
            }
            if (adapter) {
              break;
            }
            rejectedReasons[id || "#" + i] = adapter;
          }
          if (!adapter) {
            const reasons = Object.entries(rejectedReasons).map(
              ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
            );
            let s2 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
            throw new AxiosError(
              `There is no suitable adapter to dispatch the request ` + s2,
              "ERR_NOT_SUPPORT"
            );
          }
          return adapter;
        },
        adapters: knownAdapters
      };
      function throwIfCancellationRequested(config) {
        if (config.cancelToken) {
          config.cancelToken.throwIfRequested();
        }
        if (config.signal && config.signal.aborted) {
          throw new CanceledError(null, config);
        }
      }
      function dispatchRequest(config) {
        throwIfCancellationRequested(config);
        config.headers = AxiosHeaders$1.from(config.headers);
        config.data = transformData.call(
          config,
          config.transformRequest
        );
        if (["post", "put", "patch"].indexOf(config.method) !== -1) {
          config.headers.setContentType("application/x-www-form-urlencoded", false);
        }
        const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
        return adapter(config).then(function onAdapterResolution(response) {
          throwIfCancellationRequested(config);
          response.data = transformData.call(
            config,
            config.transformResponse,
            response
          );
          response.headers = AxiosHeaders$1.from(response.headers);
          return response;
        }, function onAdapterRejection(reason) {
          if (!isCancel(reason)) {
            throwIfCancellationRequested(config);
            if (reason && reason.response) {
              reason.response.data = transformData.call(
                config,
                config.transformResponse,
                reason.response
              );
              reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
            }
          }
          return Promise.reject(reason);
        });
      }
      const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
      function mergeConfig$1(config1, config2) {
        config2 = config2 || {};
        const config = {};
        function getMergedValue(target, source, caseless) {
          if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
            return utils$1.merge.call({ caseless }, target, source);
          } else if (utils$1.isPlainObject(source)) {
            return utils$1.merge({}, source);
          } else if (utils$1.isArray(source)) {
            return source.slice();
          }
          return source;
        }
        function mergeDeepProperties(a2, b2, caseless) {
          if (!utils$1.isUndefined(b2)) {
            return getMergedValue(a2, b2, caseless);
          } else if (!utils$1.isUndefined(a2)) {
            return getMergedValue(void 0, a2, caseless);
          }
        }
        function valueFromConfig2(a2, b2) {
          if (!utils$1.isUndefined(b2)) {
            return getMergedValue(void 0, b2);
          }
        }
        function defaultToConfig2(a2, b2) {
          if (!utils$1.isUndefined(b2)) {
            return getMergedValue(void 0, b2);
          } else if (!utils$1.isUndefined(a2)) {
            return getMergedValue(void 0, a2);
          }
        }
        function mergeDirectKeys(a2, b2, prop) {
          if (prop in config2) {
            return getMergedValue(a2, b2);
          } else if (prop in config1) {
            return getMergedValue(void 0, a2);
          }
        }
        const mergeMap = {
          url: valueFromConfig2,
          method: valueFromConfig2,
          data: valueFromConfig2,
          baseURL: defaultToConfig2,
          transformRequest: defaultToConfig2,
          transformResponse: defaultToConfig2,
          paramsSerializer: defaultToConfig2,
          timeout: defaultToConfig2,
          timeoutMessage: defaultToConfig2,
          withCredentials: defaultToConfig2,
          withXSRFToken: defaultToConfig2,
          adapter: defaultToConfig2,
          responseType: defaultToConfig2,
          xsrfCookieName: defaultToConfig2,
          xsrfHeaderName: defaultToConfig2,
          onUploadProgress: defaultToConfig2,
          onDownloadProgress: defaultToConfig2,
          decompress: defaultToConfig2,
          maxContentLength: defaultToConfig2,
          maxBodyLength: defaultToConfig2,
          beforeRedirect: defaultToConfig2,
          transport: defaultToConfig2,
          httpAgent: defaultToConfig2,
          httpsAgent: defaultToConfig2,
          cancelToken: defaultToConfig2,
          socketPath: defaultToConfig2,
          responseEncoding: defaultToConfig2,
          validateStatus: mergeDirectKeys,
          headers: (a2, b2) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), true)
        };
        utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
          const merge2 = mergeMap[prop] || mergeDeepProperties;
          const configValue = merge2(config1[prop], config2[prop], prop);
          utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
        });
        return config;
      }
      const VERSION = "1.6.8";
      const validators$1 = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
        validators$1[type] = function validator2(thing) {
          return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
        };
      });
      const deprecatedWarnings = {};
      validators$1.transitional = function transitional(validator2, version, message) {
        function formatMessage(opt, desc) {
          return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
        }
        return (value, opt, opts) => {
          if (validator2 === false) {
            throw new AxiosError(
              formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
              AxiosError.ERR_DEPRECATED
            );
          }
          if (version && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            console.warn(
              formatMessage(
                opt,
                " has been deprecated since v" + version + " and will be removed in the near future"
              )
            );
          }
          return validator2 ? validator2(value, opt, opts) : true;
        };
      };
      function assertOptions(options, schema, allowUnknown) {
        if (typeof options !== "object") {
          throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
        }
        const keys2 = Object.keys(options);
        let i = keys2.length;
        while (i-- > 0) {
          const opt = keys2[i];
          const validator2 = schema[opt];
          if (validator2) {
            const value = options[opt];
            const result = value === void 0 || validator2(value, opt, options);
            if (result !== true) {
              throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
            }
            continue;
          }
          if (allowUnknown !== true) {
            throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
          }
        }
      }
      const validator = {
        assertOptions,
        validators: validators$1
      };
      const validators = validator.validators;
      class Axios {
        constructor(instanceConfig) {
          this.defaults = instanceConfig;
          this.interceptors = {
            request: new InterceptorManager(),
            response: new InterceptorManager()
          };
        }
        /**
         * Dispatch a request
         *
         * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
         * @param {?Object} config
         *
         * @returns {Promise} The Promise to be fulfilled
         */
        async request(configOrUrl, config) {
          try {
            return await this._request(configOrUrl, config);
          } catch (err) {
            if (err instanceof Error) {
              let dummy;
              Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
              const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
              if (!err.stack) {
                err.stack = stack;
              } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
                err.stack += "\n" + stack;
              }
            }
            throw err;
          }
        }
        _request(configOrUrl, config) {
          if (typeof configOrUrl === "string") {
            config = config || {};
            config.url = configOrUrl;
          } else {
            config = configOrUrl || {};
          }
          config = mergeConfig$1(this.defaults, config);
          const { transitional: transitional2, paramsSerializer, headers } = config;
          if (transitional2 !== void 0) {
            validator.assertOptions(transitional2, {
              silentJSONParsing: validators.transitional(validators.boolean),
              forcedJSONParsing: validators.transitional(validators.boolean),
              clarifyTimeoutError: validators.transitional(validators.boolean)
            }, false);
          }
          if (paramsSerializer != null) {
            if (utils$1.isFunction(paramsSerializer)) {
              config.paramsSerializer = {
                serialize: paramsSerializer
              };
            } else {
              validator.assertOptions(paramsSerializer, {
                encode: validators.function,
                serialize: validators.function
              }, true);
            }
          }
          config.method = (config.method || this.defaults.method || "get").toLowerCase();
          let contextHeaders = headers && utils$1.merge(
            headers.common,
            headers[config.method]
          );
          headers && utils$1.forEach(
            ["delete", "get", "head", "post", "put", "patch", "common"],
            (method) => {
              delete headers[method];
            }
          );
          config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
          const requestInterceptorChain = [];
          let synchronousRequestInterceptors = true;
          this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
            if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
              return;
            }
            synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
            requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
          });
          const responseInterceptorChain = [];
          this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
            responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
          });
          let promise;
          let i = 0;
          let len;
          if (!synchronousRequestInterceptors) {
            const chain = [dispatchRequest.bind(this), void 0];
            chain.unshift.apply(chain, requestInterceptorChain);
            chain.push.apply(chain, responseInterceptorChain);
            len = chain.length;
            promise = Promise.resolve(config);
            while (i < len) {
              promise = promise.then(chain[i++], chain[i++]);
            }
            return promise;
          }
          len = requestInterceptorChain.length;
          let newConfig = config;
          i = 0;
          while (i < len) {
            const onFulfilled = requestInterceptorChain[i++];
            const onRejected = requestInterceptorChain[i++];
            try {
              newConfig = onFulfilled(newConfig);
            } catch (error) {
              onRejected.call(this, error);
              break;
            }
          }
          try {
            promise = dispatchRequest.call(this, newConfig);
          } catch (error) {
            return Promise.reject(error);
          }
          i = 0;
          len = responseInterceptorChain.length;
          while (i < len) {
            promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
          }
          return promise;
        }
        getUri(config) {
          config = mergeConfig$1(this.defaults, config);
          const fullPath = buildFullPath(config.baseURL, config.url);
          return buildURL(fullPath, config.params, config.paramsSerializer);
        }
      }
      utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
        Axios.prototype[method] = function(url, config) {
          return this.request(mergeConfig$1(config || {}, {
            method,
            url,
            data: (config || {}).data
          }));
        };
      });
      utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
        function generateHTTPMethod(isForm) {
          return function httpMethod(url, data, config) {
            return this.request(mergeConfig$1(config || {}, {
              method,
              headers: isForm ? {
                "Content-Type": "multipart/form-data"
              } : {},
              url,
              data
            }));
          };
        }
        Axios.prototype[method] = generateHTTPMethod();
        Axios.prototype[method + "Form"] = generateHTTPMethod(true);
      });
      const Axios$1 = Axios;
      class CancelToken {
        constructor(executor) {
          if (typeof executor !== "function") {
            throw new TypeError("executor must be a function.");
          }
          let resolvePromise;
          this.promise = new Promise(function promiseExecutor(resolve) {
            resolvePromise = resolve;
          });
          const token = this;
          this.promise.then((cancel) => {
            if (!token._listeners)
              return;
            let i = token._listeners.length;
            while (i-- > 0) {
              token._listeners[i](cancel);
            }
            token._listeners = null;
          });
          this.promise.then = (onfulfilled) => {
            let _resolve;
            const promise = new Promise((resolve) => {
              token.subscribe(resolve);
              _resolve = resolve;
            }).then(onfulfilled);
            promise.cancel = function reject() {
              token.unsubscribe(_resolve);
            };
            return promise;
          };
          executor(function cancel(message, config, request2) {
            if (token.reason) {
              return;
            }
            token.reason = new CanceledError(message, config, request2);
            resolvePromise(token.reason);
          });
        }
        /**
         * Throws a `CanceledError` if cancellation has been requested.
         */
        throwIfRequested() {
          if (this.reason) {
            throw this.reason;
          }
        }
        /**
         * Subscribe to the cancel signal
         */
        subscribe(listener) {
          if (this.reason) {
            listener(this.reason);
            return;
          }
          if (this._listeners) {
            this._listeners.push(listener);
          } else {
            this._listeners = [listener];
          }
        }
        /**
         * Unsubscribe from the cancel signal
         */
        unsubscribe(listener) {
          if (!this._listeners) {
            return;
          }
          const index = this._listeners.indexOf(listener);
          if (index !== -1) {
            this._listeners.splice(index, 1);
          }
        }
        /**
         * Returns an object that contains a new `CancelToken` and a function that, when called,
         * cancels the `CancelToken`.
         */
        static source() {
          let cancel;
          const token = new CancelToken(function executor(c2) {
            cancel = c2;
          });
          return {
            token,
            cancel
          };
        }
      }
      const CancelToken$1 = CancelToken;
      function spread(callback) {
        return function wrap(arr) {
          return callback.apply(null, arr);
        };
      }
      function isAxiosError(payload) {
        return utils$1.isObject(payload) && payload.isAxiosError === true;
      }
      const HttpStatusCode = {
        Continue: 100,
        SwitchingProtocols: 101,
        Processing: 102,
        EarlyHints: 103,
        Ok: 200,
        Created: 201,
        Accepted: 202,
        NonAuthoritativeInformation: 203,
        NoContent: 204,
        ResetContent: 205,
        PartialContent: 206,
        MultiStatus: 207,
        AlreadyReported: 208,
        ImUsed: 226,
        MultipleChoices: 300,
        MovedPermanently: 301,
        Found: 302,
        SeeOther: 303,
        NotModified: 304,
        UseProxy: 305,
        Unused: 306,
        TemporaryRedirect: 307,
        PermanentRedirect: 308,
        BadRequest: 400,
        Unauthorized: 401,
        PaymentRequired: 402,
        Forbidden: 403,
        NotFound: 404,
        MethodNotAllowed: 405,
        NotAcceptable: 406,
        ProxyAuthenticationRequired: 407,
        RequestTimeout: 408,
        Conflict: 409,
        Gone: 410,
        LengthRequired: 411,
        PreconditionFailed: 412,
        PayloadTooLarge: 413,
        UriTooLong: 414,
        UnsupportedMediaType: 415,
        RangeNotSatisfiable: 416,
        ExpectationFailed: 417,
        ImATeapot: 418,
        MisdirectedRequest: 421,
        UnprocessableEntity: 422,
        Locked: 423,
        FailedDependency: 424,
        TooEarly: 425,
        UpgradeRequired: 426,
        PreconditionRequired: 428,
        TooManyRequests: 429,
        RequestHeaderFieldsTooLarge: 431,
        UnavailableForLegalReasons: 451,
        InternalServerError: 500,
        NotImplemented: 501,
        BadGateway: 502,
        ServiceUnavailable: 503,
        GatewayTimeout: 504,
        HttpVersionNotSupported: 505,
        VariantAlsoNegotiates: 506,
        InsufficientStorage: 507,
        LoopDetected: 508,
        NotExtended: 510,
        NetworkAuthenticationRequired: 511
      };
      Object.entries(HttpStatusCode).forEach(([key, value]) => {
        HttpStatusCode[value] = key;
      });
      const HttpStatusCode$1 = HttpStatusCode;
      function createInstance(defaultConfig) {
        const context = new Axios$1(defaultConfig);
        const instance = bind(Axios$1.prototype.request, context);
        utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
        utils$1.extend(instance, context, null, { allOwnKeys: true });
        instance.create = function create(instanceConfig) {
          return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
        };
        return instance;
      }
      const axios = exports("bt", createInstance(defaults$1));
      axios.Axios = Axios$1;
      axios.CanceledError = CanceledError;
      axios.CancelToken = CancelToken$1;
      axios.isCancel = isCancel;
      axios.VERSION = VERSION;
      axios.toFormData = toFormData;
      axios.AxiosError = AxiosError;
      axios.Cancel = axios.CanceledError;
      axios.all = function all(promises) {
        return Promise.all(promises);
      };
      axios.spread = spread;
      axios.isAxiosError = isAxiosError;
      axios.mergeConfig = mergeConfig$1;
      axios.AxiosHeaders = AxiosHeaders$1;
      axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
      axios.getAdapter = adapters.getAdapter;
      axios.HttpStatusCode = HttpStatusCode$1;
      axios.default = axios;
      var PushStatus = exports("bg", /* @__PURE__ */ ((PushStatus2) => {
        PushStatus2[PushStatus2["NOT_START"] = 0] = "NOT_START";
        PushStatus2[PushStatus2["PUSHING"] = 1] = "PUSHING";
        PushStatus2[PushStatus2["PAUSE"] = 2] = "PAUSE";
        PushStatus2[PushStatus2["LIMIT"] = 3] = "LIMIT";
        return PushStatus2;
      })(PushStatus || {}));
      var PushResultStatus = /* @__PURE__ */ ((PushResultStatus2) => {
        PushResultStatus2[PushResultStatus2["NOT_START"] = -1] = "NOT_START";
        PushResultStatus2[PushResultStatus2["SUCCESS"] = 0] = "SUCCESS";
        PushResultStatus2[PushResultStatus2["FAIL"] = 1] = "FAIL";
        return PushResultStatus2;
      })(PushResultStatus || {});
      const _LogRecorder = class _LogRecorder extends Logger {
        constructor(name = "") {
          super(name);
          __publicField(this, "persistTimer", null);
          // 设置日志存储的最大条数
          __publicField(this, "maxLogs", 1e3);
          this.loadLogsFromStorage();
          this.startPersistTimer();
        }
        loadLogsFromStorage() {
          const storedLogs = TampermonkeyApi.GmGetValue(_LogRecorder.LOGS_STORAGE_KEY, []);
          const existingTimestamps = new Set(_LogRecorder.logs.map((log) => log.timestamp));
          const uniqueStoredLogs = storedLogs.filter((log) => !existingTimestamps.has(log.timestamp));
          _LogRecorder.logs = [..._LogRecorder.logs, ...uniqueStoredLogs];
        }
        startPersistTimer() {
          this.persistTimer = window.setInterval(() => {
            this.persistLogs();
          }, 1e4);
        }
        persistLogs() {
          TampermonkeyApi.GmSetValue(_LogRecorder.LOGS_STORAGE_KEY, _LogRecorder.logs);
        }
        clearLogs() {
          _LogRecorder.logs = [];
          this.persistLogs();
        }
        addLog(level, message) {
          const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString();
          _LogRecorder.logs.push({ level, message, timestamp });
          if (_LogRecorder.logs.length > this.maxLogs) {
            _LogRecorder.logs.shift();
          }
        }
        error(...messages) {
          const msg = messages.join(" ");
          this.addLog("error", msg);
          super.error(msg);
        }
        warn(...messages) {
          const msg = messages.join(" ");
          this.addLog("warn", msg);
          super.warn(msg);
        }
        info(...messages) {
          const msg = messages.join(" ");
          this.addLog("info", msg);
          super.info(msg);
        }
        debug(...messages) {
          const msg = messages.join(" ");
          this.addLog("debug", msg);
          super.debug(msg);
        }
        trace(...messages) {
          const msg = messages.join(" ");
          this.addLog("trace", msg);
          super.trace(msg);
        }
        // 获取日志数据，支持分页
        getLogs(page, pageSize) {
          const start = (page - 1) * pageSize;
          return _LogRecorder.logs.slice(start, start + pageSize);
        }
        // 获取日志总条数
        getLogCount() {
          return _LogRecorder.logs.length;
        }
      };
      __publicField(_LogRecorder, "LOGS_STORAGE_KEY", "logs_data");
      __publicField(_LogRecorder, "logs", []);
      let LogRecorder = exports("bh", _LogRecorder);
      const logRecorder$3 = new LogRecorder("call");
      let protoDefinition = 'option java_package = "cn.techwolf.boss.chat";option java_outer_classname = "ChatProtocol";message TechwolfUser {required int64 uid = 1;optional string name = 2;optional string avatar = 3;optional string company = 4;optional int32 headImg = 5;optional int32 certification = 6;optional int32 source = 7;}message TechwolfSound {optional int64 sid = 1;optional string url = 2;optional int32 duration = 3;optional int32 templateId = 4;}message TechwolfVideo {required int32 type = 1;required int32 status = 2;optional int32 duration = 3;optional string text = 4;}message TechwolfInterview {required int32 condition = 1;required string text = 2;optional string url = 3;optional string extend = 4;}message TechwolfImageInfo {required string url = 1;required int32 width = 2;required int32 height = 3;}message TechwolfImage {optional int64 iid = 1;optional TechwolfImageInfo tinyImage = 2;optional TechwolfImageInfo originImage = 3;}message TechwolfAction {required int32 aid = 1;optional string extend = 2;}message TechwolfArticle {required string title = 1;required string description = 2;required string picUrl = 3;required string url = 4;optional int32 templateId = 5;optional string bottomText = 6;optional int64 timeout = 7;optional string statisticParameters = 8;repeated TechwolfSlice highlightParts = 9;repeated TechwolfSlice dimParts = 10;optional string subTitle = 11;optional string extend = 12;}message TechwolfNotify {required string text = 1;optional string url = 2;optional string title = 3;}message TechwolfButton {required string text = 1;optional string url = 2;optional int32 templateId = 3;}message TechwolfDialog {required string text = 1;repeated TechwolfButton buttons = 2;required bool operated = 3;optional bool clickMore = 4;optional int32 type = 5;optional string backgroundUrl = 6;optional int64 timeout = 7;optional string statisticParameters = 8;optional string title = 9;optional string url = 10;optional int32 selectedIndex = 11;optional string extend = 12;optional string content = 13;}message TechwolfJobDesc {required string title = 1;required string company = 2;required string salary = 3;required string url = 4;required int64 jobId = 5;optional string positionCategory = 6;optional string experience = 7;optional string education = 8;optional string city = 9;optional string bossTitle = 10;optional TechwolfUser boss = 11;optional string lid = 12;optional string stage = 13;optional string bottomText = 14;optional string jobLabel = 15;optional int32 iconFlag = 16;optional string content = 17;repeated string labels = 18;optional int64 expectId = 19;optional string expectPosition = 20;optional string expectSalary = 21;optional string partTimeDesc = 22;optional TechwolfUser geek = 23;optional string latlon = 24;optional string distance = 25;}message TechwolfResume {required TechwolfUser user = 1;optional string description = 2;optional string city = 3;optional string position = 4;repeated string keywords = 5;optional int64 expectId = 6;optional string lid = 7;optional int32 gender = 8;optional string salary = 9;optional string workYear = 10;optional string content1 = 11;optional string content2 = 12;optional string education = 13;optional string age = 14;repeated string labels = 15;repeated UserExperience experiences = 16;optional string positionCategory = 17;optional string jobSalary = 18;optional string bottomText = 19;optional string applyStatus = 20;optional int64 jobId = 21;optional string content3 = 22;optional string securityId = 23;optional TechwolfUser boss = 24;optional string brandName = 25;}message TechwolfHyperLink {required string text = 1;required string url = 2;required int32 hyperLinkType = 3;optional string extraJson=4;}message TechwolfMessageBody {required int32 type = 1;required int32 templateId = 2;optional string headTitle = 11;optional string text = 3;optional TechwolfSound sound = 4;optional TechwolfImage image = 5;optional TechwolfAction action = 6;repeated TechwolfArticle articles = 7;optional TechwolfNotify notify = 8;optional TechwolfDialog dialog = 9;optional TechwolfJobDesc jobDesc = 10;optional TechwolfResume resume = 12;optional TechwolfRedEnvelope redEnvelope = 13;optional TechwolfOrderDetail orderDetail = 14;optional TechwolfHyperLink hyperLink = 15;optional TechwolfVideo video = 16;optional TechwolfInterview interview = 17;optional TechwolfJobShare jobShare = 18;optional TechwolfResumeShare resumeShare = 19;optional AtInfo atInfo = 20;optional TechwolfSticker sticker = 21;optional TechwolfChatShare chatShare = 22;optional TechwolfInterviewShare interviewShare = 23;optional TechwolfListCard listCard = 24;optional TechwolfStarRate starRate = 25;optional TechwolfFrame frame = 26;optional TechwolfMultiImage multiImage = 27;optional string extend = 28;}message TechwolfMessage {required TechwolfUser from = 1;required TechwolfUser to = 2;required int32 type = 3;optional int64 mid = 4;optional int64 time = 5;required TechwolfMessageBody body = 6;optional bool offline = 7;optional bool received = 8;optional string pushText = 9;optional int64 taskId = 10;optional int64 cmid = 11;optional int32 status = 12;optional int32 uncount = 13;optional int32 pushSound = 14;optional int32 flag = 15;optional bytes encryptedBody = 16;optional string bizId = 17;optional int32 bizType = 18;optional string securityId = 19;}message TechwolfClientInfo {optional string version = 1;optional string system = 2;optional string systemVersion = 3;optional string model = 4;optional string uniqid = 5;optional string network = 6;optional int32 appid = 7;optional string platform = 8;optional string channel = 9;optional string ssid = 10;optional string bssid = 11;optional double longitude = 12;optional double latitude = 13;}message TechwolfClientTime {optional int64 startTime = 1;optional int64 resumeTime = 2;}message TechwolfPresence {required int32 type = 1;required int32 uid = 2;optional TechwolfClientInfo clientInfo = 3;optional TechwolfClientTime clientTime = 4;optional int64 lastMessageId = 5;optional int64 lastGroupMessageId = 6;optional int64 userId = 7;}message TechwolfKVEntry {required string key = 1;required string value = 2;}message TechwolfIq {required int64 qid = 1;required string query = 2;repeated TechwolfKVEntry params = 3;}message TechwolfIqResponse {required int64 qid = 1;required string query = 2;repeated TechwolfKVEntry results = 3;}message TechwolfMessageSync {required int64 clientMid = 1;required int64 serverMid = 2;}message TechwolfMessageRead {required int64 userId = 1;required int64 messageId = 2;required int64 readTime = 3;optional bool sync = 4 [default = false];optional int32 userSource = 5;}message TechwolfChatProtocol {required int32 type = 1;optional string version = 2;repeated TechwolfMessage messages = 3;optional TechwolfPresence presence = 4;optional TechwolfIq iq = 5;optional TechwolfIqResponse iqResponse = 6;repeated TechwolfMessageSync messageSync = 7;repeated TechwolfMessageRead messageRead = 8;optional TechwolfDataSync dataSync = 9;optional int32 domain = 10;}message TechwolfRedEnvelope {required int64 redId = 1;required string redText = 2;required string redTitle = 3;required string clickUrl = 4;}message TechwolfOrderDetail {required string title = 1;required string subTitle = 2;optional string url = 3;repeated TechwolfOrderDetailEntry orderDetailEntryList =  4;}message TechwolfOrderDetailItem {required string name = 1;required int32 templateId = 2;}message TechwolfOrderDetailEntry {required TechwolfOrderDetailItem key = 1;required TechwolfOrderDetailItem value = 2;}message TechwolfUserSync {required int64 uid = 1;required int32 identity = 2;optional string extraJson = 3;optional int32 userSource = 4;}message TechwolfDataSync {required int32 type = 1;optional TechwolfUserSync userSync = 2;optional TechwolfGroupSync groupSync = 3;}message TechwolfSlice {required int32 startIndex = 1;required int32 endIndex = 2;}message UserExperience {required string organization = 1;required string occupation = 2;optional string startDate = 3;optional string endDate = 4;required int32 type = 5;}message TechwolfJobShare {required TechwolfUser user = 1;required int64 jobId = 2;required string position = 3;required string salary = 4;optional string location = 5;required string company = 6;optional string stage = 7;optional string experience = 8;optional string education = 9;optional string url = 10;optional string lid = 11;optional string price = 12;optional string description = 13;}message TechwolfResumeShare {required TechwolfUser user = 1;required int64 expectId = 2;required string position = 3;required string salary = 4;optional string location = 5;optional string applyStatus = 6;optional string age = 7;optional string experience = 8;optional string education = 9;optional string url = 10;optional string lid = 11;optional int32 gender = 12;optional bool blurred = 13;optional int32 source = 14;}message AtInfo {required int32 flag = 1;repeated int64 uids = 2;}message TechwolfGroupSync {required int64 gid = 1;optional int32 version = 2;optional string encGid = 3;}message TechwolfSticker {required int64 sid = 1;optional int64 packId = 2;optional TechwolfImage image = 3;optional string format = 4;optional string name = 5;}message TechwolfChatShare {required int64 shareId = 1;required string title = 2;repeated string records = 3;optional string bottomText = 4;optional string url = 5;required TechwolfUser from = 6;required TechwolfUser to = 7;required TechwolfUser user = 8;}message TechwolfInterviewShare {required int64 interviewId = 1;required TechwolfUser user = 2;required string title = 3;required string bottomText = 4;optional string url = 5;optional string interviewTime = 6;optional string interviewAddress = 7;optional string jobName = 8;}message TechwolfListItem {optional string title = 1;optional int32 icon = 2;}message TechwolfListCard {optional string title = 1;repeated TechwolfListItem items = 2;optional int32 pageSize = 3;}message TechwolfStar {required int64 starId = 1;optional string starDesc = 2;repeated TechwolfListItem options = 3;}message TechwolfStarRate {optional string title = 1;repeated TechwolfStar stars = 2;required int32 rateStatus = 3;optional TechwolfStar rateStar = 4;optional TechwolfButton submitButton = 5;}message TechwolfFrame {required string href = 1;}message TechwolfMultiImage {repeated TechwolfImageInfo images = 1;}';
      const root$1 = protobuf.parse(protoDefinition).root;
      const protobufType = root$1.lookupType("TechwolfChatProtocol");
      class Message {
        constructor({
          form_uid,
          to_uid,
          to_name,
          content,
          image
        }) {
          __publicField(this, "msg");
          __publicField(this, "msgObj");
          __publicField(this, "hex");
          const r = (/* @__PURE__ */ new Date()).getTime();
          const d2 = r + 68256432452609;
          const data = {
            messages: [
              {
                from: {
                  uid: form_uid,
                  source: 0
                },
                to: {
                  uid: to_uid,
                  name: to_name,
                  source: 0
                },
                type: 1,
                mid: d2.toString(),
                time: r.toString(),
                body: {
                  type: image ? 3 : 1,
                  templateId: 1,
                  text: image ? null : content,
                  image: image ? {
                    originImage: {
                      url: image.originImage
                    },
                    tinyImage: {
                      url: image.tinyImage
                    }
                  } : {}
                },
                cmid: d2.toString()
              }
            ],
            type: 1
          };
          this.msgObj = data.messages[0];
          this.msg = protobufType.encode(data).finish().slice();
          this.hex = [...this.msg].map((b2) => b2.toString(16).padStart(2, "0")).join("");
        }
        toArrayBuffer() {
          return this.msg.buffer.slice(0, this.msg.byteLength);
        }
        send() {
          if (Tools.window.ChatWebsocket) {
            try {
              Tools.window.ChatWebsocket.send(this);
            } catch (e) {
              logRecorder$3.error("发送自定义消息失败", e);
            }
            return;
          }
          if (this.msgObj.body.type === 3) {
            try {
              Tools.window.ChatWebsocketImage.send(this);
            } catch (e) {
              logRecorder$3.error("发送图片消息失败", e);
            }
            return;
          }
          if (Tools.window.GeekChatCore) {
            try {
              Tools.window.GeekChatCore.getInstance().getClient().client.send(this);
            } catch (e) {
              logRecorder$3.warn("发送自定义消息失败; boss可能更新了1，请反馈", e);
            }
            return;
          }
          logRecorder$3.warn("发送自定义消息失败; boss可能更新了，请反馈");
        }
      } exports("M", Message);
      class MessageRead {
        constructor({ userId, messageId }) {
          __publicField(this, "msg");
          __publicField(this, "hex");
          const r = (/* @__PURE__ */ new Date()).getTime();
          const data = {
            messageRead: [
              {
                messageId,
                readTime: r,
                userId,
                userSource: 0
              }
            ],
            type: 6
          };
          this.msg = protobufType.encode(data).finish().slice();
          this.hex = [...this.msg].map((b2) => b2.toString(16).padStart(2, "0")).join("");
        }
        toArrayBuffer() {
          return this.msg.buffer.slice(0, this.msg.byteLength);
        }
        send() {
          if (Tools.window.ChatWebsocket) {
            Tools.window.ChatWebsocket.send(this);
            return;
          }
          if (Tools.window.ChatWebsocketImage) {
            Tools.window.ChatWebsocketImage.send(this);
            return;
          }
        }
      }
      const pushResultCount = exports("bj", defineStore("pushResultCount", () => {
        const notMatchCount = ref(0);
        const successCount = ref(TampermonkeyApi.GmGetValue(TampermonkeyApi.PUSH_SUCCESS_COUNT, 0));
        const onceSuccessCount = ref(0);
        const failCount = ref(TampermonkeyApi.GmGetValue(TampermonkeyApi.PUSH_FAIL_COUNT, 0));
        function notMatchIncr() {
          notMatchCount.value++;
        }
        function successIncr() {
          successCount.value++;
          onceSuccessCount.value++;
          TampermonkeyApi.GmSetValue(TampermonkeyApi.PUSH_SUCCESS_COUNT, successCount.value);
        }
        function failIncr() {
          failCount.value++;
          TampermonkeyApi.GmSetValue(TampermonkeyApi.PUSH_FAIL_COUNT, failCount.value);
        }
        function clearOnceSuccessCount() {
          onceSuccessCount.value = 0;
        }
        return {
          notMatchIncr,
          successIncr,
          notMatchCount,
          successCount,
          failCount,
          failIncr,
          onceSuccessCount,
          clearOnceSuccessCount
        };
      }));
      const UserStore = exports("bk", defineStore("ai-user", () => {
        const platformType = ref();
        const user = reactive(getLocalUser());
        return {
          user,
          platformType
        };
      }));
      const LoginStore = exports("bi", defineStore("LoginStore", () => {
        const login = ref();
        const loginFailStatus = ref();
        function loginSuccess() {
          login.value = true;
        }
        function loginFail() {
          loginFailStatus.value = true;
        }
        return {
          login,
          loginSuccess,
          loginFailStatus,
          loginFail
        };
      }));
      function getLocalUser() {
        let jsonData = localStorage.getItem("ai-job-user");
        if (jsonData === null) {
          jsonData = '{"phone":"","email":"","preference":{},"preferenceMap":{}}';
        }
        let user = JSON.parse(jsonData);
        logger$1.debug("获取本地用户配置", user);
        return user;
      }
      const ProductStore = defineStore("ProductStore", () => {
        const showProduct = ref(false);
        function setShowProduct(show) {
          showProduct.value = show;
        }
        return {
          showProduct,
          setShowProduct
        };
      });
      var BizCodeEnum = /* @__PURE__ */ ((BizCodeEnum2) => {
        BizCodeEnum2[BizCodeEnum2["NOT_LOGIN"] = 401] = "NOT_LOGIN";
        BizCodeEnum2[BizCodeEnum2["PARAM_ERROR"] = 410] = "PARAM_ERROR";
        BizCodeEnum2[BizCodeEnum2["INTERNAL_SERVER_ERROR"] = 500] = "INTERNAL_SERVER_ERROR";
        BizCodeEnum2[BizCodeEnum2["USER_NOT_EXIST"] = 2e3] = "USER_NOT_EXIST";
        BizCodeEnum2[BizCodeEnum2["PROMOTION_CODE_EXPIRED"] = 2001] = "PROMOTION_CODE_EXPIRED";
        BizCodeEnum2[BizCodeEnum2["PRODUCT_NOT_AUTHORIZED"] = 5001] = "PRODUCT_NOT_AUTHORIZED";
        return BizCodeEnum2;
      })(BizCodeEnum || {});
      const request = exports("bE", axios.create({
        // 超时时间
        timeout: 1e4,
        // 格式为json数据；字符编码utf-8
        headers: {
          "Content-Type": "application/json; charset=utf-8"
        }
      }));
      {
        request.defaults.baseURL = "";
      }
      request.interceptors.request.use(
        (req) => {
          let authorization = localStorage.getItem("Authorization");
          if (authorization) {
            req.headers["Authorization"] = authorization;
          }
          return req;
        }
      );
      function handlerErrorCode(result) {
        if (!result || (result == null ? void 0 : result.code) < 5e3) {
          return;
        }
        if (result.code === BizCodeEnum.PRODUCT_NOT_AUTHORIZED) {
          const productStore = ProductStore();
          productStore.setShowProduct(true);
        }
      }
      request.interceptors.response.use(
        (resp) => {
          let result = resp.data;
          if (result.code === 200) {
            return resp;
          }
          if (result.code >= 2e3 && result.code < 5e3) {
            return resp;
          }
          if (result.code === 401) {
            let authorization = localStorage.getItem("Authorization");
            if (authorization) {
              ElMessage({
                type: "error",
                message: "登录过期，请刷新页面重试"
              });
              return;
            }
            return Promise.reject(result.message);
          }
          if (!result.code || result.code === 500 || result.code >= 5e3) {
            ElMessage({
              type: "error",
              message: result.message ? result.message : "系统异常"
            });
            handlerErrorCode(result);
          }
          return Promise.reject(result.message);
        },
        /**
         * 当
         * http的状态码不为200时
         * @param error
         */
        (error) => {
          if (error.code === "ECONNABORTED") {
            ElMessage({
              message: "网络超时",
              type: "error",
              grouping: true,
              duration: 2e3
            });
            return Promise.reject("time out");
          }
          if (error.code === "ERR_NETWORK") {
            ElMessage({
              message: "系统异常,请稍后重试",
              type: "error",
              grouping: true,
              duration: 2e3
            });
            return Promise.reject(() => {
            });
          }
          if (error.response.data) {
            error.message = error.response.data.message;
          }
          if (error.response.status === 404) {
            error.message = "资源未找到";
          }
          ElMessage({
            message: error.message,
            type: "error",
            grouping: true,
            duration: 3e3
          });
          return Promise.reject(error);
        }
      );
      const logRecorder$2 = new LogRecorder();
      let loginIng = false;
      const silentlyLogin = exports("bm", async (bossUserId) => {
        console.log("【本地模式】跳过远程登录");
        let loginStore = LoginStore();
        loginStore.loginSuccess(); // 强制标记登录状态
        return Promise.resolve();
      });
      const isProdEnv = exports("bn", () => {
        return true;
      });
      const ElMessage = exports("E", (options) => {
        if (options && options.message) {
          options.message = "[AI助理] " + options.message;
        }
        ElMessage$1(options);
      });
      async function fetchWithGM_request(url, options) {
        return new Promise((resolve, reject) => {
          _GM_xmlhttpRequest({
            method: options.method || "GET",
            url,
            headers: options.headers,
            responseType: options.responseType || "json",
            // 默认为json，根据需要修改
            data: options.data,
            onload: (response) => {
              if (response.status === 200) {
                resolve(response);
              } else {
                reject(new Error(`Request failed with status: ${response.status}`));
              }
            },
            onerror: () => {
              reject(new Error("Network error"));
            },
            ontimeout: () => {
              reject(new Error("Request timed out"));
            }
          });
        });
      }
      const loginInterceptor = exports("bs", () => {
        var _a2, _b;
        const token = (_b = (_a2 = Tools.window) == null ? void 0 : _a2._PAGE) == null ? void 0 : _b.token;
        if (!token) {
          ElMessage({
            message: "请先登录Boss",
            type: "error",
            duration: 3e3
          });
          return false;
        }
        return true;
      });
      const handlerImport = async (importResumeLoading) => {
        var _a2, _b, _c, _d;
        if (!loginInterceptor()) {
          return;
        }
        const token = (_b = (_a2 = Tools.window) == null ? void 0 : _a2._PAGE) == null ? void 0 : _b.token;
        let bossUserId = (_d = (_c = Tools.window) == null ? void 0 : _c._PAGE) == null ? void 0 : _d.uid;
        if (!bossUserId) {
          ElMessage({
            message: "未获取到Boss userId 请刷新页面重试",
            type: "error",
            duration: 3e3
          });
          return;
        }
        importResumeLoading.value = true;
        let resumeInfoResp = await axios.get("https://www.zhipin.com/wapi/zpgeek/resume/sidebar.json", { headers: { "Zp_token": token } });
        let zpData = resumeInfoResp.data.zpData;
        if (!zpData.attachmentList || zpData.attachmentList.length == 0) {
          importResumeLoading.value = false;
          ElMessage({
            message: "请先在BOSS个人中心上传附件简历；作为ai坐席定制化回复的基础",
            type: "error",
            duration: 3e3
          });
          return;
        }
        let resumeId = zpData.attachmentList[0].resumeId;
        let resumeFileResp = await fetchWithGM_request(
          "https://docdownload.zhipin.com/wflow/zpgeek/download/download4geek?resumeId=" + resumeId,
          { headers: { "Zp_token": token }, responseType: "arraybuffer" }
        );
        let fileBlob = new Blob([resumeFileResp.response], { type: "application/pdf" });
        let formData = new FormData();
        formData.append("file", fileBlob);
        formData.append("resumeId", resumeId);
        formData.append("uniqueId", bossUserId);
        let importResp = await request.post("/api/user/import/resume", formData, { headers: { "Content-Type": "multipart/form-data" } });
        if (importResp.data.code != 200) {
          ElMessage({
            message: "导入简历失败" + importResp.data.data.msg,
            type: "error",
            duration: 3e3
          });
          importResumeLoading.value = false;
          return;
        }
        let loginResp = await request.post("/api/user/silently/login?uniqueId=" + bossUserId);
        localStorage.setItem("Authorization", loginResp.data.data);
        if (!importResp.data.data.email) {
          importResumeLoading.value = false;
          return;
        }
        ElMessage({
          message: "导入简历成功",
          type: "success",
          duration: 3e3
        });
        importResumeLoading.value = false;
      };
      const logRecorder$1 = new LogRecorder();
    function userRemoteLoad() {
      logRecorder$1.info("【本地模式】开始加载本地偏好配置");
      const userStore2 = UserStore();
      const loginStore = LoginStore();

      // 1. 强制登录状态
      loginStore.loginSuccess();

      // 2. 从本地读取数据
      const localData = TampermonkeyApi.GmGetValue(TampermonkeyApi.LOCAL_CONFIG, null);

      if (localData) {
          userStore2.user = localData;
          logRecorder$1.info("【本地模式】偏好配置读取成功");
      } else {
          // 初始化默认结构
          userStore2.user = {
              phone: "LocalUser",
              email: "your_email@example.com",
              aiSeatStatus: 1,
              preference: {
                  pi: 3,
                  npi: 6,
                  dr: 0,
                  drE: false,
                  aiSeatStatus: 1
              }
          };
      }

      // 3. 补全默认值检查
      if (!userStore2.user.preference) userStore2.user.preference = {};
      const pref = userStore2.user.preference;
      pref.pi = pref.pi || 3;
      pref.npi = pref.npi || 6;
      pref.dr = pref.dr || 0;
    }
      // 在 __monkey.entry-C6x6oyrg.js 中替换原来的 AiPower 类
      class AiPower {
          static getLocalAIConfig() {
              return JSON.parse(localStorage.getItem('ai-job-config') || '{}');
          }

          static async ask(question, jobKey, bossUserInfo) {
              const aiConfig = this.getLocalAIConfig();
              const userStore = UserStore();
              
              if (!aiConfig.apiKey) {
                  ElMessage({ type: "error", message: "请先在【AI配置】中设置您的 API Key" });
                  return Promise.reject("No API Key");
              }

              // 构造系统提示词 (本地化核心：将你的简历信息塞进去)
              const systemPrompt = `你是一个求职助手。正在帮用户回复BOSS直聘上的HR。
              你的简历概要：${userStore.user.localResumeText || "暂无详细简历文本，请在偏好设置中补充"}。
              当前沟通职位：${bossUserInfo.jobTitle}。
              回复要求：语气礼貌、专业。尽量引导HR查看附件简历或面试。字数不要太多。`;

              return new Promise((resolve, reject) => {
                  GM_xmlhttpRequest({
                      method: "POST",
                      url: `${aiConfig.baseUrl.replace(/\/$/, "")}/chat/completions`,
                      headers: {
                          "Content-Type": "application/json",
                          "Authorization": `Bearer ${aiConfig.apiKey}`
                      },
                      timeout: (aiConfig.timeout || 60) * 1000,
                      data: JSON.stringify({
                          model: aiConfig.modelName || "deepseek-chat",
                          messages: [
                              { role: "system", content: systemPrompt },
                              { role: "user", content: question }
                          ],
                          temperature: 0.7
                      }),
                      onload: (res) => {
                          if (res.status !== 200) {
                              reject("API报错: " + res.responseText);
                              return;
                          }
                          const json = JSON.parse(res.responseText);
                          const answer = json.choices[0].message.content;
                          
                          // 模拟原脚本后端协议返回
                          resolve({
                              data: {
                                  code: 200,
                                  data: {
                                      answerContent: answer,
                                      answerTypeList: [1], // 1代表发送纯文本
                                      operationTypeList: []
                                  }
                              }
                          });
                      },
                      onerror: (err) => {
                          ElMessage({ type: "error", message: "AI调用失败，请检查网络或API Key" });
                          reject(err);
                      }
                  });
              });
          }

          static async filter(prompt, jobBaseInfo, jobExtInfo) {
              // 自动过滤逻辑：默认不拦截。如果需要可以像 ask 一样写一个简单的判定逻辑。
              return { data: { code: 200, data: { filter: false } } };
          }

          static async updateAskStatus() { 
              return { data: { code: 200, data: "Status Updated Locally" } }; 
          }
        }
      exports("A", AiPower);
      let pushResultCounter;
      let userStore$2;
      class AbsPlatform {
        constructor() {
          __publicField(this, "logRecorder", new LogRecorder("recorder"));
          __publicField(this, "pushStatus", PushStatus.NOT_START);
          __publicField(this, "_pushMock", false);
          __publicField(this, "_selfDefPushCountLimit", -1);
          __publicField(this, "next", async () => {
            let next = this.hasNext();
            if (!next) {
              this.logRecorder.info("无下一页数据");
              return false;
            }
            await Tools.sleep(userStore$2.user.preference.npi * 1e3);
            this.acquireDataPre();
            await Tools.sleep(3e3);
            return next;
          });
        }
        set pushMock(value) {
          this._pushMock = value;
        }
        set selfDefPushCountLimit(value) {
          this._selfDefPushCountLimit = value;
        }
        get selfDefPushCountLimit() {
          return this._selfDefPushCountLimit;
        }
        async startPush() {
          this.logRecorder.info("开始投递");
          pushResultCounter.clearOnceSuccessCount();
          this.pushStatus = PushStatus.PUSHING;
          this.startPreHandler();
          do {
            let jobList = this.getJobList();
            for (const jobDetail of jobList) {
              try {
                this.preMatchJob();
                await this.matchJob(jobDetail);
                this.pushPreHandler(jobDetail);
                const pushResult = await this.push(jobDetail);
                await this.pushAfterHandler(pushResult, jobDetail);
              } catch (error) {
                switch (true) {
                  case error instanceof NotMatchException:
                    if (this.logRecorder.getLogLevel() === LogLevel.Debug) {
                      this.logRecorder.info(`工作【${error.jobTitle}】被过滤 原因：${error.message} 当前值:${error.data}`);
                    } else {
                      this.logRecorder.info(`工作【${error.jobTitle}】被过滤 原因：${error.message}`);
                    }
                    pushResultCounter.notMatchIncr();
                    break;
                  case error instanceof PushReqException:
                    this.logRecorder.warn(`工作【${error.jobTitle}】投递失败 原因：${error.message}`);
                    pushResultCounter.failIncr();
                    break;
                  case error instanceof FetchJobBossFailExp:
                    this.logRecorder.warn(`工作【${error.jobTitle}】发送自定义招呼语失败 原因：${error.message}`);
                    break;
                  case error instanceof PublishStopExp:
                    this.logRecorder.info("手动暂停投递 " + error.message);
                    return;
                  case error instanceof PublishLimitExp:
                    this.logRecorder.info("停止投递 " + error.message);
                    return;
                  default:
                    logger$1.error("未捕获异常--->", error);
                }
              }
            }
          } while (await this.next());
          this.logRecorder.info("结束投递");
        }
        pausePush() {
        }
        preMatchJob() {
          if (this._selfDefPushCountLimit !== -1 && pushResultCounter.onceSuccessCount >= this._selfDefPushCountLimit) {
            throw new PublishLimitExp("自定义投递次数限制");
          }
          if (this.pushStatus == PushStatus.PAUSE) {
            throw new PublishStopExp("手动暂停投递");
          }
        }
        async push(jobDetail) {
          if (this.pushStatus == PushStatus.PAUSE) {
            throw new PublishStopExp("手动暂停投递");
          }
          if (this._selfDefPushCountLimit !== -1 && pushResultCounter.onceSuccessCount >= this._selfDefPushCountLimit) {
            throw new PublishLimitExp("自定义投递次数限制");
          }
          let limitResult = this.isLimit(jobDetail);
          if (limitResult.limit) {
            throw new PublishLimitExp(limitResult.msg);
          }
          if (this._pushMock) {
            let jobTitle = this.getJobKey(jobDetail);
            logger$1.debug("mock投递 ", jobTitle);
            return {
              message: "Success",
              code: 0
            };
          }
          return await this.doPush(jobDetail);
        }
        isLimit(jobDetail) {
          return {
            limit: false,
            msg: this.getJobKey(jobDetail)
          };
        }
        getFistJobDetail() {
          return this.getJobList()[0];
        }
      }
      class BossPlatform extends AbsPlatform {
        constructor(curUrl) {
          super();
          __publicField(this, "curUrl");
          __publicField(this, "name", "Boss");
          __publicField(this, "urlList", ["/web/geek", "overseas"]);
          __publicField(this, "lastHeight", 0);
          __publicField(this, "bossDataCache", /* @__PURE__ */ new Map());
          this.curUrl = curUrl;
        }
        getPlatformType() {
          return 0;
        }
        getMountEle() {
          return new Promise((resolve) => {
            let count = 0;
            let interval = setInterval(() => {
              let element = null;
              let p2 = "";
              if (this.curUrl.includes("www.zhipin.com/web/geek/chat")) {
                element = document.querySelector(".chat-conversation");
              }
              if (this.curUrl.includes("www.zhipin.com/web/geek/job-recommend")) {
                element = document.querySelector(".recommend-search-inner");
                p2 = "end";
              }
              if (this.curUrl.includes("www.zhipin.com/web/geek/jobs")) {
                element = document.querySelector(".job-recommend-result");
              } else if (this.curUrl.includes("www.zhipin.com/web/geek/job")) {
                element = document.querySelector(".page-job-inner");
              }
              if (this.curUrl.includes("overseas")) {
                element = document.querySelector(".mod-header");
              }
              if (element !== null) {
                clearInterval(interval);
                return resolve({
                  el: element,
                  p: p2
                });
              }
              if (count >= 3) {
                clearInterval(interval);
                logger$1.error(0, "获取平台挂载元素失败");
                return document.createElement("div");
              }
              count++;
            }, 300);
          });
        }
        async getRenderComponent() {
          if (this.curUrl.includes("www.zhipin.com/web/geek/chat")) {
            let promise = __vitePreload(() => module.import('./BossMessage-DBY0bJNw-D01KK3Xs.js'), void 0 );
            return promise.then((item) => item.default);
          }
          if (this.curUrl.includes("www.zhipin.com/web/geek/job") || this.curUrl.includes("overseas")) {
            let promise = __vitePreload(() => module.import('./BossJobList-BZPvSyMi-DM5PALTb.js'), void 0 );
            return promise.then((item) => item.default);
          }
        }
        startPreHandler() {
          this.lastHeight = 0;
        }
        getJobList() {
          if (this.curUrl.includes("jobs")) {
            let elementNodeList2 = document.querySelectorAll(".job-card-wrap");
            let jobList = Array.from(elementNodeList2).map((item) => item.__vue__.data).filter((job) => !job.processed);
            if (elementNodeList2.length != 0 && jobList.length == 0) {
              this.logRecorder.info("当前筛选条件下岗位均已投递");
            }
            return jobList;
          }
          if (this.curUrl.includes("job-recommend")) {
            let elementNodeList2 = document.querySelectorAll(".job-card-wrap");
            return Array.from(elementNodeList2).map((item) => item.__vue__.data).filter((job) => !job.contact);
          }
          if (this.curUrl.includes("overseas")) {
            let elementNodeList2 = document.querySelectorAll(".job-card-box");
            return Array.from(elementNodeList2).map((item) => item.__vue__.data).filter((job) => !job.contact);
          }
          let elementNodeList = document.querySelectorAll(".job-card-wrapper");
          return Array.from(elementNodeList).map((item) => item.__vue__.data);
        }
        hasNext() {
          var _a2, _b;
          logger$1.debug("hasNext");
          if (this.curUrl.includes("jobs")) {
            return this.lastHeight != ((_a2 = document.querySelector(".job-list-container")) == null ? void 0 : _a2.scrollHeight);
          }
          if (this.curUrl.includes("overseas")) {
            return this.lastHeight != ((_b = document.querySelector(".job-list")) == null ? void 0 : _b.scrollHeight);
          }
          if (this.curUrl.includes("job-recommend")) {
            return !!document.querySelector("#footer");
          }
          let nextPageBtn = document.querySelector(".ui-icon-arrow-right");
          if (nextPageBtn === null) {
            return false;
          }
          return nextPageBtn.parentElement.className !== "disabled";
        }
        acquireDataPre() {
          var _a2, _b;
          if (this.pushStatus == PushStatus.PAUSE) {
            return;
          }
          if (this.curUrl.includes("jobs")) {
            this.lastHeight = (_a2 = document.querySelector(".job-list-container")) == null ? void 0 : _a2.scrollHeight;
            simulateScrollToEnd().then(() => {
              logger$1.info("获取下一页成功");
            }).catch((e) => {
              this.logRecorder.warn("获取下一页失败", e);
            });
            return;
          } else if (this.curUrl.includes("job-recommend")) {
            simulateScrollToEnd().then(() => {
              logger$1.info("获取下一页成功");
            }).catch((e) => {
              this.logRecorder.warn("获取下一页失败", e);
            });
            return;
          } else if (this.curUrl.includes("overseas")) {
            this.lastHeight = (_b = document.querySelector(".job-list")) == null ? void 0 : _b.scrollHeight;
            simulateScrollToEnd().then(() => {
              logger$1.info("获取下一页成功");
            }).catch((e) => {
              this.logRecorder.warn("获取下一页失败", e);
            });
            return;
          }
          document.querySelector(".ui-icon-arrow-right").click();
        }
        async matchJob(jobDetail) {
          var _a2;
          jobDetail.processed = true;
          const jobTitle = this.getJobKey(jobDetail);
          if (jobDetail.contact) {
            throw new NotMatchException(jobTitle, jobDetail.contact, "已经沟通过");
          }
          if (userStore$2.user.preference.fhE && jobDetail.goldHunter === 1) {
            throw new NotMatchException(jobTitle, jobDetail.goldHunter, "过滤猎头");
          }
          if (userStore$2.user.preference.polE && !jobDetail.bossOnline) {
            throw new NotMatchException(jobTitle, jobDetail.bossOnline, "仅投递在线boss");
          }
          let companyNameInclude = userStore$2.user.preference.cni;
          if (userStore$2.user.preference.cniE && !Tools.fuzzyMatch(companyNameInclude, jobDetail.brandName, true)) {
            throw new NotMatchException(jobTitle, jobDetail.brandName, "不满足配置公司名");
          }
          let companyNameExclude = userStore$2.user.preference.cne;
          if (userStore$2.user.preference.cneE && Tools.fuzzyMatch(companyNameExclude, jobDetail.brandName, false)) {
            throw new NotMatchException(jobTitle, jobDetail.brandName, "满足排除公司名");
          }
          let jobNameInclude = userStore$2.user.preference.jni;
          if (userStore$2.user.preference.jniE && !Tools.fuzzyMatch(jobNameInclude, jobDetail.jobName, true)) {
            throw new NotMatchException(jobTitle, jobDetail.jobName, "不满足配置工作名");
          }
          let jobNameExclude = userStore$2.user.preference.jne;
          if (userStore$2.user.preference.jneE && Tools.fuzzyMatch(jobNameExclude, jobDetail.jobName, false)) {
            throw new NotMatchException(jobTitle, jobDetail.jobName, "满足排除工作名");
          }
          let pageSalaryRange = jobDetail.salaryDesc.split(".")[0];
          if (userStore$2.user.preference.srE && !Tools.isRangeOverlap(userStore$2.user.preference.sr, pageSalaryRange)) {
            throw new NotMatchException(jobTitle, pageSalaryRange, "不满足薪资范围");
          }
          let pageCompanyScaleRange = userStore$2.user.preference.csr;
          if (userStore$2.user.preference.csrE && !Tools.isRangeOverlap(pageCompanyScaleRange, jobDetail.brandScaleName)) {
            throw new NotMatchException(jobTitle, jobDetail.brandScaleName, "不满足公司规模范围");
          }
          let jobDetailExt = await this.obtainBossJobDetailExt(jobDetail);
          logger$1.debug(`获取工作【${jobTitle}】详情扩展信息用于过滤 `, jobDetail);
          let activeTimeDesc = jobDetailExt.activeTimeDesc;
          if (!this.bossIsActive(activeTimeDesc)) {
            throw new NotMatchException(jobTitle, activeTimeDesc, "不满足活跃度检查");
          }
          let jobContent = jobDetailExt.postDescription;
          let jobContentExclude = userStore$2.user.preference.jce;
          if (userStore$2.user.preference.jceE && Tools.fuzzyMatch(jobContentExclude, jobContent, false)) {
            throw new NotMatchException(jobTitle, jobContent, "满足排除工作内容");
          }
          let jobContentInclude = userStore$2.user.preference.jci;
          if (userStore$2.user.preference.jciE && !Tools.fuzzyMatch(jobContentInclude, jobContent, true)) {
            throw new NotMatchException(jobTitle, jobContent, "不满足工作内容");
          }
          if (userStore$2.user.preference.afE && userStore$2.user.preference.af) {
            let filterResp = await AiPower.filter(userStore$2.user.preference.af, JSON.stringify(this.unpackBaseInfo(jobDetail)), JSON.stringify(this.unpackExtInfo(jobDetailExt)));
            let filterResult = filterResp ? (_a2 = filterResp == null ? void 0 : filterResp.data) == null ? void 0 : _a2.data : null;
            if (filterResult && (filterResult == null ? void 0 : filterResult.filter)) {
              throw new NotMatchException(jobTitle, filterResult.reason, "AI过滤");
            }
          }
          if (this.isCommunication(jobDetailExt)) {
            throw new NotMatchException(jobTitle, jobDetailExt.friendStatus, "已经沟通过");
          }
          return true;
        }
        unpackBaseInfo(jobDetail) {
          return {
            jobName: jobDetail.jobName,
            salaryDesc: jobDetail.salaryDesc,
            jobLabels: jobDetail.jobLabels,
            skills: jobDetail.skills,
            jobExperience: jobDetail.jobExperience,
            jobDegree: jobDetail.jobDegree,
            cityName: jobDetail.cityName,
            areaDistrict: jobDetail.areaDistrict,
            businessDistrict: jobDetail.businessDistrict,
            brandName: jobDetail.brandName,
            brandStageName: jobDetail.brandStageName,
            brandIndustry: jobDetail.brandIndustry,
            brandScaleName: jobDetail.brandScaleName,
            welfareList: jobDetail.welfareList
          };
        }
        unpackExtInfo(jobDetailExt) {
          return {
            postDescription: jobDetailExt.postDescription,
            address: jobDetailExt.address,
            activeTimeDesc: jobDetailExt.activeTimeDesc
          };
        }
        pausePush() {
          this.pushStatus = PushStatus.PAUSE;
        }
        getJobKey(jobDetail) {
          return jobDetail.jobName + "-" + jobDetail.cityName + jobDetail.areaDistrict + jobDetail.businessDistrict;
        }
        isLimit(jobDetail) {
          return {
            limit: TampermonkeyApi.GmGetValue(TampermonkeyApi.PUSH_LIMIT, false),
            msg: "Boss投递限制每天100次"
          };
        }
        async doPush(jobDetail, errorMsg = "", retries = 3) {
          var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
          const jobTitle = this.getJobKey(jobDetail);
          if (retries === 3) {
            logger$1.debug("正在投递：" + jobTitle);
          }
          if (retries === 0) {
            throw new PushReqException(jobTitle, errorMsg);
          }
          let publishUrl = `https://www.zhipin.com/wapi/zpgeek/friend/add.json?securityId=${jobDetail.securityId}&jobId=${jobDetail.encryptJobId}&lid=${jobDetail.lid}`;
          let pushResp = { code: PushResultStatus.NOT_START, message: "" };
          try {
            await Tools.sleep(userStore$2.user.preference.pi * 1e3);
            pushResp = await axios.post(publishUrl, null, { headers: { "Zp_token": Tools.getCookieValue("bst") } });
          } catch (error) {
            logger$1.debug(`工作【${jobTitle}】投递失败; 正在等待重试; 原因：${error.message}`);
            await Tools.sleep(800);
            return await this.doPush(jobDetail, error.message, retries - 1);
          }
          if (pushResp.data.code === PushResultStatus.FAIL && ((_d = (_c = (_b = (_a2 = pushResp.data) == null ? void 0 : _a2.zpData) == null ? void 0 : _b.bizData) == null ? void 0 : _c.chatRemindDialog) == null ? void 0 : _d.content)) {
            if ((_h = (_g = (_f = (_e = pushResp.data) == null ? void 0 : _e.zpData) == null ? void 0 : _f.bizData) == null ? void 0 : _g.chatRemindDialog) == null ? void 0 : _h.content.include("您今天已与120位BOSS沟通")) {
              logger$1.debug(`当天已投递超过120次 工作【${jobTitle}】已修正为投递成功`);
              return {
                code: PushResultStatus.SUCCESS,
                message: "Success"
              };
            }
            return {
              code: 1,
              message: (_l = (_k = (_j = (_i = pushResp.data) == null ? void 0 : _i.zpData) == null ? void 0 : _j.bizData) == null ? void 0 : _k.chatRemindDialog) == null ? void 0 : _l.content
            };
          }
          await Tools.sleep(800);
          return pushResp.data;
        }
        async requestBossDataByCache(jobDetail) {
          let cacheKey = `${jobDetail.encryptBossId}-${jobDetail.securityId}`;
          if (this.bossDataCache.has(cacheKey)) {
            return this.bossDataCache.get(cacheKey);
          }
          const result = await this.requestBossData(jobDetail);
          this.bossDataCache.set(cacheKey, result);
          return result;
        }
        async requestBossData(jobDetail, errorMsg = "", retries = 3) {
          let jobTitle = this.getJobKey(jobDetail);
          if (retries === 0) {
            throw new FetchJobBossFailExp(jobTitle, errorMsg || "获取boss数据重试多次失败");
          }
          const url = "https://www.zhipin.com/wapi/zpchat/geek/getBossData";
          const token = Tools.getCookieValue("bst");
          if (!token) {
            throw new FetchJobBossFailExp(jobTitle, "未获取到zp-token");
          }
          const data = new FormData();
          data.append("bossId", jobDetail.encryptBossId);
          data.append("securityId", jobDetail.securityId);
          data.append("bossSrc", "0");
          let resp;
          try {
            resp = await axios({ url, data, method: "POST", headers: { Zp_token: token } });
          } catch (e) {
            return this.requestBossData(jobDetail, e.message, retries - 1);
          }
          if (resp.data.code !== 0) {
            throw new FetchJobBossFailExp(jobTitle, resp.data.message);
          }
          return resp.data.zpData;
        }
        async pushAfterHandler(pushResult, jobDetail) {
          const jobTitle = this.getJobKey(jobDetail);
          if (pushResult.message === "Success" && pushResult.code === 0) {
            pushResultCounter.successIncr();
            this.logRecorder.info(`工作【${jobTitle}】 投递成功`);
            try {
              await this.pushAfterSendImage(jobDetail);
            } catch (e) {
            }
            try {
              await this.pushAfterSendMsg(jobDetail);
            } catch (e) {
            }
            jobDetail.contact = true;
            return jobDetail;
          }
          if (pushResult.message.includes("今日沟通人数已达上限")) {
            throw new PublishLimitExp(pushResult.message);
          }
          throw new PushReqException(jobTitle, pushResult.message);
        }
        /**
         * 投递后发送自定义消息
         */
        async pushAfterSendMsg(jobDetail) {
          if (!userStore$2.user.preference.cgE || this._pushMock) {
            return;
          }
          let bossData = await this.requestBossDataByCache(jobDetail);
          let customGreeting = userStore$2.user.preference.cg;
          let message = new Message({
            form_uid: Tools.window._PAGE.uid.toString(),
            to_uid: bossData.data.bossId.toString(),
            to_name: jobDetail.encryptBossId,
            content: customGreeting,
            image: void 0
          });
          message.send();
        }
        /**
         * 投递后发送自定义图片
         */
        async pushAfterSendImage(jobDetail) {
          if (!userStore$2.user.preference.cIE || this._pushMock) {
            return;
          }
          let bossData = await this.requestBossDataByCache(jobDetail);
          let customerImageSet = userStore$2.user.preference.cI;
          if (!customerImageSet) {
            return;
          }
          let message = new Message({
            form_uid: Tools.window._PAGE.uid.toString(),
            to_uid: bossData.data.bossId.toString(),
            to_name: jobDetail.encryptBossId,
            content: "",
            image: {
              originImage: customerImageSet.split("===")[0],
              tinyImage: customerImageSet.split("===")[1]
            }
          });
          message.send();
        }
        pushPreHandler(jobDetail) {
          return jobDetail;
        }
        async obtainBossJobDetailExt(jobDetail, message = "", retries = 3) {
          if (retries === 0) {
            logger$1.warn(`获取工作详情扩展信息异常,用于活跃度过滤以及工作内容过滤; 原因：${message}`);
            throw new NotMatchException(this.getJobKey(jobDetail), message, "获取工作详情扩展信息异常");
          }
          let params = `lid=${jobDetail.lid}&securityId=${jobDetail.securityId}&sessionId=`;
          try {
            let resp = await axios.get("https://www.zhipin.com/wapi/zpgeek/job/card.json?" + params, { timeout: 5e3 });
            return resp.data.zpData.jobCard;
          } catch (error) {
            logger$1.debug("获取详情页异常正在重试:", error);
            return this.obtainBossJobDetailExt(jobDetail, error.message, retries - 1);
          }
        }
        bossIsActive(activeText) {
          return !(activeText.includes("月") || activeText.includes("年") || activeText.includes("周"));
        }
        isCommunication(jobCardJson) {
          return (jobCardJson == null ? void 0 : jobCardJson.friendStatus) === 1;
        }
      }
      const platformList = [BossPlatform];
      class PlatformFactory {
        static getInstance(url) {
          for (const PlatformClass of platformList) {
            const platformInstance = new PlatformClass(url);
            if (platformInstance.urlList.some((platformUrl) => url.includes(platformUrl))) {
              pushResultCounter = pushResultCount();
              userStore$2 = UserStore();
              userStore$2.platformType = platformInstance.getPlatformType();
              userRemoteLoad();
              return platformInstance;
            }
          }
          throw new PlatformError(2, "错误的平台");
        }
      }
      const _sfc_main$x = /* @__PURE__ */ defineComponent({
        __name: "ViewRouter",
        setup(__props) {
          const platform2 = inject("$platform");
          const renderComponent = shallowRef(null);
          platform2.getRenderComponent().then((data) => {
            renderComponent.value = data;
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(renderComponent.value));
          };
        }
      });
      const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
        const handleEvent = (event) => {
          const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
          if (checkForDefaultPrevented === false || !shouldPrevent) {
            return oursHandler == null ? void 0 : oursHandler(event);
          }
        };
        return handleEvent;
      };
      var _a;
      const isClient = exports("aJ", typeof window !== "undefined");
      const isDef = (val) => typeof val !== "undefined";
      const isFunction$2 = (val) => typeof val === "function";
      const isString$1 = (val) => typeof val === "string";
      const noop = () => {
      };
      const isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
      function resolveUnref(r) {
        return typeof r === "function" ? r() : unref(r);
      }
      function createFilterWrapper(filter3, fn2) {
        function wrapper(...args) {
          return new Promise((resolve, reject) => {
            Promise.resolve(filter3(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args })).then(resolve).catch(reject);
          });
        }
        return wrapper;
      }
      function debounceFilter(ms, options = {}) {
        let timer;
        let maxTimer;
        let lastRejector = noop;
        const _clearTimeout = (timer2) => {
          clearTimeout(timer2);
          lastRejector();
          lastRejector = noop;
        };
        const filter3 = (invoke) => {
          const duration = resolveUnref(ms);
          const maxDuration = resolveUnref(options.maxWait);
          if (timer)
            _clearTimeout(timer);
          if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
            if (maxTimer) {
              _clearTimeout(maxTimer);
              maxTimer = null;
            }
            return Promise.resolve(invoke());
          }
          return new Promise((resolve, reject) => {
            lastRejector = options.rejectOnCancel ? reject : resolve;
            if (maxDuration && !maxTimer) {
              maxTimer = setTimeout(() => {
                if (timer)
                  _clearTimeout(timer);
                maxTimer = null;
                resolve(invoke());
              }, maxDuration);
            }
            timer = setTimeout(() => {
              if (maxTimer)
                _clearTimeout(maxTimer);
              maxTimer = null;
              resolve(invoke());
            }, duration);
          });
        };
        return filter3;
      }
      function throttleFilter(ms, trailing = true, leading = true, rejectOnCancel = false) {
        let lastExec = 0;
        let timer;
        let isLeading = true;
        let lastRejector = noop;
        let lastValue;
        const clear = () => {
          if (timer) {
            clearTimeout(timer);
            timer = void 0;
            lastRejector();
            lastRejector = noop;
          }
        };
        const filter3 = (_invoke) => {
          const duration = resolveUnref(ms);
          const elapsed = Date.now() - lastExec;
          const invoke = () => {
            return lastValue = _invoke();
          };
          clear();
          if (duration <= 0) {
            lastExec = Date.now();
            return invoke();
          }
          if (elapsed > duration && (leading || !isLeading)) {
            lastExec = Date.now();
            invoke();
          } else if (trailing) {
            lastValue = new Promise((resolve, reject) => {
              lastRejector = rejectOnCancel ? reject : resolve;
              timer = setTimeout(() => {
                lastExec = Date.now();
                isLeading = true;
                resolve(invoke());
                clear();
              }, Math.max(0, duration - elapsed));
            });
          }
          if (!leading && !timer)
            timer = setTimeout(() => isLeading = true, duration);
          isLeading = false;
          return lastValue;
        };
        return filter3;
      }
      function identity$1(arg) {
        return arg;
      }
      function tryOnScopeDispose(fn2) {
        if (getCurrentScope()) {
          onScopeDispose(fn2);
          return true;
        }
        return false;
      }
      function useDebounceFn(fn2, ms = 200, options = {}) {
        return createFilterWrapper(debounceFilter(ms, options), fn2);
      }
      function refDebounced(value, ms = 200, options = {}) {
        const debounced = ref(value.value);
        const updater = useDebounceFn(() => {
          debounced.value = value.value;
        }, ms, options);
        watch(value, () => updater());
        return debounced;
      }
      function useThrottleFn(fn2, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {
        return createFilterWrapper(throttleFilter(ms, trailing, leading, rejectOnCancel), fn2);
      }
      function tryOnMounted(fn2, sync = true) {
        if (getCurrentInstance())
          onMounted(fn2);
        else if (sync)
          fn2();
        else
          nextTick(fn2);
      }
      function useTimeoutFn(cb, interval, options = {}) {
        const {
          immediate = true
        } = options;
        const isPending = ref(false);
        let timer = null;
        function clear() {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        }
        function stop() {
          isPending.value = false;
          clear();
        }
        function start(...args) {
          clear();
          isPending.value = true;
          timer = setTimeout(() => {
            isPending.value = false;
            timer = null;
            cb(...args);
          }, resolveUnref(interval));
        }
        if (immediate) {
          isPending.value = true;
          if (isClient)
            start();
        }
        tryOnScopeDispose(stop);
        return {
          isPending: readonly(isPending),
          start,
          stop
        };
      }
      function unrefElement(elRef) {
        var _a2;
        const plain = resolveUnref(elRef);
        return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
      }
      const defaultWindow = isClient ? window : void 0;
      function useEventListener(...args) {
        let target;
        let events;
        let listeners;
        let options;
        if (isString$1(args[0]) || Array.isArray(args[0])) {
          [events, listeners, options] = args;
          target = defaultWindow;
        } else {
          [target, events, listeners, options] = args;
        }
        if (!target)
          return noop;
        if (!Array.isArray(events))
          events = [events];
        if (!Array.isArray(listeners))
          listeners = [listeners];
        const cleanups = [];
        const cleanup = () => {
          cleanups.forEach((fn2) => fn2());
          cleanups.length = 0;
        };
        const register = (el, event, listener, options2) => {
          el.addEventListener(event, listener, options2);
          return () => el.removeEventListener(event, listener, options2);
        };
        const stopWatch = watch(() => [unrefElement(target), resolveUnref(options)], ([el, options2]) => {
          cleanup();
          if (!el)
            return;
          cleanups.push(...events.flatMap((event) => {
            return listeners.map((listener) => register(el, event, listener, options2));
          }));
        }, { immediate: true, flush: "post" });
        const stop = () => {
          stopWatch();
          cleanup();
        };
        tryOnScopeDispose(stop);
        return stop;
      }
      let _iOSWorkaround = false;
      function onClickOutside(target, handler, options = {}) {
        const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;
        if (!window2)
          return;
        if (isIOS && !_iOSWorkaround) {
          _iOSWorkaround = true;
          Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop));
        }
        let shouldListen = true;
        const shouldIgnore = (event) => {
          return ignore.some((target2) => {
            if (typeof target2 === "string") {
              return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
            } else {
              const el = unrefElement(target2);
              return el && (event.target === el || event.composedPath().includes(el));
            }
          });
        };
        const listener = (event) => {
          const el = unrefElement(target);
          if (!el || el === event.target || event.composedPath().includes(el))
            return;
          if (event.detail === 0)
            shouldListen = !shouldIgnore(event);
          if (!shouldListen) {
            shouldListen = true;
            return;
          }
          handler(event);
        };
        const cleanup = [
          useEventListener(window2, "click", listener, { passive: true, capture }),
          useEventListener(window2, "pointerdown", (e) => {
            const el = unrefElement(target);
            if (el)
              shouldListen = !e.composedPath().includes(el) && !shouldIgnore(e);
          }, { passive: true }),
          detectIframe && useEventListener(window2, "blur", (event) => {
            var _a2;
            const el = unrefElement(target);
            if (((_a2 = window2.document.activeElement) == null ? void 0 : _a2.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement)))
              handler(event);
          })
        ].filter(Boolean);
        const stop = () => cleanup.forEach((fn2) => fn2());
        return stop;
      }
      function useSupported(callback, sync = false) {
        const isSupported = ref();
        const update = () => isSupported.value = Boolean(callback());
        update();
        tryOnMounted(update, sync);
        return isSupported;
      }
      function cloneFnJSON(source) {
        return JSON.parse(JSON.stringify(source));
      }
      const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      const globalKey = "__vueuse_ssr_handlers__";
      _global[globalKey] = _global[globalKey] || {};
      var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
      var __hasOwnProp$g = Object.prototype.hasOwnProperty;
      var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
      var __objRest$2 = (source, exclude) => {
        var target = {};
        for (var prop in source)
          if (__hasOwnProp$g.call(source, prop) && exclude.indexOf(prop) < 0)
            target[prop] = source[prop];
        if (source != null && __getOwnPropSymbols$g)
          for (var prop of __getOwnPropSymbols$g(source)) {
            if (exclude.indexOf(prop) < 0 && __propIsEnum$g.call(source, prop))
              target[prop] = source[prop];
          }
        return target;
      };
      function useResizeObserver(target, callback, options = {}) {
        const _a2 = options, { window: window2 = defaultWindow } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
        let observer;
        const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
        const cleanup = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const stopWatch = watch(() => unrefElement(target), (el) => {
          cleanup();
          if (isSupported.value && window2 && el) {
            observer = new ResizeObserver(callback);
            observer.observe(el, observerOptions);
          }
        }, { immediate: true, flush: "post" });
        const stop = () => {
          cleanup();
          stopWatch();
        };
        tryOnScopeDispose(stop);
        return {
          isSupported,
          stop
        };
      }
      var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
      var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
      var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
      var __objRest$1 = (source, exclude) => {
        var target = {};
        for (var prop in source)
          if (__hasOwnProp$8.call(source, prop) && exclude.indexOf(prop) < 0)
            target[prop] = source[prop];
        if (source != null && __getOwnPropSymbols$8)
          for (var prop of __getOwnPropSymbols$8(source)) {
            if (exclude.indexOf(prop) < 0 && __propIsEnum$8.call(source, prop))
              target[prop] = source[prop];
          }
        return target;
      };
      function useMutationObserver(target, callback, options = {}) {
        const _a2 = options, { window: window2 = defaultWindow } = _a2, mutationOptions = __objRest$1(_a2, ["window"]);
        let observer;
        const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
        const cleanup = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const stopWatch = watch(() => unrefElement(target), (el) => {
          cleanup();
          if (isSupported.value && window2 && el) {
            observer = new MutationObserver(callback);
            observer.observe(el, mutationOptions);
          }
        }, { immediate: true });
        const stop = () => {
          cleanup();
          stopWatch();
        };
        tryOnScopeDispose(stop);
        return {
          isSupported,
          stop
        };
      }
      var SwipeDirection;
      (function(SwipeDirection2) {
        SwipeDirection2["UP"] = "UP";
        SwipeDirection2["RIGHT"] = "RIGHT";
        SwipeDirection2["DOWN"] = "DOWN";
        SwipeDirection2["LEFT"] = "LEFT";
        SwipeDirection2["NONE"] = "NONE";
      })(SwipeDirection || (SwipeDirection = {}));
      var __defProp = Object.defineProperty;
      var __getOwnPropSymbols = Object.getOwnPropertySymbols;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __propIsEnum = Object.prototype.propertyIsEnumerable;
      var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues = (a2, b2) => {
        for (var prop in b2 || (b2 = {}))
          if (__hasOwnProp.call(b2, prop))
            __defNormalProp(a2, prop, b2[prop]);
        if (__getOwnPropSymbols)
          for (var prop of __getOwnPropSymbols(b2)) {
            if (__propIsEnum.call(b2, prop))
              __defNormalProp(a2, prop, b2[prop]);
          }
        return a2;
      };
      const _TransitionPresets = {
        easeInSine: [0.12, 0, 0.39, 0],
        easeOutSine: [0.61, 1, 0.88, 1],
        easeInOutSine: [0.37, 0, 0.63, 1],
        easeInQuad: [0.11, 0, 0.5, 0],
        easeOutQuad: [0.5, 1, 0.89, 1],
        easeInOutQuad: [0.45, 0, 0.55, 1],
        easeInCubic: [0.32, 0, 0.67, 0],
        easeOutCubic: [0.33, 1, 0.68, 1],
        easeInOutCubic: [0.65, 0, 0.35, 1],
        easeInQuart: [0.5, 0, 0.75, 0],
        easeOutQuart: [0.25, 1, 0.5, 1],
        easeInOutQuart: [0.76, 0, 0.24, 1],
        easeInQuint: [0.64, 0, 0.78, 0],
        easeOutQuint: [0.22, 1, 0.36, 1],
        easeInOutQuint: [0.83, 0, 0.17, 1],
        easeInExpo: [0.7, 0, 0.84, 0],
        easeOutExpo: [0.16, 1, 0.3, 1],
        easeInOutExpo: [0.87, 0, 0.13, 1],
        easeInCirc: [0.55, 0, 1, 0.45],
        easeOutCirc: [0, 0.55, 0.45, 1],
        easeInOutCirc: [0.85, 0, 0.15, 1],
        easeInBack: [0.36, 0, 0.66, -0.56],
        easeOutBack: [0.34, 1.56, 0.64, 1],
        easeInOutBack: [0.68, -0.6, 0.32, 1.6]
      };
      __spreadValues({
        linear: identity$1
      }, _TransitionPresets);
      function useVModel(props, key, emit, options = {}) {
        var _a2, _b, _c;
        const {
          clone = false,
          passive = false,
          eventName,
          deep = false,
          defaultValue
        } = options;
        const vm = getCurrentInstance();
        const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a2 = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a2.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
        let event = eventName;
        if (!key) {
          {
            key = "modelValue";
          }
        }
        event = eventName || event || `update:${key.toString()}`;
        const cloneFn = (val) => !clone ? val : isFunction$2(clone) ? clone(val) : cloneFnJSON(val);
        const getValue2 = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;
        if (passive) {
          const initialValue = getValue2();
          const proxy = ref(initialValue);
          watch(() => props[key], (v2) => proxy.value = cloneFn(v2));
          watch(proxy, (v2) => {
            if (v2 !== props[key] || deep)
              _emit(event, v2);
          }, { deep });
          return proxy;
        } else {
          return computed$1({
            get() {
              return getValue2();
            },
            set(value) {
              _emit(event, value);
            }
          });
        }
      }
      const isFirefox = () => isClient && /firefox/i.test(window.navigator.userAgent);
      const isInContainer = (el, container) => {
        if (!isClient || !el || !container)
          return false;
        const elRect = el.getBoundingClientRect();
        let containerRect;
        if (container instanceof Element) {
          containerRect = container.getBoundingClientRect();
        } else {
          containerRect = {
            top: 0,
            right: window.innerWidth,
            bottom: window.innerHeight,
            left: 0
          };
        }
        return elRect.top < containerRect.bottom && elRect.bottom > containerRect.top && elRect.right > containerRect.left && elRect.left < containerRect.right;
      };
      /**
      * @vue/shared v3.4.21
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      const NOOP = exports("ar", () => {
      });
      const hasOwnProperty$c = Object.prototype.hasOwnProperty;
      const hasOwn = (val, key) => hasOwnProperty$c.call(val, key);
      const isArray$1 = exports("I", Array.isArray);
      const isDate = exports("aY", (val) => toTypeString(val) === "[object Date]");
      const isFunction$1 = exports("g", (val) => typeof val === "function");
      const isString = exports("x", (val) => typeof val === "string");
      const isSymbol$1 = (val) => typeof val === "symbol";
      const isObject$1 = exports("U", (val) => val !== null && typeof val === "object");
      const isPromise = exports("aM", (val) => {
        return (isObject$1(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
      });
      const objectToString$1 = Object.prototype.toString;
      const toTypeString = (value) => objectToString$1.call(value);
      const toRawType = exports("aK", (value) => {
        return toTypeString(value).slice(8, -1);
      });
      const isPlainObject$1 = exports("aN", (val) => toTypeString(val) === "[object Object]");
      const cacheStringFunction = (fn2) => {
        const cache = /* @__PURE__ */ Object.create(null);
        return (str2) => {
          const hit = cache[str2];
          return hit || (cache[str2] = fn2(str2));
        };
      };
      const camelizeRE = /-(\w)/g;
      const camelize = cacheStringFunction((str2) => {
        return str2.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
      });
      const hyphenateRE = /\B([A-Z])/g;
      const hyphenate = exports("bG", cacheStringFunction(
        (str2) => str2.replace(hyphenateRE, "-$1").toLowerCase()
      ));
      const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var Symbol$1 = exports("S", root.Symbol);
      var objectProto$e = Object.prototype;
      var hasOwnProperty$b = objectProto$e.hasOwnProperty;
      var nativeObjectToString$1 = objectProto$e.toString;
      var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
        try {
          value[symToStringTag$1] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString$1.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag$1] = tag;
          } else {
            delete value[symToStringTag$1];
          }
        }
        return result;
      }
      var objectProto$d = Object.prototype;
      var nativeObjectToString = objectProto$d.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var symbolTag$1 = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      var isArray = exports("av", Array.isArray);
      var INFINITY$1 = 1 / 0;
      var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
      }
      var reWhitespace = /\s/;
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var reTrimStart = /^\s+/;
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      var NAN = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function identity(value) {
        return value;
      }
      var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      var coreJsData = root["__core-js_shared__"];
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var funcProto$2 = Function.prototype;
      var funcToString$2 = funcProto$2.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString$2.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto$1 = Function.prototype, objectProto$c = Object.prototype;
      var funcToString$1 = funcProto$1.toString;
      var hasOwnProperty$a = objectProto$c.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      var WeakMap = getNative(root, "WeakMap");
      var objectCreate = Object.create;
      var baseCreate = /* @__PURE__ */ function() {
        function object() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result = new object();
          object.prototype = void 0;
          return result;
        };
      }();
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var nativeNow = Date.now;
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      const baseSetToString$1 = baseSetToString;
      var setToString = shortOut(baseSetToString$1);
      var MAX_SAFE_INTEGER$1 = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER$1 : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var objectProto$b = Object.prototype;
      var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty$9.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      var nativeMax$1 = Math.max;
      function overRest(func, start, transform) {
        start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax$1(args.length - start, 0), array = Array(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform(array);
          return apply(func, this, otherArgs);
        };
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? void 0 : customizer;
            length = 1;
          }
          object = Object(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      var objectProto$a = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
        return value === proto;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      var argsTag$2 = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag$2;
      }
      var objectProto$9 = Object.prototype;
      var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
      var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
      var isArguments = baseIsArguments(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty$8.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
      };
      function stubFalse() {
        return false;
      }
      var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
      var Buffer$2 = moduleExports$2 ? root.Buffer : void 0;
      var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
      var isBuffer = exports("aT", nativeIsBuffer || stubFalse);
      var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
      var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
      var freeProcess = moduleExports$1 && freeGlobal.process;
      var nodeUtil = exports("n", function() {
        try {
          var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }());
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      var objectProto$8 = Object.prototype;
      var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty$7.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      var nativeKeys = overArg(Object.keys, Object);
      var objectProto$7 = Object.prototype;
      var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty$6.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function nativeKeysIn(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }
      var objectProto$6 = Object.prototype;
      var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty$5.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      var nativeCreate = getNative(Object, "create");
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
      var objectProto$5 = Object.prototype;
      var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED$2 ? void 0 : result;
        }
        return hasOwnProperty$4.call(data, key) ? data[key] : void 0;
      }
      var objectProto$4 = Object.prototype;
      var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty$3.call(data, key);
      }
      var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
        return this;
      }
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      var Map$1 = getNative(root, "Map");
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map$1 || ListCache)(),
          "string": new Hash()
        };
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      var FUNC_ERROR_TEXT$2 = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$2);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result) || cache;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result.cache;
        return result;
      }
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string) {
        var result = [];
        if (string.charCodeAt(0) === 46) {
          result.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result;
      });
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value));
      }
      var INFINITY = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : void 0;
      }
      function get(object, path, defaultValue) {
        var result = object == null ? void 0 : baseGet(object, path);
        return result === void 0 ? defaultValue : result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function baseFlatten(array, depth, predicate, isStrict, result) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result || (result = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
              arrayPush(result, value);
            }
          } else if (!isStrict) {
            result[result.length] = value;
          }
        }
        return result;
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flatRest(func) {
        return setToString(overRest(func, void 0, flatten), func + "");
      }
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      const getPrototype$1 = exports("bb", getPrototype);
      var objectTag$2 = "[object Object]";
      var funcProto = Function.prototype, objectProto$3 = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
      var objectCtorString = funcToString.call(Object);
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag$2) {
          return false;
        }
        var proto = getPrototype$1(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty$2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer$1 = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function stubArray() {
        return [];
      }
      var objectProto$2 = Object.prototype;
      var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbols = exports("b2", !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      });
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      var DataView = getNative(root, "DataView");
      var Promise$1 = getNative(root, "Promise");
      var Set$1 = exports("c", getNative(root, "Set"));
      var mapTag$1 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$1 = "[object Set]", weakMapTag = "[object WeakMap]";
      var dataViewTag$1 = "[object DataView]";
      var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap);
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$1 || Map$1 && getTag(new Map$1()) != mapTag$1 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$1 || WeakMap && getTag(new WeakMap()) != weakMapTag) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag$1;
              case mapCtorString:
                return mapTag$1;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag$1;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      const getTag$1 = exports("aS", getTag);
      var Uint8Array$1 = root.Uint8Array;
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
        return result;
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype$1(object)) : {};
      }
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen2) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen2.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result;
      }
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function setToArray(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
      var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
      var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG$2;
            stack.set(object, other);
            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      var COMPARE_PARTIAL_FLAG$3 = 1;
      var objectProto$1 = Object.prototype;
      var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result;
      }
      var COMPARE_PARTIAL_FLAG$2 = 1;
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === void 0 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function getMatchData(object) {
        var result = keys(object), length = result.length;
        while (length--) {
          var key = result[length], value = object[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
        };
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? void 0 : object[key];
        };
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      var baseFor = createBaseFor();
      function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys);
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      var baseEach = createBaseEach(baseForOwn);
      var now = function() {
        return root.Date.now();
      };
      var FUNC_ERROR_TEXT$1 = "Expected a function";
      var nativeMax = Math.max, nativeMin = Math.min;
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$1);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout(timerId);
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      function assignMergeValue(object, key, value) {
        if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
        var isCommon = newValue === void 0;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
            if (newValue === void 0) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMap(collection, iteratee) {
        var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result[++index] = iteratee(value, key, collection2);
        });
        return result;
      }
      function map(collection, iteratee) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, baseIteratee(iteratee));
      }
      function flatMap(collection, iteratee) {
        return baseFlatten(map(collection, iteratee), 1);
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result = {};
        while (++index < length) {
          var pair = pairs[index];
          result[pair[0]] = pair[1];
        }
        return result;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isNil(value) {
        return value == null;
      }
      function isUndefined$1(value) {
        return value === void 0;
      }
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      const merge$1 = merge;
      function baseSet(object, path, value, customizer) {
        if (!isObject(object)) {
          return object;
        }
        path = castPath(path, object);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : void 0;
            if (newValue === void 0) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result, castPath(path, object), value);
          }
        }
        return result;
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function set(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      var FUNC_ERROR_TEXT = "Expected a function";
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      const isUndefined = exports("W", (val) => val === void 0);
      const isBoolean = exports("w", (val) => typeof val === "boolean");
      const isNumber = exports("R", (val) => typeof val === "number");
      const isEmpty = exports("az", (val) => !val && val !== 0 || isArray$1(val) && val.length === 0 || isObject$1(val) && !Object.keys(val).length);
      const isElement = (e) => {
        if (typeof Element === "undefined")
          return false;
        return e instanceof Element;
      };
      const isPropAbsent = (prop) => {
        return isNil(prop);
      };
      const isStringNumber = (val) => {
        if (!isString(val)) {
          return false;
        }
        return !Number.isNaN(Number(val));
      };
      const rAF = (fn2) => isClient ? window.requestAnimationFrame(fn2) : setTimeout(fn2, 16);
      const keysOf = (arr) => Object.keys(arr);
      const entriesOf = exports("aO", (arr) => Object.entries(arr));
      const getProp = exports("y", (obj, path, defaultValue) => {
        return {
          get value() {
            return get(obj, path, defaultValue);
          },
          set value(val) {
            set(obj, path, val);
          }
        };
      });
      class ElementPlusError extends Error {
        constructor(m2) {
          super(m2);
          this.name = "ElementPlusError";
        }
      }
      function throwError(scope, m2) {
        throw new ElementPlusError(`[${scope}] ${m2}`);
      }
      function debugWarn(scope, message) {
      }
      const classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
      const hasClass = exports("aE", (el, cls) => {
        if (!el || !cls)
          return false;
        if (cls.includes(" "))
          throw new Error("className should not contain space.");
        return el.classList.contains(cls);
      });
      const addClass = exports("aC", (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.add(...classNameToArray(cls));
      });
      const removeClass = exports("aD", (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.remove(...classNameToArray(cls));
      });
      const getStyle = exports("bf", (element, styleName) => {
        var _a2;
        if (!isClient || !element || !styleName)
          return "";
        let key = camelize(styleName);
        if (key === "float")
          key = "cssFloat";
        try {
          const style = element.style[key];
          if (style)
            return style;
          const computed2 = (_a2 = document.defaultView) == null ? void 0 : _a2.getComputedStyle(element, "");
          return computed2 ? computed2[key] : "";
        } catch (e) {
          return element.style[key];
        }
      });
      function addUnit(value, defaultUnit = "px") {
        if (!value)
          return "";
        if (isNumber(value) || isStringNumber(value)) {
          return `${value}${defaultUnit}`;
        } else if (isString(value)) {
          return value;
        }
      }
      const isScroll = (el, isVertical) => {
        if (!isClient)
          return false;
        const key = {
          undefined: "overflow",
          true: "overflow-y",
          false: "overflow-x"
        }[String(isVertical)];
        const overflow = getStyle(el, key);
        return ["scroll", "auto", "overlay"].some((s2) => overflow.includes(s2));
      };
      const getScrollContainer = (el, isVertical) => {
        if (!isClient)
          return;
        let parent = el;
        while (parent) {
          if ([window, document, document.documentElement].includes(parent))
            return window;
          if (isScroll(parent, isVertical))
            return parent;
          parent = parent.parentNode;
        }
        return parent;
      };
      let scrollBarWidth;
      const getScrollBarWidth = (namespace) => {
        var _a2;
        if (!isClient)
          return 0;
        if (scrollBarWidth !== void 0)
          return scrollBarWidth;
        const outer = document.createElement("div");
        outer.className = `${namespace}-scrollbar__wrap`;
        outer.style.visibility = "hidden";
        outer.style.width = "100px";
        outer.style.position = "absolute";
        outer.style.top = "-9999px";
        document.body.appendChild(outer);
        const widthNoScroll = outer.offsetWidth;
        outer.style.overflow = "scroll";
        const inner = document.createElement("div");
        inner.style.width = "100%";
        outer.appendChild(inner);
        const widthWithScroll = inner.offsetWidth;
        (_a2 = outer.parentNode) == null ? void 0 : _a2.removeChild(outer);
        scrollBarWidth = widthNoScroll - widthWithScroll;
        return scrollBarWidth;
      };
      function scrollIntoView(container, selected) {
        if (!isClient)
          return;
        if (!selected) {
          container.scrollTop = 0;
          return;
        }
        const offsetParents = [];
        let pointer = selected.offsetParent;
        while (pointer !== null && container !== pointer && container.contains(pointer)) {
          offsetParents.push(pointer);
          pointer = pointer.offsetParent;
        }
        const top = selected.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
        const bottom = top + selected.offsetHeight;
        const viewRectTop = container.scrollTop;
        const viewRectBottom = viewRectTop + container.clientHeight;
        if (top < viewRectTop) {
          container.scrollTop = top;
        } else if (bottom > viewRectBottom) {
          container.scrollTop = bottom - container.clientHeight;
        }
      }
      /*! Element Plus Icons Vue v2.3.1 */
      var arrow_down_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowDown",
        __name: "arrow-down",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
            })
          ]));
        }
      });
      var arrow_down_default = exports("$", arrow_down_vue_vue_type_script_setup_true_lang_default);
      var arrow_left_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowLeft",
        __name: "arrow-left",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
            })
          ]));
        }
      });
      var arrow_left_default = exports("ah", arrow_left_vue_vue_type_script_setup_true_lang_default);
      var arrow_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowRight",
        __name: "arrow-right",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
            })
          ]));
        }
      });
      var arrow_right_default = exports("V", arrow_right_vue_vue_type_script_setup_true_lang_default);
      var arrow_up_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowUp",
        __name: "arrow-up",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
            })
          ]));
        }
      });
      var arrow_up_default = exports("a1", arrow_up_vue_vue_type_script_setup_true_lang_default);
      var calendar_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Calendar",
        __name: "calendar",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M128 384v512h768V192H768v32a32 32 0 1 1-64 0v-32H320v32a32 32 0 0 1-64 0v-32H128v128h768v64zm192-256h384V96a32 32 0 1 1 64 0v32h160a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h160V96a32 32 0 0 1 64 0zm-32 384h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64"
            })
          ]));
        }
      });
      var calendar_default = exports("L", calendar_vue_vue_type_script_setup_true_lang_default);
      var check_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Check",
        __name: "check",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
            })
          ]));
        }
      });
      var check_default = exports("am", check_vue_vue_type_script_setup_true_lang_default);
      var circle_check_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "CircleCheck",
        __name: "circle-check",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            }),
            createElementVNode("path", {
              fill: "currentColor",
              d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
            })
          ]));
        }
      });
      var circle_check_default = exports("al", circle_check_vue_vue_type_script_setup_true_lang_default);
      var circle_close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "CircleClose",
        __name: "circle-close",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
            }),
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            })
          ]));
        }
      });
      var circle_close_default = exports("D", circle_close_vue_vue_type_script_setup_true_lang_default);
      var clock_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Clock",
        __name: "clock",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            }),
            createElementVNode("path", {
              fill: "currentColor",
              d: "M480 256a32 32 0 0 1 32 32v256a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32"
            }),
            createElementVNode("path", {
              fill: "currentColor",
              d: "M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32"
            })
          ]));
        }
      });
      var clock_default = exports("K", clock_vue_vue_type_script_setup_true_lang_default);
      var close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Close",
        __name: "close",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
            })
          ]));
        }
      });
      var close_default = exports("an", close_vue_vue_type_script_setup_true_lang_default);
      var d_arrow_left_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "DArrowLeft",
        __name: "d-arrow-left",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224zm256 0a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224z"
            })
          ]));
        }
      });
      var d_arrow_left_default = exports("ae", d_arrow_left_vue_vue_type_script_setup_true_lang_default);
      var d_arrow_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "DArrowRight",
        __name: "d-arrow-right",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L764.736 512 452.864 192a30.592 30.592 0 0 1 0-42.688m-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L508.736 512 196.864 192a30.592 30.592 0 0 1 0-42.688z"
            })
          ]));
        }
      });
      var d_arrow_right_default = exports("ag", d_arrow_right_vue_vue_type_script_setup_true_lang_default);
      var delete_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Delete",
        __name: "delete",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32zm448-64v-64H416v64zM224 896h576V256H224zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32m192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32"
            })
          ]));
        }
      });
      var delete_default = exports("au", delete_vue_vue_type_script_setup_true_lang_default);
      var document_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Document",
        __name: "document",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M832 384H576V128H192v768h640zm-26.496-64L640 154.496V320zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32m160 448h384v64H320zm0-192h160v64H320zm0 384h384v64H320z"
            })
          ]));
        }
      });
      var document_default = exports("as", document_vue_vue_type_script_setup_true_lang_default);
      var full_screen_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "FullScreen",
        __name: "full-screen",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64z"
            })
          ]));
        }
      });
      var full_screen_default = full_screen_vue_vue_type_script_setup_true_lang_default;
      var hide_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Hide",
        __name: "hide",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
            }),
            createElementVNode("path", {
              fill: "currentColor",
              d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
            })
          ]));
        }
      });
      var hide_default = hide_vue_vue_type_script_setup_true_lang_default;
      var loading_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Loading",
        __name: "loading",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
            })
          ]));
        }
      });
      var loading_default = exports("aq", loading_vue_vue_type_script_setup_true_lang_default);
      var minus_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Minus",
        __name: "minus",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64"
            })
          ]));
        }
      });
      var minus_default = exports("a0", minus_vue_vue_type_script_setup_true_lang_default);
      var more_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "MoreFilled",
        __name: "more-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224"
            })
          ]));
        }
      });
      var more_filled_default = exports("af", more_filled_vue_vue_type_script_setup_true_lang_default);
      var more_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "More",
        __name: "more",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M176 416a112 112 0 1 0 0 224 112 112 0 0 0 0-224m0 64a48 48 0 1 1 0 96 48 48 0 0 1 0-96m336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224m0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96m336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224m0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96"
            })
          ]));
        }
      });
      var more_default = exports("a4", more_vue_vue_type_script_setup_true_lang_default);
      var plus_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Plus",
        __name: "plus",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64z"
            })
          ]));
        }
      });
      var plus_default = exports("a2", plus_vue_vue_type_script_setup_true_lang_default);
      var question_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "QuestionFilled",
        __name: "question-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 0 0-38.72 14.784 49.408 49.408 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.968 51.968 0 0 0-15.488-38.016 55.936 55.936 0 0 0-39.424-14.784z"
            })
          ]));
        }
      });
      var question_filled_default = exports("aj", question_filled_vue_vue_type_script_setup_true_lang_default);
      var refresh_left_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "RefreshLeft",
        __name: "refresh-left",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
            })
          ]));
        }
      });
      var refresh_left_default = refresh_left_vue_vue_type_script_setup_true_lang_default;
      var refresh_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "RefreshRight",
        __name: "refresh-right",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
            })
          ]));
        }
      });
      var refresh_right_default = refresh_right_vue_vue_type_script_setup_true_lang_default;
      var scale_to_original_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ScaleToOriginal",
        __name: "scale-to-original",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118M512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412M512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512"
            })
          ]));
        }
      });
      var scale_to_original_default = scale_to_original_vue_vue_type_script_setup_true_lang_default;
      var view_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "View",
        __name: "view",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
            })
          ]));
        }
      });
      var view_default = view_vue_vue_type_script_setup_true_lang_default;
      var warning_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "WarningFilled",
        __name: "warning-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
            })
          ]));
        }
      });
      var warning_filled_default = exports("ak", warning_filled_vue_vue_type_script_setup_true_lang_default);
      var zoom_in_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ZoomIn",
        __name: "zoom-in",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704m-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64z"
            })
          ]));
        }
      });
      var zoom_in_default = exports("at", zoom_in_vue_vue_type_script_setup_true_lang_default);
      var zoom_out_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ZoomOut",
        __name: "zoom-out",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704M352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64"
            })
          ]));
        }
      });
      var zoom_out_default = zoom_out_vue_vue_type_script_setup_true_lang_default;
      const epPropKey = "__epPropKey";
      const definePropType = exports("j", (val) => val);
      const isEpProp = (val) => isObject$1(val) && !!val[epPropKey];
      const buildProp = (prop, key) => {
        if (!isObject$1(prop) || isEpProp(prop))
          return prop;
        const { values, required, default: defaultValue, type, validator: validator2 } = prop;
        const _validator = values || validator2 ? (val) => {
          let valid = false;
          let allowedValues = [];
          if (values) {
            allowedValues = Array.from(values);
            if (hasOwn(prop, "default")) {
              allowedValues.push(defaultValue);
            }
            valid || (valid = allowedValues.includes(val));
          }
          if (validator2)
            valid || (valid = validator2(val));
          if (!valid && allowedValues.length > 0) {
            const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
            warn(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
          }
          return valid;
        } : void 0;
        const epProp = {
          type,
          required: !!required,
          validator: _validator,
          [epPropKey]: true
        };
        if (hasOwn(prop, "default"))
          epProp.default = defaultValue;
        return epProp;
      };
      const buildProps = exports("f", (props) => fromPairs(Object.entries(props).map(([key, option]) => [
        key,
        buildProp(option, key)
      ])));
      const iconPropType = exports("a3", definePropType([
        String,
        Object,
        Function
      ]));
      const CloseComponents = {
        Close: close_default
      };
      const ValidateComponentsMap = exports("aI", {
        validating: loading_default,
        success: circle_check_default,
        error: circle_close_default
      });
      const withInstall = exports("z", (main, extra) => {
        main.install = (app2) => {
          for (const comp of [main, ...Object.values(extra != null ? extra : {})]) {
            app2.component(comp.name, comp);
          }
        };
        if (extra) {
          for (const [key, comp] of Object.entries(extra)) {
            main[key] = comp;
          }
        }
        return main;
      });
      const withNoopInstall = exports("C", (component) => {
        component.install = NOOP;
        return component;
      });
      const composeRefs = (...refs) => {
        return (el) => {
          refs.forEach((ref2) => {
            if (isFunction$1(ref2)) {
              ref2(el);
            } else {
              ref2.value = el;
            }
          });
        };
      };
      const EVENT_CODE = exports("aA", {
        tab: "Tab",
        enter: "Enter",
        space: "Space",
        left: "ArrowLeft",
        up: "ArrowUp",
        right: "ArrowRight",
        down: "ArrowDown",
        esc: "Escape",
        delete: "Delete",
        backspace: "Backspace",
        numpadEnter: "NumpadEnter",
        pageUp: "PageUp",
        pageDown: "PageDown",
        home: "Home",
        end: "End"
      });
      const UPDATE_MODEL_EVENT = exports("Z", "update:modelValue");
      const CHANGE_EVENT = exports("ac", "change");
      const INPUT_EVENT = exports("ap", "input");
      const componentSizes = exports("h", ["", "default", "small", "large"]);
      var PatchFlags = /* @__PURE__ */ ((PatchFlags2) => {
        PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
        PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
        PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
        PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
        PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
        PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
        PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
        PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
        PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
        PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
        PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
        PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
        PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
        return PatchFlags2;
      })(PatchFlags || {});
      const flattedChildren = exports("a5", (children) => {
        const vNodes = isArray$1(children) ? children : [children];
        const result = [];
        vNodes.forEach((child) => {
          var _a2;
          if (isArray$1(child)) {
            result.push(...flattedChildren(child));
          } else if (isVNode(child) && isArray$1(child.children)) {
            result.push(...flattedChildren(child.children));
          } else {
            result.push(child);
            if (isVNode(child) && ((_a2 = child.component) == null ? void 0 : _a2.subTree)) {
              result.push(...flattedChildren(child.component.subTree));
            }
          }
        });
        return result;
      });
      const isKorean = exports("b8", (text) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(text));
      const mutable = exports("Q", (val) => val);
      const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
      const LISTENER_PREFIX = /^on[A-Z]/;
      const useAttrs = (params = {}) => {
        const { excludeListeners = false, excludeKeys } = params;
        const allExcludeKeys = computed$1(() => {
          return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
        });
        const instance = getCurrentInstance();
        if (!instance) {
          return computed$1(() => ({}));
        }
        return computed$1(() => {
          var _a2;
          return fromPairs(Object.entries((_a2 = instance.proxy) == null ? void 0 : _a2.$attrs).filter(([key]) => !allExcludeKeys.value.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))));
        });
      };
      const useDeprecated = ({ from, replacement, scope, version, ref: ref2, type = "API" }, condition) => {
        watch(() => unref(condition), (val) => {
        }, {
          immediate: true
        });
      };
      const useDraggable = (targetRef, dragRef, draggable, overflow) => {
        let transform = {
          offsetX: 0,
          offsetY: 0
        };
        const onMousedown = (e) => {
          const downX = e.clientX;
          const downY = e.clientY;
          const { offsetX, offsetY } = transform;
          const targetRect = targetRef.value.getBoundingClientRect();
          const targetLeft = targetRect.left;
          const targetTop = targetRect.top;
          const targetWidth = targetRect.width;
          const targetHeight = targetRect.height;
          const clientWidth = document.documentElement.clientWidth;
          const clientHeight = document.documentElement.clientHeight;
          const minLeft = -targetLeft + offsetX;
          const minTop = -targetTop + offsetY;
          const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
          const maxTop = clientHeight - targetTop - targetHeight + offsetY;
          const onMousemove = (e2) => {
            let moveX = offsetX + e2.clientX - downX;
            let moveY = offsetY + e2.clientY - downY;
            if (!(overflow == null ? void 0 : overflow.value)) {
              moveX = Math.min(Math.max(moveX, minLeft), maxLeft);
              moveY = Math.min(Math.max(moveY, minTop), maxTop);
            }
            transform = {
              offsetX: moveX,
              offsetY: moveY
            };
            if (targetRef.value) {
              targetRef.value.style.transform = `translate(${addUnit(moveX)}, ${addUnit(moveY)})`;
            }
          };
          const onMouseup = () => {
            document.removeEventListener("mousemove", onMousemove);
            document.removeEventListener("mouseup", onMouseup);
          };
          document.addEventListener("mousemove", onMousemove);
          document.addEventListener("mouseup", onMouseup);
        };
        const onDraggable = () => {
          if (dragRef.value && targetRef.value) {
            dragRef.value.addEventListener("mousedown", onMousedown);
          }
        };
        const offDraggable = () => {
          if (dragRef.value && targetRef.value) {
            dragRef.value.removeEventListener("mousedown", onMousedown);
          }
        };
        onMounted(() => {
          watchEffect(() => {
            if (draggable.value) {
              onDraggable();
            } else {
              offDraggable();
            }
          });
        });
        onBeforeUnmount(() => {
          offDraggable();
        });
      };
      var English = {
        name: "en",
        el: {
          breadcrumb: {
            label: "Breadcrumb"
          },
          colorpicker: {
            confirm: "OK",
            clear: "Clear",
            defaultLabel: "color picker",
            description: "current color is {color}. press enter to select a new color."
          },
          datepicker: {
            now: "Now",
            today: "Today",
            cancel: "Cancel",
            clear: "Clear",
            confirm: "OK",
            dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
            monthTablePrompt: "Use the arrow keys and enter to select the month",
            yearTablePrompt: "Use the arrow keys and enter to select the year",
            selectedDate: "Selected date",
            selectDate: "Select date",
            selectTime: "Select time",
            startDate: "Start Date",
            startTime: "Start Time",
            endDate: "End Date",
            endTime: "End Time",
            prevYear: "Previous Year",
            nextYear: "Next Year",
            prevMonth: "Previous Month",
            nextMonth: "Next Month",
            year: "",
            month1: "January",
            month2: "February",
            month3: "March",
            month4: "April",
            month5: "May",
            month6: "June",
            month7: "July",
            month8: "August",
            month9: "September",
            month10: "October",
            month11: "November",
            month12: "December",
            week: "week",
            weeks: {
              sun: "Sun",
              mon: "Mon",
              tue: "Tue",
              wed: "Wed",
              thu: "Thu",
              fri: "Fri",
              sat: "Sat"
            },
            weeksFull: {
              sun: "Sunday",
              mon: "Monday",
              tue: "Tuesday",
              wed: "Wednesday",
              thu: "Thursday",
              fri: "Friday",
              sat: "Saturday"
            },
            months: {
              jan: "Jan",
              feb: "Feb",
              mar: "Mar",
              apr: "Apr",
              may: "May",
              jun: "Jun",
              jul: "Jul",
              aug: "Aug",
              sep: "Sep",
              oct: "Oct",
              nov: "Nov",
              dec: "Dec"
            }
          },
          inputNumber: {
            decrease: "decrease number",
            increase: "increase number"
          },
          select: {
            loading: "Loading",
            noMatch: "No matching data",
            noData: "No data",
            placeholder: "Select"
          },
          dropdown: {
            toggleDropdown: "Toggle Dropdown"
          },
          cascader: {
            noMatch: "No matching data",
            loading: "Loading",
            placeholder: "Select",
            noData: "No data"
          },
          pagination: {
            goto: "Go to",
            pagesize: "/page",
            total: "Total {total}",
            pageClassifier: "",
            page: "Page",
            prev: "Go to previous page",
            next: "Go to next page",
            currentPage: "page {pager}",
            prevPages: "Previous {pager} pages",
            nextPages: "Next {pager} pages",
            deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
          },
          dialog: {
            close: "Close this dialog"
          },
          drawer: {
            close: "Close this dialog"
          },
          messagebox: {
            title: "Message",
            confirm: "OK",
            cancel: "Cancel",
            error: "Illegal input",
            close: "Close this dialog"
          },
          upload: {
            deleteTip: "press delete to remove",
            delete: "Delete",
            preview: "Preview",
            continue: "Continue"
          },
          slider: {
            defaultLabel: "slider between {min} and {max}",
            defaultRangeStartLabel: "pick start value",
            defaultRangeEndLabel: "pick end value"
          },
          table: {
            emptyText: "No Data",
            confirmFilter: "Confirm",
            resetFilter: "Reset",
            clearFilter: "All",
            sumText: "Sum"
          },
          tour: {
            next: "Next",
            previous: "Previous",
            finish: "Finish"
          },
          tree: {
            emptyText: "No Data"
          },
          transfer: {
            noMatch: "No matching data",
            noData: "No data",
            titles: ["List 1", "List 2"],
            filterPlaceholder: "Enter keyword",
            noCheckedFormat: "{total} items",
            hasCheckedFormat: "{checked}/{total} checked"
          },
          image: {
            error: "FAILED"
          },
          pageHeader: {
            title: "Back"
          },
          popconfirm: {
            confirmButtonText: "Yes",
            cancelButtonText: "No"
          },
          carousel: {
            leftArrow: "Carousel arrow left",
            rightArrow: "Carousel arrow right",
            indicator: "Carousel switch to index {index}"
          }
        }
      };
      const buildTranslator = (locale) => (path, option) => translate(path, option, unref(locale));
      const translate = (path, option, locale) => get(locale, path, path).replace(/\{(\w+)\}/g, (_2, key) => {
        var _a2;
        return `${(_a2 = option == null ? void 0 : option[key]) != null ? _a2 : `{${key}}`}`;
      });
      const buildLocaleContext = (locale) => {
        const lang = computed$1(() => unref(locale).name);
        const localeRef = isRef(locale) ? locale : ref(locale);
        return {
          lang,
          locale: localeRef,
          t: buildTranslator(locale)
        };
      };
      const localeContextKey = Symbol("localeContextKey");
      const useLocale = exports("G", (localeOverrides) => {
        const locale = localeOverrides || inject(localeContextKey, ref());
        return buildLocaleContext(computed$1(() => locale.value || English));
      });
      /**
      * @vue/reactivity v3.4.21
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      let activeEffectScope;
      function recordEffectScope(effect2, scope = activeEffectScope) {
        if (scope && scope.active) {
          scope.effects.push(effect2);
        }
      }
      let activeEffect;
      class ReactiveEffect {
        constructor(fn2, trigger2, scheduler, scope) {
          this.fn = fn2;
          this.trigger = trigger2;
          this.scheduler = scheduler;
          this.active = true;
          this.deps = [];
          this._dirtyLevel = 4;
          this._trackId = 0;
          this._runnings = 0;
          this._shouldSchedule = false;
          this._depsLength = 0;
          recordEffectScope(this, scope);
        }
        get dirty() {
          if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
            this._dirtyLevel = 1;
            pauseTracking();
            for (let i = 0; i < this._depsLength; i++) {
              const dep = this.deps[i];
              if (dep.computed) {
                triggerComputed(dep.computed);
                if (this._dirtyLevel >= 4) {
                  break;
                }
              }
            }
            if (this._dirtyLevel === 1) {
              this._dirtyLevel = 0;
            }
            resetTracking();
          }
          return this._dirtyLevel >= 4;
        }
        set dirty(v2) {
          this._dirtyLevel = v2 ? 4 : 0;
        }
        run() {
          this._dirtyLevel = 0;
          if (!this.active) {
            return this.fn();
          }
          let lastShouldTrack = shouldTrack;
          let lastEffect = activeEffect;
          try {
            shouldTrack = true;
            activeEffect = this;
            this._runnings++;
            preCleanupEffect(this);
            return this.fn();
          } finally {
            postCleanupEffect(this);
            this._runnings--;
            activeEffect = lastEffect;
            shouldTrack = lastShouldTrack;
          }
        }
        stop() {
          var _a2;
          if (this.active) {
            preCleanupEffect(this);
            postCleanupEffect(this);
            (_a2 = this.onStop) == null ? void 0 : _a2.call(this);
            this.active = false;
          }
        }
      }
      function triggerComputed(computed2) {
        return computed2.value;
      }
      function preCleanupEffect(effect2) {
        effect2._trackId++;
        effect2._depsLength = 0;
      }
      function postCleanupEffect(effect2) {
        if (effect2.deps.length > effect2._depsLength) {
          for (let i = effect2._depsLength; i < effect2.deps.length; i++) {
            cleanupDepEffect(effect2.deps[i], effect2);
          }
          effect2.deps.length = effect2._depsLength;
        }
      }
      function cleanupDepEffect(dep, effect2) {
        const trackId = dep.get(effect2);
        if (trackId !== void 0 && effect2._trackId !== trackId) {
          dep.delete(effect2);
          if (dep.size === 0) {
            dep.cleanup();
          }
        }
      }
      let shouldTrack = true;
      let pauseScheduleStack = 0;
      const trackStack = [];
      function pauseTracking() {
        trackStack.push(shouldTrack);
        shouldTrack = false;
      }
      function resetTracking() {
        const last = trackStack.pop();
        shouldTrack = last === void 0 ? true : last;
      }
      function pauseScheduling() {
        pauseScheduleStack++;
      }
      function resetScheduling() {
        pauseScheduleStack--;
        while (!pauseScheduleStack && queueEffectSchedulers.length) {
          queueEffectSchedulers.shift()();
        }
      }
      function trackEffect(effect2, dep, debuggerEventExtraInfo) {
        if (dep.get(effect2) !== effect2._trackId) {
          dep.set(effect2, effect2._trackId);
          const oldDep = effect2.deps[effect2._depsLength];
          if (oldDep !== dep) {
            if (oldDep) {
              cleanupDepEffect(oldDep, effect2);
            }
            effect2.deps[effect2._depsLength++] = dep;
          } else {
            effect2._depsLength++;
          }
        }
      }
      const queueEffectSchedulers = [];
      function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
        pauseScheduling();
        for (const effect2 of dep.keys()) {
          let tracking;
          if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
            effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
            effect2._dirtyLevel = dirtyLevel;
          }
          if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
            effect2.trigger();
            if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
              effect2._shouldSchedule = false;
              if (effect2.scheduler) {
                queueEffectSchedulers.push(effect2.scheduler);
              }
            }
          }
        }
        resetScheduling();
      }
      const createDep = (cleanup, computed2) => {
        const dep = /* @__PURE__ */ new Map();
        dep.cleanup = cleanup;
        dep.computed = computed2;
        return dep;
      };
      new Set(
        /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
      );
      function toRaw(observed) {
        const raw = observed && observed["__v_raw"];
        return raw ? toRaw(raw) : observed;
      }
      class ComputedRefImpl {
        constructor(getter, _setter, isReadonly2, isSSR) {
          this.getter = getter;
          this._setter = _setter;
          this.dep = void 0;
          this.__v_isRef = true;
          this["__v_isReadonly"] = false;
          this.effect = new ReactiveEffect(
            () => getter(this._value),
            () => triggerRefValue(
              this,
              this.effect._dirtyLevel === 2 ? 2 : 3
            )
          );
          this.effect.computed = this;
          this.effect.active = this._cacheable = !isSSR;
          this["__v_isReadonly"] = isReadonly2;
        }
        get value() {
          const self2 = toRaw(this);
          if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
            triggerRefValue(self2, 4);
          }
          trackRefValue(self2);
          if (self2.effect._dirtyLevel >= 2) {
            triggerRefValue(self2, 2);
          }
          return self2._value;
        }
        set value(newValue) {
          this._setter(newValue);
        }
        // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
        get _dirty() {
          return this.effect.dirty;
        }
        set _dirty(v2) {
          this.effect.dirty = v2;
        }
        // #endregion
      }
      function computed(getterOrOptions, debugOptions, isSSR = false) {
        let getter;
        let setter;
        const onlyGetter = isFunction$1(getterOrOptions);
        if (onlyGetter) {
          getter = getterOrOptions;
          setter = NOOP;
        } else {
          getter = getterOrOptions.get;
          setter = getterOrOptions.set;
        }
        const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
        return cRef;
      }
      function trackRefValue(ref2) {
        var _a2;
        if (shouldTrack && activeEffect) {
          ref2 = toRaw(ref2);
          trackEffect(
            activeEffect,
            (_a2 = ref2.dep) != null ? _a2 : ref2.dep = createDep(
              () => ref2.dep = void 0,
              ref2 instanceof ComputedRefImpl ? ref2 : void 0
            )
          );
        }
      }
      function triggerRefValue(ref2, dirtyLevel = 4, newVal) {
        ref2 = toRaw(ref2);
        const dep = ref2.dep;
        if (dep) {
          triggerEffects(
            dep,
            dirtyLevel
          );
        }
      }
      const defaultNamespace = "el";
      const statePrefix = "is-";
      const _bem = (namespace, block, blockSuffix, element, modifier) => {
        let cls = `${namespace}-${block}`;
        if (blockSuffix) {
          cls += `-${blockSuffix}`;
        }
        if (element) {
          cls += `__${element}`;
        }
        if (modifier) {
          cls += `--${modifier}`;
        }
        return cls;
      };
      const namespaceContextKey = Symbol("namespaceContextKey");
      const useGetDerivedNamespace = (namespaceOverrides) => {
        const derivedNamespace = namespaceOverrides || (getCurrentInstance() ? inject(namespaceContextKey, ref(defaultNamespace)) : ref(defaultNamespace));
        const namespace = computed$1(() => {
          return unref(derivedNamespace) || defaultNamespace;
        });
        return namespace;
      };
      const useNamespace = exports("k", (block, namespaceOverrides) => {
        const namespace = useGetDerivedNamespace(namespaceOverrides);
        const b2 = (blockSuffix = "") => _bem(namespace.value, block, blockSuffix, "", "");
        const e = (element) => element ? _bem(namespace.value, block, "", element, "") : "";
        const m2 = (modifier) => modifier ? _bem(namespace.value, block, "", "", modifier) : "";
        const be2 = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block, blockSuffix, element, "") : "";
        const em = (element, modifier) => element && modifier ? _bem(namespace.value, block, "", element, modifier) : "";
        const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block, blockSuffix, "", modifier) : "";
        const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block, blockSuffix, element, modifier) : "";
        const is = (name, ...args) => {
          const state = args.length >= 1 ? args[0] : true;
          return name && state ? `${statePrefix}${name}` : "";
        };
        const cssVar = (object) => {
          const styles = {};
          for (const key in object) {
            if (object[key]) {
              styles[`--${namespace.value}-${key}`] = object[key];
            }
          }
          return styles;
        };
        const cssVarBlock = (object) => {
          const styles = {};
          for (const key in object) {
            if (object[key]) {
              styles[`--${namespace.value}-${block}-${key}`] = object[key];
            }
          }
          return styles;
        };
        const cssVarName = (name) => `--${namespace.value}-${name}`;
        const cssVarBlockName = (name) => `--${namespace.value}-${block}-${name}`;
        return {
          namespace,
          b: b2,
          e,
          m: m2,
          be: be2,
          em,
          bm,
          bem,
          is,
          cssVar,
          cssVarName,
          cssVarBlock,
          cssVarBlockName
        };
      });
      const useLockscreen = (trigger, options = {}) => {
        if (!isRef(trigger)) {
          throwError("[useLockscreen]", "You need to pass a ref param to this function");
        }
        const ns = options.ns || useNamespace("popup");
        const hiddenCls = computed(() => ns.bm("parent", "hidden"));
        if (!isClient || hasClass(document.body, hiddenCls.value)) {
          return;
        }
        let scrollBarWidth2 = 0;
        let withoutHiddenClass = false;
        let bodyWidth = "0";
        const cleanup = () => {
          setTimeout(() => {
            removeClass(document == null ? void 0 : document.body, hiddenCls.value);
            if (withoutHiddenClass && document) {
              document.body.style.width = bodyWidth;
            }
          }, 200);
        };
        watch(trigger, (val) => {
          if (!val) {
            cleanup();
            return;
          }
          withoutHiddenClass = !hasClass(document.body, hiddenCls.value);
          if (withoutHiddenClass) {
            bodyWidth = document.body.style.width;
          }
          scrollBarWidth2 = getScrollBarWidth(ns.namespace.value);
          const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
          const bodyOverflowY = getStyle(document.body, "overflowY");
          if (scrollBarWidth2 > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
            document.body.style.width = `calc(100% - ${scrollBarWidth2}px)`;
          }
          addClass(document.body, hiddenCls.value);
        });
        onScopeDispose(() => cleanup());
      };
      const _prop = buildProp({
        type: definePropType(Boolean),
        default: null
      });
      const _event = buildProp({
        type: definePropType(Function)
      });
      const createModelToggleComposable = (name) => {
        const updateEventKey = `update:${name}`;
        const updateEventKeyRaw = `onUpdate:${name}`;
        const useModelToggleEmits2 = [updateEventKey];
        const useModelToggleProps2 = {
          [name]: _prop,
          [updateEventKeyRaw]: _event
        };
        const useModelToggle2 = ({
          indicator,
          toggleReason,
          shouldHideWhenRouteChanges,
          shouldProceed,
          onShow,
          onHide
        }) => {
          const instance = getCurrentInstance();
          const { emit } = instance;
          const props = instance.props;
          const hasUpdateHandler = computed$1(() => isFunction$1(props[updateEventKeyRaw]));
          const isModelBindingAbsent = computed$1(() => props[name] === null);
          const doShow = (event) => {
            if (indicator.value === true) {
              return;
            }
            indicator.value = true;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$1(onShow)) {
              onShow(event);
            }
          };
          const doHide = (event) => {
            if (indicator.value === false) {
              return;
            }
            indicator.value = false;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$1(onHide)) {
              onHide(event);
            }
          };
          const show = (event) => {
            if (props.disabled === true || isFunction$1(shouldProceed) && !shouldProceed())
              return;
            const shouldEmit = hasUpdateHandler.value && isClient;
            if (shouldEmit) {
              emit(updateEventKey, true);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doShow(event);
            }
          };
          const hide = (event) => {
            if (props.disabled === true || !isClient)
              return;
            const shouldEmit = hasUpdateHandler.value && isClient;
            if (shouldEmit) {
              emit(updateEventKey, false);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doHide(event);
            }
          };
          const onChange = (val) => {
            if (!isBoolean(val))
              return;
            if (props.disabled && val) {
              if (hasUpdateHandler.value) {
                emit(updateEventKey, false);
              }
            } else if (indicator.value !== val) {
              if (val) {
                doShow();
              } else {
                doHide();
              }
            }
          };
          const toggle = () => {
            if (indicator.value) {
              hide();
            } else {
              show();
            }
          };
          watch(() => props[name], onChange);
          if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
            watch(() => ({
              ...instance.proxy.$route
            }), () => {
              if (shouldHideWhenRouteChanges.value && indicator.value) {
                hide();
              }
            });
          }
          onMounted(() => {
            onChange(props[name]);
          });
          return {
            hide,
            show,
            toggle,
            hasUpdateHandler
          };
        };
        return {
          useModelToggle: useModelToggle2,
          useModelToggleProps: useModelToggleProps2,
          useModelToggleEmits: useModelToggleEmits2
        };
      };
      const useProp = (name) => {
        const vm = getCurrentInstance();
        return computed$1(() => {
          var _a2, _b;
          return (_b = (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$props) == null ? void 0 : _b[name];
        });
      };
      var E$1 = "top", R = "bottom", W = "right", P$1 = "left", me = "auto", G = [E$1, R, W, P$1], U$1 = "start", J = "end", Xe = "clippingParents", je = "viewport", K = "popper", Ye = "reference", De = G.reduce(function(t, e) {
        return t.concat([e + "-" + U$1, e + "-" + J]);
      }, []), Ee = exports("a9", [].concat(G, [me]).reduce(function(t, e) {
        return t.concat([e, e + "-" + U$1, e + "-" + J]);
      }, [])), Ge = "beforeRead", Je = "read", Ke = "afterRead", Qe = "beforeMain", Ze = "main", et = "afterMain", tt = "beforeWrite", nt = "write", rt = "afterWrite", ot = [Ge, Je, Ke, Qe, Ze, et, tt, nt, rt];
      function C(t) {
        return t ? (t.nodeName || "").toLowerCase() : null;
      }
      function H(t) {
        if (t == null)
          return window;
        if (t.toString() !== "[object Window]") {
          var e = t.ownerDocument;
          return e && e.defaultView || window;
        }
        return t;
      }
      function Q(t) {
        var e = H(t).Element;
        return t instanceof e || t instanceof Element;
      }
      function B(t) {
        var e = H(t).HTMLElement;
        return t instanceof e || t instanceof HTMLElement;
      }
      function Pe(t) {
        if (typeof ShadowRoot == "undefined")
          return false;
        var e = H(t).ShadowRoot;
        return t instanceof e || t instanceof ShadowRoot;
      }
      function Mt(t) {
        var e = t.state;
        Object.keys(e.elements).forEach(function(n) {
          var r = e.styles[n] || {}, o2 = e.attributes[n] || {}, i = e.elements[n];
          !B(i) || !C(i) || (Object.assign(i.style, r), Object.keys(o2).forEach(function(a2) {
            var s2 = o2[a2];
            s2 === false ? i.removeAttribute(a2) : i.setAttribute(a2, s2 === true ? "" : s2);
          }));
        });
      }
      function Rt(t) {
        var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
        return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
          Object.keys(e.elements).forEach(function(r) {
            var o2 = e.elements[r], i = e.attributes[r] || {}, a2 = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), s2 = a2.reduce(function(f2, c2) {
              return f2[c2] = "", f2;
            }, {});
            !B(o2) || !C(o2) || (Object.assign(o2.style, s2), Object.keys(i).forEach(function(f2) {
              o2.removeAttribute(f2);
            }));
          });
        };
      }
      var Ae = { name: "applyStyles", enabled: true, phase: "write", fn: Mt, effect: Rt, requires: ["computeStyles"] };
      function q(t) {
        return t.split("-")[0];
      }
      var X$1 = Math.max, ve = Math.min, Z = Math.round;
      function ee(t, e) {
        e === void 0 && (e = false);
        var n = t.getBoundingClientRect(), r = 1, o2 = 1;
        if (B(t) && e) {
          var i = t.offsetHeight, a2 = t.offsetWidth;
          a2 > 0 && (r = Z(n.width) / a2 || 1), i > 0 && (o2 = Z(n.height) / i || 1);
        }
        return { width: n.width / r, height: n.height / o2, top: n.top / o2, right: n.right / r, bottom: n.bottom / o2, left: n.left / r, x: n.left / r, y: n.top / o2 };
      }
      function ke(t) {
        var e = ee(t), n = t.offsetWidth, r = t.offsetHeight;
        return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: r };
      }
      function it(t, e) {
        var n = e.getRootNode && e.getRootNode();
        if (t.contains(e))
          return true;
        if (n && Pe(n)) {
          var r = e;
          do {
            if (r && t.isSameNode(r))
              return true;
            r = r.parentNode || r.host;
          } while (r);
        }
        return false;
      }
      function N$1(t) {
        return H(t).getComputedStyle(t);
      }
      function Wt(t) {
        return ["table", "td", "th"].indexOf(C(t)) >= 0;
      }
      function I$1(t) {
        return ((Q(t) ? t.ownerDocument : t.document) || window.document).documentElement;
      }
      function ge(t) {
        return C(t) === "html" ? t : t.assignedSlot || t.parentNode || (Pe(t) ? t.host : null) || I$1(t);
      }
      function at(t) {
        return !B(t) || N$1(t).position === "fixed" ? null : t.offsetParent;
      }
      function Bt(t) {
        var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
        if (n && B(t)) {
          var r = N$1(t);
          if (r.position === "fixed")
            return null;
        }
        var o2 = ge(t);
        for (Pe(o2) && (o2 = o2.host); B(o2) && ["html", "body"].indexOf(C(o2)) < 0; ) {
          var i = N$1(o2);
          if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none")
            return o2;
          o2 = o2.parentNode;
        }
        return null;
      }
      function se(t) {
        for (var e = H(t), n = at(t); n && Wt(n) && N$1(n).position === "static"; )
          n = at(n);
        return n && (C(n) === "html" || C(n) === "body" && N$1(n).position === "static") ? e : n || Bt(t) || e;
      }
      function Le(t) {
        return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
      }
      function fe(t, e, n) {
        return X$1(t, ve(e, n));
      }
      function St(t, e, n) {
        var r = fe(t, e, n);
        return r > n ? n : r;
      }
      function st() {
        return { top: 0, right: 0, bottom: 0, left: 0 };
      }
      function ft(t) {
        return Object.assign({}, st(), t);
      }
      function ct(t, e) {
        return e.reduce(function(n, r) {
          return n[r] = t, n;
        }, {});
      }
      var Tt = function(t, e) {
        return t = typeof t == "function" ? t(Object.assign({}, e.rects, { placement: e.placement })) : t, ft(typeof t != "number" ? t : ct(t, G));
      };
      function Ht(t) {
        var e, n = t.state, r = t.name, o2 = t.options, i = n.elements.arrow, a2 = n.modifiersData.popperOffsets, s2 = q(n.placement), f2 = Le(s2), c2 = [P$1, W].indexOf(s2) >= 0, u2 = c2 ? "height" : "width";
        if (!(!i || !a2)) {
          var m2 = Tt(o2.padding, n), v2 = ke(i), l2 = f2 === "y" ? E$1 : P$1, h2 = f2 === "y" ? R : W, p2 = n.rects.reference[u2] + n.rects.reference[f2] - a2[f2] - n.rects.popper[u2], g = a2[f2] - n.rects.reference[f2], x2 = se(i), y = x2 ? f2 === "y" ? x2.clientHeight || 0 : x2.clientWidth || 0 : 0, $ = p2 / 2 - g / 2, d2 = m2[l2], b2 = y - v2[u2] - m2[h2], w2 = y / 2 - v2[u2] / 2 + $, O2 = fe(d2, w2, b2), j = f2;
          n.modifiersData[r] = (e = {}, e[j] = O2, e.centerOffset = O2 - w2, e);
        }
      }
      function Ct(t) {
        var e = t.state, n = t.options, r = n.element, o2 = r === void 0 ? "[data-popper-arrow]" : r;
        o2 != null && (typeof o2 == "string" && (o2 = e.elements.popper.querySelector(o2), !o2) || !it(e.elements.popper, o2) || (e.elements.arrow = o2));
      }
      var pt = { name: "arrow", enabled: true, phase: "main", fn: Ht, effect: Ct, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
      function te(t) {
        return t.split("-")[1];
      }
      var qt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
      function Vt(t) {
        var e = t.x, n = t.y, r = window, o2 = r.devicePixelRatio || 1;
        return { x: Z(e * o2) / o2 || 0, y: Z(n * o2) / o2 || 0 };
      }
      function ut(t) {
        var e, n = t.popper, r = t.popperRect, o2 = t.placement, i = t.variation, a2 = t.offsets, s2 = t.position, f2 = t.gpuAcceleration, c2 = t.adaptive, u2 = t.roundOffsets, m2 = t.isFixed, v2 = a2.x, l2 = v2 === void 0 ? 0 : v2, h2 = a2.y, p2 = h2 === void 0 ? 0 : h2, g = typeof u2 == "function" ? u2({ x: l2, y: p2 }) : { x: l2, y: p2 };
        l2 = g.x, p2 = g.y;
        var x2 = a2.hasOwnProperty("x"), y = a2.hasOwnProperty("y"), $ = P$1, d2 = E$1, b2 = window;
        if (c2) {
          var w2 = se(n), O2 = "clientHeight", j = "clientWidth";
          if (w2 === H(n) && (w2 = I$1(n), N$1(w2).position !== "static" && s2 === "absolute" && (O2 = "scrollHeight", j = "scrollWidth")), w2 = w2, o2 === E$1 || (o2 === P$1 || o2 === W) && i === J) {
            d2 = R;
            var A2 = m2 && w2 === b2 && b2.visualViewport ? b2.visualViewport.height : w2[O2];
            p2 -= A2 - r.height, p2 *= f2 ? 1 : -1;
          }
          if (o2 === P$1 || (o2 === E$1 || o2 === R) && i === J) {
            $ = W;
            var k = m2 && w2 === b2 && b2.visualViewport ? b2.visualViewport.width : w2[j];
            l2 -= k - r.width, l2 *= f2 ? 1 : -1;
          }
        }
        var D2 = Object.assign({ position: s2 }, c2 && qt), S2 = u2 === true ? Vt({ x: l2, y: p2 }) : { x: l2, y: p2 };
        if (l2 = S2.x, p2 = S2.y, f2) {
          var L;
          return Object.assign({}, D2, (L = {}, L[d2] = y ? "0" : "", L[$] = x2 ? "0" : "", L.transform = (b2.devicePixelRatio || 1) <= 1 ? "translate(" + l2 + "px, " + p2 + "px)" : "translate3d(" + l2 + "px, " + p2 + "px, 0)", L));
        }
        return Object.assign({}, D2, (e = {}, e[d2] = y ? p2 + "px" : "", e[$] = x2 ? l2 + "px" : "", e.transform = "", e));
      }
      function Nt(t) {
        var e = t.state, n = t.options, r = n.gpuAcceleration, o2 = r === void 0 ? true : r, i = n.adaptive, a2 = i === void 0 ? true : i, s2 = n.roundOffsets, f2 = s2 === void 0 ? true : s2, c2 = { placement: q(e.placement), variation: te(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: o2, isFixed: e.options.strategy === "fixed" };
        e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, ut(Object.assign({}, c2, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: a2, roundOffsets: f2 })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, ut(Object.assign({}, c2, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: f2 })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
      }
      var Me = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: Nt, data: {} }, ye = { passive: true };
      function It(t) {
        var e = t.state, n = t.instance, r = t.options, o2 = r.scroll, i = o2 === void 0 ? true : o2, a2 = r.resize, s2 = a2 === void 0 ? true : a2, f2 = H(e.elements.popper), c2 = [].concat(e.scrollParents.reference, e.scrollParents.popper);
        return i && c2.forEach(function(u2) {
          u2.addEventListener("scroll", n.update, ye);
        }), s2 && f2.addEventListener("resize", n.update, ye), function() {
          i && c2.forEach(function(u2) {
            u2.removeEventListener("scroll", n.update, ye);
          }), s2 && f2.removeEventListener("resize", n.update, ye);
        };
      }
      var Re = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
      }, effect: It, data: {} }, _t = { left: "right", right: "left", bottom: "top", top: "bottom" };
      function be(t) {
        return t.replace(/left|right|bottom|top/g, function(e) {
          return _t[e];
        });
      }
      var zt = { start: "end", end: "start" };
      function lt(t) {
        return t.replace(/start|end/g, function(e) {
          return zt[e];
        });
      }
      function We(t) {
        var e = H(t), n = e.pageXOffset, r = e.pageYOffset;
        return { scrollLeft: n, scrollTop: r };
      }
      function Be(t) {
        return ee(I$1(t)).left + We(t).scrollLeft;
      }
      function Ft(t) {
        var e = H(t), n = I$1(t), r = e.visualViewport, o2 = n.clientWidth, i = n.clientHeight, a2 = 0, s2 = 0;
        return r && (o2 = r.width, i = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a2 = r.offsetLeft, s2 = r.offsetTop)), { width: o2, height: i, x: a2 + Be(t), y: s2 };
      }
      function Ut(t) {
        var e, n = I$1(t), r = We(t), o2 = (e = t.ownerDocument) == null ? void 0 : e.body, i = X$1(n.scrollWidth, n.clientWidth, o2 ? o2.scrollWidth : 0, o2 ? o2.clientWidth : 0), a2 = X$1(n.scrollHeight, n.clientHeight, o2 ? o2.scrollHeight : 0, o2 ? o2.clientHeight : 0), s2 = -r.scrollLeft + Be(t), f2 = -r.scrollTop;
        return N$1(o2 || n).direction === "rtl" && (s2 += X$1(n.clientWidth, o2 ? o2.clientWidth : 0) - i), { width: i, height: a2, x: s2, y: f2 };
      }
      function Se(t) {
        var e = N$1(t), n = e.overflow, r = e.overflowX, o2 = e.overflowY;
        return /auto|scroll|overlay|hidden/.test(n + o2 + r);
      }
      function dt(t) {
        return ["html", "body", "#document"].indexOf(C(t)) >= 0 ? t.ownerDocument.body : B(t) && Se(t) ? t : dt(ge(t));
      }
      function ce(t, e) {
        var n;
        e === void 0 && (e = []);
        var r = dt(t), o2 = r === ((n = t.ownerDocument) == null ? void 0 : n.body), i = H(r), a2 = o2 ? [i].concat(i.visualViewport || [], Se(r) ? r : []) : r, s2 = e.concat(a2);
        return o2 ? s2 : s2.concat(ce(ge(a2)));
      }
      function Te(t) {
        return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height });
      }
      function Xt(t) {
        var e = ee(t);
        return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;
      }
      function ht(t, e) {
        return e === je ? Te(Ft(t)) : Q(e) ? Xt(e) : Te(Ut(I$1(t)));
      }
      function Yt(t) {
        var e = ce(ge(t)), n = ["absolute", "fixed"].indexOf(N$1(t).position) >= 0, r = n && B(t) ? se(t) : t;
        return Q(r) ? e.filter(function(o2) {
          return Q(o2) && it(o2, r) && C(o2) !== "body";
        }) : [];
      }
      function Gt(t, e, n) {
        var r = e === "clippingParents" ? Yt(t) : [].concat(e), o2 = [].concat(r, [n]), i = o2[0], a2 = o2.reduce(function(s2, f2) {
          var c2 = ht(t, f2);
          return s2.top = X$1(c2.top, s2.top), s2.right = ve(c2.right, s2.right), s2.bottom = ve(c2.bottom, s2.bottom), s2.left = X$1(c2.left, s2.left), s2;
        }, ht(t, i));
        return a2.width = a2.right - a2.left, a2.height = a2.bottom - a2.top, a2.x = a2.left, a2.y = a2.top, a2;
      }
      function mt(t) {
        var e = t.reference, n = t.element, r = t.placement, o2 = r ? q(r) : null, i = r ? te(r) : null, a2 = e.x + e.width / 2 - n.width / 2, s2 = e.y + e.height / 2 - n.height / 2, f2;
        switch (o2) {
          case E$1:
            f2 = { x: a2, y: e.y - n.height };
            break;
          case R:
            f2 = { x: a2, y: e.y + e.height };
            break;
          case W:
            f2 = { x: e.x + e.width, y: s2 };
            break;
          case P$1:
            f2 = { x: e.x - n.width, y: s2 };
            break;
          default:
            f2 = { x: e.x, y: e.y };
        }
        var c2 = o2 ? Le(o2) : null;
        if (c2 != null) {
          var u2 = c2 === "y" ? "height" : "width";
          switch (i) {
            case U$1:
              f2[c2] = f2[c2] - (e[u2] / 2 - n[u2] / 2);
              break;
            case J:
              f2[c2] = f2[c2] + (e[u2] / 2 - n[u2] / 2);
              break;
          }
        }
        return f2;
      }
      function ne(t, e) {
        e === void 0 && (e = {});
        var n = e, r = n.placement, o2 = r === void 0 ? t.placement : r, i = n.boundary, a2 = i === void 0 ? Xe : i, s2 = n.rootBoundary, f2 = s2 === void 0 ? je : s2, c2 = n.elementContext, u2 = c2 === void 0 ? K : c2, m2 = n.altBoundary, v2 = m2 === void 0 ? false : m2, l2 = n.padding, h2 = l2 === void 0 ? 0 : l2, p2 = ft(typeof h2 != "number" ? h2 : ct(h2, G)), g = u2 === K ? Ye : K, x2 = t.rects.popper, y = t.elements[v2 ? g : u2], $ = Gt(Q(y) ? y : y.contextElement || I$1(t.elements.popper), a2, f2), d2 = ee(t.elements.reference), b2 = mt({ reference: d2, element: x2, strategy: "absolute", placement: o2 }), w2 = Te(Object.assign({}, x2, b2)), O2 = u2 === K ? w2 : d2, j = { top: $.top - O2.top + p2.top, bottom: O2.bottom - $.bottom + p2.bottom, left: $.left - O2.left + p2.left, right: O2.right - $.right + p2.right }, A2 = t.modifiersData.offset;
        if (u2 === K && A2) {
          var k = A2[o2];
          Object.keys(j).forEach(function(D2) {
            var S2 = [W, R].indexOf(D2) >= 0 ? 1 : -1, L = [E$1, R].indexOf(D2) >= 0 ? "y" : "x";
            j[D2] += k[L] * S2;
          });
        }
        return j;
      }
      function Jt(t, e) {
        e === void 0 && (e = {});
        var n = e, r = n.placement, o2 = n.boundary, i = n.rootBoundary, a2 = n.padding, s2 = n.flipVariations, f2 = n.allowedAutoPlacements, c2 = f2 === void 0 ? Ee : f2, u2 = te(r), m2 = u2 ? s2 ? De : De.filter(function(h2) {
          return te(h2) === u2;
        }) : G, v2 = m2.filter(function(h2) {
          return c2.indexOf(h2) >= 0;
        });
        v2.length === 0 && (v2 = m2);
        var l2 = v2.reduce(function(h2, p2) {
          return h2[p2] = ne(t, { placement: p2, boundary: o2, rootBoundary: i, padding: a2 })[q(p2)], h2;
        }, {});
        return Object.keys(l2).sort(function(h2, p2) {
          return l2[h2] - l2[p2];
        });
      }
      function Kt(t) {
        if (q(t) === me)
          return [];
        var e = be(t);
        return [lt(t), e, lt(e)];
      }
      function Qt(t) {
        var e = t.state, n = t.options, r = t.name;
        if (!e.modifiersData[r]._skip) {
          for (var o2 = n.mainAxis, i = o2 === void 0 ? true : o2, a2 = n.altAxis, s2 = a2 === void 0 ? true : a2, f2 = n.fallbackPlacements, c2 = n.padding, u2 = n.boundary, m2 = n.rootBoundary, v2 = n.altBoundary, l2 = n.flipVariations, h2 = l2 === void 0 ? true : l2, p2 = n.allowedAutoPlacements, g = e.options.placement, x2 = q(g), y = x2 === g, $ = f2 || (y || !h2 ? [be(g)] : Kt(g)), d2 = [g].concat($).reduce(function(z, V) {
            return z.concat(q(V) === me ? Jt(e, { placement: V, boundary: u2, rootBoundary: m2, padding: c2, flipVariations: h2, allowedAutoPlacements: p2 }) : V);
          }, []), b2 = e.rects.reference, w2 = e.rects.popper, O2 = /* @__PURE__ */ new Map(), j = true, A2 = d2[0], k = 0; k < d2.length; k++) {
            var D2 = d2[k], S2 = q(D2), L = te(D2) === U$1, re = [E$1, R].indexOf(S2) >= 0, oe = re ? "width" : "height", M2 = ne(e, { placement: D2, boundary: u2, rootBoundary: m2, altBoundary: v2, padding: c2 }), T2 = re ? L ? W : P$1 : L ? R : E$1;
            b2[oe] > w2[oe] && (T2 = be(T2));
            var pe = be(T2), _2 = [];
            if (i && _2.push(M2[S2] <= 0), s2 && _2.push(M2[T2] <= 0, M2[pe] <= 0), _2.every(function(z) {
              return z;
            })) {
              A2 = D2, j = false;
              break;
            }
            O2.set(D2, _2);
          }
          if (j)
            for (var ue = h2 ? 3 : 1, xe = function(z) {
              var V = d2.find(function(de) {
                var ae = O2.get(de);
                if (ae)
                  return ae.slice(0, z).every(function(Y2) {
                    return Y2;
                  });
              });
              if (V)
                return A2 = V, "break";
            }, ie = ue; ie > 0; ie--) {
              var le = xe(ie);
              if (le === "break")
                break;
            }
          e.placement !== A2 && (e.modifiersData[r]._skip = true, e.placement = A2, e.reset = true);
        }
      }
      var vt = { name: "flip", enabled: true, phase: "main", fn: Qt, requiresIfExists: ["offset"], data: { _skip: false } };
      function gt(t, e, n) {
        return n === void 0 && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x };
      }
      function yt(t) {
        return [E$1, W, R, P$1].some(function(e) {
          return t[e] >= 0;
        });
      }
      function Zt(t) {
        var e = t.state, n = t.name, r = e.rects.reference, o2 = e.rects.popper, i = e.modifiersData.preventOverflow, a2 = ne(e, { elementContext: "reference" }), s2 = ne(e, { altBoundary: true }), f2 = gt(a2, r), c2 = gt(s2, o2, i), u2 = yt(f2), m2 = yt(c2);
        e.modifiersData[n] = { referenceClippingOffsets: f2, popperEscapeOffsets: c2, isReferenceHidden: u2, hasPopperEscaped: m2 }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": u2, "data-popper-escaped": m2 });
      }
      var bt = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: Zt };
      function en(t, e, n) {
        var r = q(t), o2 = [P$1, E$1].indexOf(r) >= 0 ? -1 : 1, i = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n, a2 = i[0], s2 = i[1];
        return a2 = a2 || 0, s2 = (s2 || 0) * o2, [P$1, W].indexOf(r) >= 0 ? { x: s2, y: a2 } : { x: a2, y: s2 };
      }
      function tn(t) {
        var e = t.state, n = t.options, r = t.name, o2 = n.offset, i = o2 === void 0 ? [0, 0] : o2, a2 = Ee.reduce(function(u2, m2) {
          return u2[m2] = en(m2, e.rects, i), u2;
        }, {}), s2 = a2[e.placement], f2 = s2.x, c2 = s2.y;
        e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += f2, e.modifiersData.popperOffsets.y += c2), e.modifiersData[r] = a2;
      }
      var wt = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: tn };
      function nn(t) {
        var e = t.state, n = t.name;
        e.modifiersData[n] = mt({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement });
      }
      var He = { name: "popperOffsets", enabled: true, phase: "read", fn: nn, data: {} };
      function rn(t) {
        return t === "x" ? "y" : "x";
      }
      function on(t) {
        var e = t.state, n = t.options, r = t.name, o2 = n.mainAxis, i = o2 === void 0 ? true : o2, a2 = n.altAxis, s2 = a2 === void 0 ? false : a2, f2 = n.boundary, c2 = n.rootBoundary, u2 = n.altBoundary, m2 = n.padding, v2 = n.tether, l2 = v2 === void 0 ? true : v2, h2 = n.tetherOffset, p2 = h2 === void 0 ? 0 : h2, g = ne(e, { boundary: f2, rootBoundary: c2, padding: m2, altBoundary: u2 }), x2 = q(e.placement), y = te(e.placement), $ = !y, d2 = Le(x2), b2 = rn(d2), w2 = e.modifiersData.popperOffsets, O2 = e.rects.reference, j = e.rects.popper, A2 = typeof p2 == "function" ? p2(Object.assign({}, e.rects, { placement: e.placement })) : p2, k = typeof A2 == "number" ? { mainAxis: A2, altAxis: A2 } : Object.assign({ mainAxis: 0, altAxis: 0 }, A2), D2 = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, S2 = { x: 0, y: 0 };
        if (w2) {
          if (i) {
            var L, re = d2 === "y" ? E$1 : P$1, oe = d2 === "y" ? R : W, M2 = d2 === "y" ? "height" : "width", T2 = w2[d2], pe = T2 + g[re], _2 = T2 - g[oe], ue = l2 ? -j[M2] / 2 : 0, xe = y === U$1 ? O2[M2] : j[M2], ie = y === U$1 ? -j[M2] : -O2[M2], le = e.elements.arrow, z = l2 && le ? ke(le) : { width: 0, height: 0 }, V = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : st(), de = V[re], ae = V[oe], Y2 = fe(0, O2[M2], z[M2]), jt = $ ? O2[M2] / 2 - ue - Y2 - de - k.mainAxis : xe - Y2 - de - k.mainAxis, Dt = $ ? -O2[M2] / 2 + ue + Y2 + ae + k.mainAxis : ie + Y2 + ae + k.mainAxis, Oe = e.elements.arrow && se(e.elements.arrow), Et = Oe ? d2 === "y" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Ce = (L = D2 == null ? void 0 : D2[d2]) != null ? L : 0, Pt = T2 + jt - Ce - Et, At = T2 + Dt - Ce, qe = fe(l2 ? ve(pe, Pt) : pe, T2, l2 ? X$1(_2, At) : _2);
            w2[d2] = qe, S2[d2] = qe - T2;
          }
          if (s2) {
            var Ve, kt = d2 === "x" ? E$1 : P$1, Lt = d2 === "x" ? R : W, F2 = w2[b2], he = b2 === "y" ? "height" : "width", Ne = F2 + g[kt], Ie = F2 - g[Lt], $e = [E$1, P$1].indexOf(x2) !== -1, _e = (Ve = D2 == null ? void 0 : D2[b2]) != null ? Ve : 0, ze = $e ? Ne : F2 - O2[he] - j[he] - _e + k.altAxis, Fe = $e ? F2 + O2[he] + j[he] - _e - k.altAxis : Ie, Ue = l2 && $e ? St(ze, F2, Fe) : fe(l2 ? ze : Ne, F2, l2 ? Fe : Ie);
            w2[b2] = Ue, S2[b2] = Ue - F2;
          }
          e.modifiersData[r] = S2;
        }
      }
      var xt = { name: "preventOverflow", enabled: true, phase: "main", fn: on, requiresIfExists: ["offset"] };
      function an(t) {
        return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
      }
      function sn(t) {
        return t === H(t) || !B(t) ? We(t) : an(t);
      }
      function fn(t) {
        var e = t.getBoundingClientRect(), n = Z(e.width) / t.offsetWidth || 1, r = Z(e.height) / t.offsetHeight || 1;
        return n !== 1 || r !== 1;
      }
      function cn(t, e, n) {
        n === void 0 && (n = false);
        var r = B(e), o2 = B(e) && fn(e), i = I$1(e), a2 = ee(t, o2), s2 = { scrollLeft: 0, scrollTop: 0 }, f2 = { x: 0, y: 0 };
        return (r || !r && !n) && ((C(e) !== "body" || Se(i)) && (s2 = sn(e)), B(e) ? (f2 = ee(e, true), f2.x += e.clientLeft, f2.y += e.clientTop) : i && (f2.x = Be(i))), { x: a2.left + s2.scrollLeft - f2.x, y: a2.top + s2.scrollTop - f2.y, width: a2.width, height: a2.height };
      }
      function pn(t) {
        var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
        t.forEach(function(i) {
          e.set(i.name, i);
        });
        function o2(i) {
          n.add(i.name);
          var a2 = [].concat(i.requires || [], i.requiresIfExists || []);
          a2.forEach(function(s2) {
            if (!n.has(s2)) {
              var f2 = e.get(s2);
              f2 && o2(f2);
            }
          }), r.push(i);
        }
        return t.forEach(function(i) {
          n.has(i.name) || o2(i);
        }), r;
      }
      function un(t) {
        var e = pn(t);
        return ot.reduce(function(n, r) {
          return n.concat(e.filter(function(o2) {
            return o2.phase === r;
          }));
        }, []);
      }
      function ln(t) {
        var e;
        return function() {
          return e || (e = new Promise(function(n) {
            Promise.resolve().then(function() {
              e = void 0, n(t());
            });
          })), e;
        };
      }
      function dn(t) {
        var e = t.reduce(function(n, r) {
          var o2 = n[r.name];
          return n[r.name] = o2 ? Object.assign({}, o2, r, { options: Object.assign({}, o2.options, r.options), data: Object.assign({}, o2.data, r.data) }) : r, n;
        }, {});
        return Object.keys(e).map(function(n) {
          return e[n];
        });
      }
      var Ot = { placement: "bottom", modifiers: [], strategy: "absolute" };
      function $t() {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
          e[n] = arguments[n];
        return !e.some(function(r) {
          return !(r && typeof r.getBoundingClientRect == "function");
        });
      }
      function we(t) {
        t === void 0 && (t = {});
        var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, o2 = e.defaultOptions, i = o2 === void 0 ? Ot : o2;
        return function(a2, s2, f2) {
          f2 === void 0 && (f2 = i);
          var c2 = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ot, i), modifiersData: {}, elements: { reference: a2, popper: s2 }, attributes: {}, styles: {} }, u2 = [], m2 = false, v2 = { state: c2, setOptions: function(p2) {
            var g = typeof p2 == "function" ? p2(c2.options) : p2;
            h2(), c2.options = Object.assign({}, i, c2.options, g), c2.scrollParents = { reference: Q(a2) ? ce(a2) : a2.contextElement ? ce(a2.contextElement) : [], popper: ce(s2) };
            var x2 = un(dn([].concat(r, c2.options.modifiers)));
            return c2.orderedModifiers = x2.filter(function(y) {
              return y.enabled;
            }), l2(), v2.update();
          }, forceUpdate: function() {
            if (!m2) {
              var p2 = c2.elements, g = p2.reference, x2 = p2.popper;
              if ($t(g, x2)) {
                c2.rects = { reference: cn(g, se(x2), c2.options.strategy === "fixed"), popper: ke(x2) }, c2.reset = false, c2.placement = c2.options.placement, c2.orderedModifiers.forEach(function(j) {
                  return c2.modifiersData[j.name] = Object.assign({}, j.data);
                });
                for (var y = 0; y < c2.orderedModifiers.length; y++) {
                  if (c2.reset === true) {
                    c2.reset = false, y = -1;
                    continue;
                  }
                  var $ = c2.orderedModifiers[y], d2 = $.fn, b2 = $.options, w2 = b2 === void 0 ? {} : b2, O2 = $.name;
                  typeof d2 == "function" && (c2 = d2({ state: c2, options: w2, name: O2, instance: v2 }) || c2);
                }
              }
            }
          }, update: ln(function() {
            return new Promise(function(p2) {
              v2.forceUpdate(), p2(c2);
            });
          }), destroy: function() {
            h2(), m2 = true;
          } };
          if (!$t(a2, s2))
            return v2;
          v2.setOptions(f2).then(function(p2) {
            !m2 && f2.onFirstUpdate && f2.onFirstUpdate(p2);
          });
          function l2() {
            c2.orderedModifiers.forEach(function(p2) {
              var g = p2.name, x2 = p2.options, y = x2 === void 0 ? {} : x2, $ = p2.effect;
              if (typeof $ == "function") {
                var d2 = $({ state: c2, name: g, instance: v2, options: y }), b2 = function() {
                };
                u2.push(d2 || b2);
              }
            });
          }
          function h2() {
            u2.forEach(function(p2) {
              return p2();
            }), u2 = [];
          }
          return v2;
        };
      }
      we();
      var mn = [Re, He, Me, Ae];
      we({ defaultModifiers: mn });
      var gn = [Re, He, Me, Ae, wt, vt, xt, pt, bt], yn = we({ defaultModifiers: gn });
      const usePopper = (referenceElementRef, popperElementRef, opts = {}) => {
        const stateUpdater = {
          name: "updateState",
          enabled: true,
          phase: "write",
          fn: ({ state }) => {
            const derivedState = deriveState(state);
            Object.assign(states.value, derivedState);
          },
          requires: ["computeStyles"]
        };
        const options = computed$1(() => {
          const { onFirstUpdate, placement, strategy, modifiers } = unref(opts);
          return {
            onFirstUpdate,
            placement: placement || "bottom",
            strategy: strategy || "absolute",
            modifiers: [
              ...modifiers || [],
              stateUpdater,
              { name: "applyStyles", enabled: false }
            ]
          };
        });
        const instanceRef = shallowRef();
        const states = ref({
          styles: {
            popper: {
              position: unref(options).strategy,
              left: "0",
              top: "0"
            },
            arrow: {
              position: "absolute"
            }
          },
          attributes: {}
        });
        const destroy = () => {
          if (!instanceRef.value)
            return;
          instanceRef.value.destroy();
          instanceRef.value = void 0;
        };
        watch(options, (newOptions) => {
          const instance = unref(instanceRef);
          if (instance) {
            instance.setOptions(newOptions);
          }
        }, {
          deep: true
        });
        watch([referenceElementRef, popperElementRef], ([referenceElement, popperElement]) => {
          destroy();
          if (!referenceElement || !popperElement)
            return;
          instanceRef.value = yn(referenceElement, popperElement, unref(options));
        });
        onBeforeUnmount(() => {
          destroy();
        });
        return {
          state: computed$1(() => {
            var _a2;
            return { ...((_a2 = unref(instanceRef)) == null ? void 0 : _a2.state) || {} };
          }),
          styles: computed$1(() => unref(states).styles),
          attributes: computed$1(() => unref(states).attributes),
          update: () => {
            var _a2;
            return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.update();
          },
          forceUpdate: () => {
            var _a2;
            return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.forceUpdate();
          },
          instanceRef: computed$1(() => unref(instanceRef))
        };
      };
      function deriveState(state) {
        const elements = Object.keys(state.elements);
        const styles = fromPairs(elements.map((element) => [element, state.styles[element] || {}]));
        const attributes = fromPairs(elements.map((element) => [element, state.attributes[element]]));
        return {
          styles,
          attributes
        };
      }
      const useSameTarget = (handleClick) => {
        if (!handleClick) {
          return { onClick: NOOP, onMousedown: NOOP, onMouseup: NOOP };
        }
        let mousedownTarget = false;
        let mouseupTarget = false;
        const onClick = (e) => {
          if (mousedownTarget && mouseupTarget) {
            handleClick(e);
          }
          mousedownTarget = mouseupTarget = false;
        };
        const onMousedown = (e) => {
          mousedownTarget = e.target === e.currentTarget;
        };
        const onMouseup = (e) => {
          mouseupTarget = e.target === e.currentTarget;
        };
        return { onClick, onMousedown, onMouseup };
      };
      function useTimeout() {
        let timeoutHandle;
        const registerTimeout = (fn2, delay) => {
          cancelTimeout();
          timeoutHandle = window.setTimeout(fn2, delay);
        };
        const cancelTimeout = () => window.clearTimeout(timeoutHandle);
        tryOnScopeDispose(() => cancelTimeout());
        return {
          registerTimeout,
          cancelTimeout
        };
      }
      const defaultIdInjection = {
        prefix: Math.floor(Math.random() * 1e4),
        current: 0
      };
      const ID_INJECTION_KEY = Symbol("elIdInjection");
      const useIdInjection = exports("aB", () => {
        return getCurrentInstance() ? inject(ID_INJECTION_KEY, defaultIdInjection) : defaultIdInjection;
      });
      const useId = exports("q", (deterministicId) => {
        const idInjection = useIdInjection();
        const namespace = useGetDerivedNamespace();
        const idRef = computed$1(() => unref(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`);
        return idRef;
      });
      let registeredEscapeHandlers = [];
      const cachedHandler = (e) => {
        const event = e;
        if (event.key === EVENT_CODE.esc) {
          registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
        }
      };
      const useEscapeKeydown = (handler) => {
        onMounted(() => {
          if (registeredEscapeHandlers.length === 0) {
            document.addEventListener("keydown", cachedHandler);
          }
          if (isClient)
            registeredEscapeHandlers.push(handler);
        });
        onBeforeUnmount(() => {
          registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
          if (registeredEscapeHandlers.length === 0) {
            if (isClient)
              document.removeEventListener("keydown", cachedHandler);
          }
        });
      };
      let cachedContainer;
      const usePopperContainerId = () => {
        const namespace = useGetDerivedNamespace();
        const idInjection = useIdInjection();
        const id = computed$1(() => {
          return `${namespace.value}-popper-container-${idInjection.prefix}`;
        });
        const selector = computed$1(() => `#${id.value}`);
        return {
          id,
          selector
        };
      };
      const createContainer = (id) => {
        const container = document.createElement("div");
        container.id = id;
        document.body.appendChild(container);
        return container;
      };
      const usePopperContainer = () => {
        const { id, selector } = usePopperContainerId();
        onBeforeMount(() => {
          if (!isClient)
            return;
          if (!cachedContainer && !document.body.querySelector(selector.value)) {
            cachedContainer = createContainer(id.value);
          }
        });
        return {
          id,
          selector
        };
      };
      const useDelayedToggleProps = buildProps({
        showAfter: {
          type: Number,
          default: 0
        },
        hideAfter: {
          type: Number,
          default: 200
        },
        autoClose: {
          type: Number,
          default: 0
        }
      });
      const useDelayedToggle = ({
        showAfter,
        hideAfter,
        autoClose,
        open,
        close
      }) => {
        const { registerTimeout } = useTimeout();
        const {
          registerTimeout: registerTimeoutForAutoClose,
          cancelTimeout: cancelTimeoutForAutoClose
        } = useTimeout();
        const onOpen = (event) => {
          registerTimeout(() => {
            open(event);
            const _autoClose = unref(autoClose);
            if (isNumber(_autoClose) && _autoClose > 0) {
              registerTimeoutForAutoClose(() => {
                close(event);
              }, _autoClose);
            }
          }, unref(showAfter));
        };
        const onClose = (event) => {
          cancelTimeoutForAutoClose();
          registerTimeout(() => {
            close(event);
          }, unref(hideAfter));
        };
        return {
          onOpen,
          onClose
        };
      };
      const FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
      const useForwardRef = (forwardRef) => {
        const setForwardRef = (el) => {
          forwardRef.value = el;
        };
        provide(FORWARD_REF_INJECTION_KEY, {
          setForwardRef
        });
      };
      const useForwardRefDirective = (setForwardRef) => {
        return {
          mounted(el) {
            setForwardRef(el);
          },
          updated(el) {
            setForwardRef(el);
          },
          unmounted() {
            setForwardRef(null);
          }
        };
      };
      const initial = {
        current: 0
      };
      const zIndex = ref(0);
      const defaultInitialZIndex = 2e3;
      const ZINDEX_INJECTION_KEY = Symbol("elZIndexContextKey");
      const zIndexContextKey = Symbol("zIndexContextKey");
      const useZIndex = (zIndexOverrides) => {
        const increasingInjection = getCurrentInstance() ? inject(ZINDEX_INJECTION_KEY, initial) : initial;
        const zIndexInjection = zIndexOverrides || (getCurrentInstance() ? inject(zIndexContextKey, void 0) : void 0);
        const initialZIndex = computed$1(() => {
          const zIndexFromInjection = unref(zIndexInjection);
          return isNumber(zIndexFromInjection) ? zIndexFromInjection : defaultInitialZIndex;
        });
        const currentZIndex = computed$1(() => initialZIndex.value + zIndex.value);
        const nextZIndex = () => {
          increasingInjection.current++;
          zIndex.value = increasingInjection.current;
          return currentZIndex.value;
        };
        if (!isClient && !inject(ZINDEX_INJECTION_KEY))
          ;
        return {
          initialZIndex,
          currentZIndex,
          nextZIndex
        };
      };
      function useCursor(input) {
        const selectionRef = ref();
        function recordCursor() {
          if (input.value == void 0)
            return;
          const { selectionStart, selectionEnd, value } = input.value;
          if (selectionStart == null || selectionEnd == null)
            return;
          const beforeTxt = value.slice(0, Math.max(0, selectionStart));
          const afterTxt = value.slice(Math.max(0, selectionEnd));
          selectionRef.value = {
            selectionStart,
            selectionEnd,
            value,
            beforeTxt,
            afterTxt
          };
        }
        function setCursor() {
          if (input.value == void 0 || selectionRef.value == void 0)
            return;
          const { value } = input.value;
          const { beforeTxt, afterTxt, selectionStart } = selectionRef.value;
          if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
            return;
          let startPos = value.length;
          if (value.endsWith(afterTxt)) {
            startPos = value.length - afterTxt.length;
          } else if (value.startsWith(beforeTxt)) {
            startPos = beforeTxt.length;
          } else {
            const beforeLastChar = beforeTxt[selectionStart - 1];
            const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
            if (newIndex !== -1) {
              startPos = newIndex + 1;
            }
          }
          input.value.setSelectionRange(startPos, startPos);
        }
        return [recordCursor, setCursor];
      }
      const useSizeProp = exports("F", buildProp({
        type: String,
        values: componentSizes,
        required: false
      }));
      const SIZE_INJECTION_KEY = Symbol("size");
      const useGlobalSize = () => {
        const injectedSize = inject(SIZE_INJECTION_KEY, {});
        return computed$1(() => {
          return unref(injectedSize.size) || "";
        });
      };
      function useFocusController(target, { afterFocus, beforeBlur, afterBlur } = {}) {
        const instance = getCurrentInstance();
        const { emit } = instance;
        const wrapperRef = shallowRef();
        const isFocused = ref(false);
        const handleFocus = (event) => {
          if (isFocused.value)
            return;
          isFocused.value = true;
          emit("focus", event);
          afterFocus == null ? void 0 : afterFocus();
        };
        const handleBlur = (event) => {
          var _a2;
          const cancelBlur = isFunction$1(beforeBlur) ? beforeBlur(event) : false;
          if (cancelBlur || event.relatedTarget && ((_a2 = wrapperRef.value) == null ? void 0 : _a2.contains(event.relatedTarget)))
            return;
          isFocused.value = false;
          emit("blur", event);
          afterBlur == null ? void 0 : afterBlur();
        };
        const handleClick = () => {
          var _a2;
          (_a2 = target.value) == null ? void 0 : _a2.focus();
        };
        watch(wrapperRef, (el) => {
          if (el) {
            el.setAttribute("tabindex", "-1");
          }
        });
        useEventListener(wrapperRef, "click", handleClick);
        return {
          wrapperRef,
          isFocused,
          handleFocus,
          handleBlur
        };
      }
      const configProviderContextKey = Symbol();
      const globalConfig = ref();
      function useGlobalConfig(key, defaultValue = void 0) {
        const config = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;
        if (key) {
          return computed$1(() => {
            var _a2, _b;
            return (_b = (_a2 = config.value) == null ? void 0 : _a2[key]) != null ? _b : defaultValue;
          });
        } else {
          return config;
        }
      }
      function useGlobalComponentSettings(block, sizeFallback) {
        const config = useGlobalConfig();
        const ns = useNamespace(block, computed$1(() => {
          var _a2;
          return ((_a2 = config.value) == null ? void 0 : _a2.namespace) || defaultNamespace;
        }));
        const locale = useLocale(computed$1(() => {
          var _a2;
          return (_a2 = config.value) == null ? void 0 : _a2.locale;
        }));
        const zIndex2 = useZIndex(computed$1(() => {
          var _a2;
          return ((_a2 = config.value) == null ? void 0 : _a2.zIndex) || defaultInitialZIndex;
        }));
        const size = computed$1(() => {
          var _a2;
          return unref(sizeFallback) || ((_a2 = config.value) == null ? void 0 : _a2.size) || "";
        });
        provideGlobalConfig(computed$1(() => unref(config) || {}));
        return {
          ns,
          locale,
          zIndex: zIndex2,
          size
        };
      }
      const provideGlobalConfig = (config, app2, global2 = false) => {
        var _a2;
        const inSetup = !!getCurrentInstance();
        const oldConfig = inSetup ? useGlobalConfig() : void 0;
        const provideFn = (_a2 = app2 == null ? void 0 : app2.provide) != null ? _a2 : inSetup ? provide : void 0;
        if (!provideFn) {
          return;
        }
        const context = computed$1(() => {
          const cfg = unref(config);
          if (!(oldConfig == null ? void 0 : oldConfig.value))
            return cfg;
          return mergeConfig(oldConfig.value, cfg);
        });
        provideFn(configProviderContextKey, context);
        provideFn(localeContextKey, computed$1(() => context.value.locale));
        provideFn(namespaceContextKey, computed$1(() => context.value.namespace));
        provideFn(zIndexContextKey, computed$1(() => context.value.zIndex));
        provideFn(SIZE_INJECTION_KEY, {
          size: computed$1(() => context.value.size || "")
        });
        if (global2 || !globalConfig.value) {
          globalConfig.value = context.value;
        }
        return context;
      };
      const mergeConfig = (a2, b2) => {
        const keys2 = [.../* @__PURE__ */ new Set([...keysOf(a2), ...keysOf(b2)])];
        const obj = {};
        for (const key of keys2) {
          obj[key] = b2[key] !== void 0 ? b2[key] : a2[key];
        }
        return obj;
      };
      var _export_sfc$1 = exports("ay", (sfc, props) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props) {
          target[key] = val;
        }
        return target;
      });
      const iconProps = buildProps({
        size: {
          type: definePropType([Number, String])
        },
        color: {
          type: String
        }
      });
      const __default__$l = defineComponent({
        name: "ElIcon",
        inheritAttrs: false
      });
      const _sfc_main$w = /* @__PURE__ */ defineComponent({
        ...__default__$l,
        props: iconProps,
        setup(__props) {
          const props = __props;
          const ns = useNamespace("icon");
          const style = computed$1(() => {
            const { size, color } = props;
            if (!size && !color)
              return {};
            return {
              fontSize: isUndefined(size) ? void 0 : addUnit(size),
              "--color": color
            };
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("i", mergeProps({
              class: unref(ns).b(),
              style: unref(style)
            }, _ctx.$attrs), [
              renderSlot(_ctx.$slots, "default")
            ], 16);
          };
        }
      });
      var Icon = /* @__PURE__ */ _export_sfc$1(_sfc_main$w, [["__file", "icon.vue"]]);
      const ElIcon = exports("P", withInstall(Icon));
      const formContextKey = exports("m", Symbol("formContextKey"));
      const formItemContextKey = exports("o", Symbol("formItemContextKey"));
      const useFormSize = exports("u", (fallback, ignore = {}) => {
        const emptyRef = ref(void 0);
        const size = ignore.prop ? emptyRef : useProp("size");
        const globalConfig2 = ignore.global ? emptyRef : useGlobalSize();
        const form = ignore.form ? { size: void 0 } : inject(formContextKey, void 0);
        const formItem = ignore.formItem ? { size: void 0 } : inject(formItemContextKey, void 0);
        return computed$1(() => size.value || unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig2.value || "");
      });
      const useFormDisabled = exports("X", (fallback) => {
        const disabled = useProp("disabled");
        const form = inject(formContextKey, void 0);
        return computed$1(() => disabled.value || unref(fallback) || (form == null ? void 0 : form.disabled) || false);
      });
      const useFormItem = exports("H", () => {
        const form = inject(formContextKey, void 0);
        const formItem = inject(formItemContextKey, void 0);
        return {
          form,
          formItem
        };
      });
      const useFormItemInputId = exports("ao", (props, {
        formItemContext,
        disableIdGeneration,
        disableIdManagement
      }) => {
        if (!disableIdGeneration) {
          disableIdGeneration = ref(false);
        }
        if (!disableIdManagement) {
          disableIdManagement = ref(false);
        }
        const inputId = ref();
        let idUnwatch = void 0;
        const isLabeledByFormItem = computed$1(() => {
          var _a2;
          return !!(!props.label && formItemContext && formItemContext.inputIds && ((_a2 = formItemContext.inputIds) == null ? void 0 : _a2.length) <= 1);
        });
        onMounted(() => {
          idUnwatch = watch([toRef(props, "id"), disableIdGeneration], ([id, disableIdGeneration2]) => {
            const newId = id != null ? id : !disableIdGeneration2 ? useId().value : void 0;
            if (newId !== inputId.value) {
              if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
                inputId.value && formItemContext.removeInputId(inputId.value);
                if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
                  formItemContext.addInputId(newId);
                }
              }
              inputId.value = newId;
            }
          }, { immediate: true });
        });
        onUnmounted(() => {
          idUnwatch && idUnwatch();
          if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
            inputId.value && formItemContext.removeInputId(inputId.value);
          }
        });
        return {
          isLabeledByFormItem,
          inputId
        };
      });
      let hiddenTextarea = void 0;
      const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  ${isFirefox() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
      const CONTEXT_STYLE = [
        "letter-spacing",
        "line-height",
        "padding-top",
        "padding-bottom",
        "font-family",
        "font-weight",
        "font-size",
        "text-rendering",
        "text-transform",
        "width",
        "text-indent",
        "padding-left",
        "padding-right",
        "border-width",
        "box-sizing"
      ];
      function calculateNodeStyling(targetElement) {
        const style = window.getComputedStyle(targetElement);
        const boxSizing = style.getPropertyValue("box-sizing");
        const paddingSize = Number.parseFloat(style.getPropertyValue("padding-bottom")) + Number.parseFloat(style.getPropertyValue("padding-top"));
        const borderSize = Number.parseFloat(style.getPropertyValue("border-bottom-width")) + Number.parseFloat(style.getPropertyValue("border-top-width"));
        const contextStyle = CONTEXT_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";");
        return { contextStyle, paddingSize, borderSize, boxSizing };
      }
      function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
        var _a2;
        if (!hiddenTextarea) {
          hiddenTextarea = document.createElement("textarea");
          document.body.appendChild(hiddenTextarea);
        }
        const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
        hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
        hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
        let height = hiddenTextarea.scrollHeight;
        const result = {};
        if (boxSizing === "border-box") {
          height = height + borderSize;
        } else if (boxSizing === "content-box") {
          height = height - paddingSize;
        }
        hiddenTextarea.value = "";
        const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
        if (isNumber(minRows)) {
          let minHeight = singleRowHeight * minRows;
          if (boxSizing === "border-box") {
            minHeight = minHeight + paddingSize + borderSize;
          }
          height = Math.max(minHeight, height);
          result.minHeight = `${minHeight}px`;
        }
        if (isNumber(maxRows)) {
          let maxHeight = singleRowHeight * maxRows;
          if (boxSizing === "border-box") {
            maxHeight = maxHeight + paddingSize + borderSize;
          }
          height = Math.min(maxHeight, height);
        }
        result.height = `${height}px`;
        (_a2 = hiddenTextarea.parentNode) == null ? void 0 : _a2.removeChild(hiddenTextarea);
        hiddenTextarea = void 0;
        return result;
      }
      const inputProps = buildProps({
        id: {
          type: String,
          default: void 0
        },
        size: useSizeProp,
        disabled: Boolean,
        modelValue: {
          type: definePropType([
            String,
            Number,
            Object
          ]),
          default: ""
        },
        maxlength: {
          type: [String, Number]
        },
        minlength: {
          type: [String, Number]
        },
        type: {
          type: String,
          default: "text"
        },
        resize: {
          type: String,
          values: ["none", "both", "horizontal", "vertical"]
        },
        autosize: {
          type: definePropType([Boolean, Object]),
          default: false
        },
        autocomplete: {
          type: String,
          default: "off"
        },
        formatter: {
          type: Function
        },
        parser: {
          type: Function
        },
        placeholder: {
          type: String
        },
        form: {
          type: String
        },
        readonly: {
          type: Boolean,
          default: false
        },
        clearable: {
          type: Boolean,
          default: false
        },
        showPassword: {
          type: Boolean,
          default: false
        },
        showWordLimit: {
          type: Boolean,
          default: false
        },
        suffixIcon: {
          type: iconPropType
        },
        prefixIcon: {
          type: iconPropType
        },
        containerRole: {
          type: String,
          default: void 0
        },
        label: {
          type: String,
          default: void 0
        },
        tabindex: {
          type: [String, Number],
          default: 0
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        inputStyle: {
          type: definePropType([Object, Array, String]),
          default: () => mutable({})
        },
        autofocus: {
          type: Boolean,
          default: false
        }
      });
      const inputEmits = {
        [UPDATE_MODEL_EVENT]: (value) => isString(value),
        input: (value) => isString(value),
        change: (value) => isString(value),
        focus: (evt) => evt instanceof FocusEvent,
        blur: (evt) => evt instanceof FocusEvent,
        clear: () => true,
        mouseleave: (evt) => evt instanceof MouseEvent,
        mouseenter: (evt) => evt instanceof MouseEvent,
        keydown: (evt) => evt instanceof Event,
        compositionstart: (evt) => evt instanceof CompositionEvent,
        compositionupdate: (evt) => evt instanceof CompositionEvent,
        compositionend: (evt) => evt instanceof CompositionEvent
      };
      const _hoisted_1$f = ["role"];
      const _hoisted_2$c = ["id", "minlength", "maxlength", "type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus"];
      const _hoisted_3$7 = ["id", "minlength", "maxlength", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus"];
      const __default__$k = defineComponent({
        name: "ElInput",
        inheritAttrs: false
      });
      const _sfc_main$v = /* @__PURE__ */ defineComponent({
        ...__default__$k,
        props: inputProps,
        emits: inputEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const rawAttrs = useAttrs$1();
          const slots = useSlots();
          const containerAttrs = computed$1(() => {
            const comboBoxAttrs = {};
            if (props.containerRole === "combobox") {
              comboBoxAttrs["aria-haspopup"] = rawAttrs["aria-haspopup"];
              comboBoxAttrs["aria-owns"] = rawAttrs["aria-owns"];
              comboBoxAttrs["aria-expanded"] = rawAttrs["aria-expanded"];
            }
            return comboBoxAttrs;
          });
          const containerKls = computed$1(() => [
            props.type === "textarea" ? nsTextarea.b() : nsInput.b(),
            nsInput.m(inputSize.value),
            nsInput.is("disabled", inputDisabled.value),
            nsInput.is("exceed", inputExceed.value),
            {
              [nsInput.b("group")]: slots.prepend || slots.append,
              [nsInput.bm("group", "append")]: slots.append,
              [nsInput.bm("group", "prepend")]: slots.prepend,
              [nsInput.m("prefix")]: slots.prefix || props.prefixIcon,
              [nsInput.m("suffix")]: slots.suffix || props.suffixIcon || props.clearable || props.showPassword,
              [nsInput.bm("suffix", "password-clear")]: showClear.value && showPwdVisible.value,
              [nsInput.b("hidden")]: props.type === "hidden"
            },
            rawAttrs.class
          ]);
          const wrapperKls = computed$1(() => [
            nsInput.e("wrapper"),
            nsInput.is("focus", isFocused.value)
          ]);
          const attrs = useAttrs({
            excludeKeys: computed$1(() => {
              return Object.keys(containerAttrs.value);
            })
          });
          const { form: elForm, formItem: elFormItem } = useFormItem();
          const { inputId } = useFormItemInputId(props, {
            formItemContext: elFormItem
          });
          const inputSize = useFormSize();
          const inputDisabled = useFormDisabled();
          const nsInput = useNamespace("input");
          const nsTextarea = useNamespace("textarea");
          const input = shallowRef();
          const textarea = shallowRef();
          const hovering = ref(false);
          const isComposing = ref(false);
          const passwordVisible = ref(false);
          const countStyle = ref();
          const textareaCalcStyle = shallowRef(props.inputStyle);
          const _ref = computed$1(() => input.value || textarea.value);
          const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(_ref, {
            afterBlur() {
              var _a2;
              if (props.validateEvent) {
                (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "blur").catch((err) => debugWarn());
              }
            }
          });
          const needStatusIcon = computed$1(() => {
            var _a2;
            return (_a2 = elForm == null ? void 0 : elForm.statusIcon) != null ? _a2 : false;
          });
          const validateState = computed$1(() => (elFormItem == null ? void 0 : elFormItem.validateState) || "");
          const validateIcon = computed$1(() => validateState.value && ValidateComponentsMap[validateState.value]);
          const passwordIcon = computed$1(() => passwordVisible.value ? view_default : hide_default);
          const containerStyle = computed$1(() => [
            rawAttrs.style
          ]);
          const textareaStyle = computed$1(() => [
            props.inputStyle,
            textareaCalcStyle.value,
            { resize: props.resize }
          ]);
          const nativeInputValue = computed$1(() => isNil(props.modelValue) ? "" : String(props.modelValue));
          const showClear = computed$1(() => props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (isFocused.value || hovering.value));
          const showPwdVisible = computed$1(() => props.showPassword && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (!!nativeInputValue.value || isFocused.value));
          const isWordLimitVisible = computed$1(() => props.showWordLimit && !!props.maxlength && (props.type === "text" || props.type === "textarea") && !inputDisabled.value && !props.readonly && !props.showPassword);
          const textLength = computed$1(() => nativeInputValue.value.length);
          const inputExceed = computed$1(() => !!isWordLimitVisible.value && textLength.value > Number(props.maxlength));
          const suffixVisible = computed$1(() => !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
          const [recordCursor, setCursor] = useCursor(input);
          useResizeObserver(textarea, (entries) => {
            onceInitSizeTextarea();
            if (!isWordLimitVisible.value || props.resize !== "both")
              return;
            const entry = entries[0];
            const { width } = entry.contentRect;
            countStyle.value = {
              right: `calc(100% - ${width + 15 + 6}px)`
            };
          });
          const resizeTextarea = () => {
            const { type, autosize } = props;
            if (!isClient || type !== "textarea" || !textarea.value)
              return;
            if (autosize) {
              const minRows = isObject$1(autosize) ? autosize.minRows : void 0;
              const maxRows = isObject$1(autosize) ? autosize.maxRows : void 0;
              const textareaStyle2 = calcTextareaHeight(textarea.value, minRows, maxRows);
              textareaCalcStyle.value = {
                overflowY: "hidden",
                ...textareaStyle2
              };
              nextTick(() => {
                textarea.value.offsetHeight;
                textareaCalcStyle.value = textareaStyle2;
              });
            } else {
              textareaCalcStyle.value = {
                minHeight: calcTextareaHeight(textarea.value).minHeight
              };
            }
          };
          const createOnceInitResize = (resizeTextarea2) => {
            let isInit = false;
            return () => {
              var _a2;
              if (isInit || !props.autosize)
                return;
              const isElHidden = ((_a2 = textarea.value) == null ? void 0 : _a2.offsetParent) === null;
              if (!isElHidden) {
                resizeTextarea2();
                isInit = true;
              }
            };
          };
          const onceInitSizeTextarea = createOnceInitResize(resizeTextarea);
          const setNativeInputValue = () => {
            const input2 = _ref.value;
            const formatterValue = props.formatter ? props.formatter(nativeInputValue.value) : nativeInputValue.value;
            if (!input2 || input2.value === formatterValue)
              return;
            input2.value = formatterValue;
          };
          const handleInput = async (event) => {
            recordCursor();
            let { value } = event.target;
            if (props.formatter) {
              value = props.parser ? props.parser(value) : value;
            }
            if (isComposing.value)
              return;
            if (value === nativeInputValue.value) {
              setNativeInputValue();
              return;
            }
            emit(UPDATE_MODEL_EVENT, value);
            emit("input", value);
            await nextTick();
            setNativeInputValue();
            setCursor();
          };
          const handleChange = (event) => {
            emit("change", event.target.value);
          };
          const handleCompositionStart = (event) => {
            emit("compositionstart", event);
            isComposing.value = true;
          };
          const handleCompositionUpdate = (event) => {
            var _a2;
            emit("compositionupdate", event);
            const text = (_a2 = event.target) == null ? void 0 : _a2.value;
            const lastCharacter = text[text.length - 1] || "";
            isComposing.value = !isKorean(lastCharacter);
          };
          const handleCompositionEnd = (event) => {
            emit("compositionend", event);
            if (isComposing.value) {
              isComposing.value = false;
              handleInput(event);
            }
          };
          const handlePasswordVisible = () => {
            passwordVisible.value = !passwordVisible.value;
            focus();
          };
          const focus = async () => {
            var _a2;
            await nextTick();
            (_a2 = _ref.value) == null ? void 0 : _a2.focus();
          };
          const blur = () => {
            var _a2;
            return (_a2 = _ref.value) == null ? void 0 : _a2.blur();
          };
          const handleMouseLeave = (evt) => {
            hovering.value = false;
            emit("mouseleave", evt);
          };
          const handleMouseEnter = (evt) => {
            hovering.value = true;
            emit("mouseenter", evt);
          };
          const handleKeydown = (evt) => {
            emit("keydown", evt);
          };
          const select = () => {
            var _a2;
            (_a2 = _ref.value) == null ? void 0 : _a2.select();
          };
          const clear = () => {
            emit(UPDATE_MODEL_EVENT, "");
            emit("change", "");
            emit("clear");
            emit("input", "");
          };
          watch(() => props.modelValue, () => {
            var _a2;
            nextTick(() => resizeTextarea());
            if (props.validateEvent) {
              (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "change").catch((err) => debugWarn());
            }
          });
          watch(nativeInputValue, () => setNativeInputValue());
          watch(() => props.type, async () => {
            await nextTick();
            setNativeInputValue();
            resizeTextarea();
          });
          onMounted(() => {
            if (!props.formatter && props.parser)
              ;
            setNativeInputValue();
            nextTick(resizeTextarea);
          });
          expose({
            input,
            textarea,
            ref: _ref,
            textareaStyle,
            autosize: toRef(props, "autosize"),
            focus,
            blur,
            select,
            clear,
            resizeTextarea
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", mergeProps(unref(containerAttrs), {
              class: unref(containerKls),
              style: unref(containerStyle),
              role: _ctx.containerRole,
              onMouseenter: handleMouseEnter,
              onMouseleave: handleMouseLeave
            }), [
              createCommentVNode(" input "),
              _ctx.type !== "textarea" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createCommentVNode(" prepend slot "),
                _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(nsInput).be("group", "prepend"))
                }, [
                  renderSlot(_ctx.$slots, "prepend")
                ], 2)) : createCommentVNode("v-if", true),
                createElementVNode("div", {
                  ref_key: "wrapperRef",
                  ref: wrapperRef,
                  class: normalizeClass(unref(wrapperKls))
                }, [
                  createCommentVNode(" prefix slot "),
                  _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass(unref(nsInput).e("prefix"))
                  }, [
                    createElementVNode("span", {
                      class: normalizeClass(unref(nsInput).e("prefix-inner"))
                    }, [
                      renderSlot(_ctx.$slots, "prefix"),
                      _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 0,
                        class: normalizeClass(unref(nsInput).e("icon"))
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : createCommentVNode("v-if", true),
                  createElementVNode("input", mergeProps({
                    id: unref(inputId),
                    ref_key: "input",
                    ref: input,
                    class: unref(nsInput).e("inner")
                  }, unref(attrs), {
                    minlength: _ctx.minlength,
                    maxlength: _ctx.maxlength,
                    type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
                    disabled: unref(inputDisabled),
                    readonly: _ctx.readonly,
                    autocomplete: _ctx.autocomplete,
                    tabindex: _ctx.tabindex,
                    "aria-label": _ctx.label,
                    placeholder: _ctx.placeholder,
                    style: _ctx.inputStyle,
                    form: _ctx.form,
                    autofocus: _ctx.autofocus,
                    onCompositionstart: handleCompositionStart,
                    onCompositionupdate: handleCompositionUpdate,
                    onCompositionend: handleCompositionEnd,
                    onInput: handleInput,
                    onFocus: _cache[0] || (_cache[0] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                    onBlur: _cache[1] || (_cache[1] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
                    onChange: handleChange,
                    onKeydown: handleKeydown
                  }), null, 16, _hoisted_2$c),
                  createCommentVNode(" suffix slot "),
                  unref(suffixVisible) ? (openBlock(), createElementBlock("span", {
                    key: 1,
                    class: normalizeClass(unref(nsInput).e("suffix"))
                  }, [
                    createElementVNode("span", {
                      class: normalizeClass(unref(nsInput).e("suffix-inner"))
                    }, [
                      !unref(showClear) || !unref(showPwdVisible) || !unref(isWordLimitVisible) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                        renderSlot(_ctx.$slots, "suffix"),
                        _ctx.suffixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                          key: 0,
                          class: normalizeClass(unref(nsInput).e("icon"))
                        }, {
                          default: withCtx(() => [
                            (openBlock(), createBlock(resolveDynamicComponent(_ctx.suffixIcon)))
                          ]),
                          _: 1
                        }, 8, ["class"])) : createCommentVNode("v-if", true)
                      ], 64)) : createCommentVNode("v-if", true),
                      unref(showClear) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 1,
                        class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("clear")]),
                        onMousedown: withModifiers(unref(NOOP), ["prevent"]),
                        onClick: clear
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(circle_close_default))
                        ]),
                        _: 1
                      }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true),
                      unref(showPwdVisible) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 2,
                        class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("password")]),
                        onClick: handlePasswordVisible
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(passwordIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true),
                      unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                        key: 3,
                        class: normalizeClass(unref(nsInput).e("count"))
                      }, [
                        createElementVNode("span", {
                          class: normalizeClass(unref(nsInput).e("count-inner"))
                        }, toDisplayString(unref(textLength)) + " / " + toDisplayString(_ctx.maxlength), 3)
                      ], 2)) : createCommentVNode("v-if", true),
                      unref(validateState) && unref(validateIcon) && unref(needStatusIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 4,
                        class: normalizeClass([
                          unref(nsInput).e("icon"),
                          unref(nsInput).e("validateIcon"),
                          unref(nsInput).is("loading", unref(validateState) === "validating")
                        ])
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(validateIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : createCommentVNode("v-if", true)
                ], 2),
                createCommentVNode(" append slot "),
                _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(unref(nsInput).be("group", "append"))
                }, [
                  renderSlot(_ctx.$slots, "append")
                ], 2)) : createCommentVNode("v-if", true)
              ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createCommentVNode(" textarea "),
                createElementVNode("textarea", mergeProps({
                  id: unref(inputId),
                  ref_key: "textarea",
                  ref: textarea,
                  class: unref(nsTextarea).e("inner")
                }, unref(attrs), {
                  minlength: _ctx.minlength,
                  maxlength: _ctx.maxlength,
                  tabindex: _ctx.tabindex,
                  disabled: unref(inputDisabled),
                  readonly: _ctx.readonly,
                  autocomplete: _ctx.autocomplete,
                  style: unref(textareaStyle),
                  "aria-label": _ctx.label,
                  placeholder: _ctx.placeholder,
                  form: _ctx.form,
                  autofocus: _ctx.autofocus,
                  onCompositionstart: handleCompositionStart,
                  onCompositionupdate: handleCompositionUpdate,
                  onCompositionend: handleCompositionEnd,
                  onInput: handleInput,
                  onFocus: _cache[2] || (_cache[2] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                  onBlur: _cache[3] || (_cache[3] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
                  onChange: handleChange,
                  onKeydown: handleKeydown
                }), null, 16, _hoisted_3$7),
                unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  style: normalizeStyle(countStyle.value),
                  class: normalizeClass(unref(nsInput).e("count"))
                }, toDisplayString(unref(textLength)) + " / " + toDisplayString(_ctx.maxlength), 7)) : createCommentVNode("v-if", true)
              ], 64))
            ], 16, _hoisted_1$f);
          };
        }
      });
      var Input = /* @__PURE__ */ _export_sfc$1(_sfc_main$v, [["__file", "input.vue"]]);
      const ElInput = exports("b", withInstall(Input));
      const GAP = 4;
      const BAR_MAP = {
        vertical: {
          offset: "offsetHeight",
          scroll: "scrollTop",
          scrollSize: "scrollHeight",
          size: "height",
          key: "vertical",
          axis: "Y",
          client: "clientY",
          direction: "top"
        },
        horizontal: {
          offset: "offsetWidth",
          scroll: "scrollLeft",
          scrollSize: "scrollWidth",
          size: "width",
          key: "horizontal",
          axis: "X",
          client: "clientX",
          direction: "left"
        }
      };
      const renderThumbStyle = ({
        move,
        size,
        bar
      }) => ({
        [bar.size]: size,
        transform: `translate${bar.axis}(${move}%)`
      });
      const scrollbarContextKey = Symbol("scrollbarContextKey");
      const thumbProps = buildProps({
        vertical: Boolean,
        size: String,
        move: Number,
        ratio: {
          type: Number,
          required: true
        },
        always: Boolean
      });
      const COMPONENT_NAME$1 = "Thumb";
      const _sfc_main$u = /* @__PURE__ */ defineComponent({
        __name: "thumb",
        props: thumbProps,
        setup(__props) {
          const props = __props;
          const scrollbar = inject(scrollbarContextKey);
          const ns = useNamespace("scrollbar");
          if (!scrollbar)
            throwError(COMPONENT_NAME$1, "can not inject scrollbar context");
          const instance = ref();
          const thumb = ref();
          const thumbState = ref({});
          const visible = ref(false);
          let cursorDown = false;
          let cursorLeave = false;
          let originalOnSelectStart = isClient ? document.onselectstart : null;
          const bar = computed$1(() => BAR_MAP[props.vertical ? "vertical" : "horizontal"]);
          const thumbStyle = computed$1(() => renderThumbStyle({
            size: props.size,
            move: props.move,
            bar: bar.value
          }));
          const offsetRatio = computed$1(() => instance.value[bar.value.offset] ** 2 / scrollbar.wrapElement[bar.value.scrollSize] / props.ratio / thumb.value[bar.value.offset]);
          const clickThumbHandler = (e) => {
            var _a2;
            e.stopPropagation();
            if (e.ctrlKey || [1, 2].includes(e.button))
              return;
            (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
            startDrag(e);
            const el = e.currentTarget;
            if (!el)
              return;
            thumbState.value[bar.value.axis] = el[bar.value.offset] - (e[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
          };
          const clickTrackHandler = (e) => {
            if (!thumb.value || !instance.value || !scrollbar.wrapElement)
              return;
            const offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
            const thumbHalf = thumb.value[bar.value.offset] / 2;
            const thumbPositionPercentage = (offset - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const startDrag = (e) => {
            e.stopImmediatePropagation();
            cursorDown = true;
            document.addEventListener("mousemove", mouseMoveDocumentHandler);
            document.addEventListener("mouseup", mouseUpDocumentHandler);
            originalOnSelectStart = document.onselectstart;
            document.onselectstart = () => false;
          };
          const mouseMoveDocumentHandler = (e) => {
            if (!instance.value || !thumb.value)
              return;
            if (cursorDown === false)
              return;
            const prevPage = thumbState.value[bar.value.axis];
            if (!prevPage)
              return;
            const offset = (instance.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
            const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
            const thumbPositionPercentage = (offset - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const mouseUpDocumentHandler = () => {
            cursorDown = false;
            thumbState.value[bar.value.axis] = 0;
            document.removeEventListener("mousemove", mouseMoveDocumentHandler);
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
            restoreOnselectstart();
            if (cursorLeave)
              visible.value = false;
          };
          const mouseMoveScrollbarHandler = () => {
            cursorLeave = false;
            visible.value = !!props.size;
          };
          const mouseLeaveScrollbarHandler = () => {
            cursorLeave = true;
            visible.value = cursorDown;
          };
          onBeforeUnmount(() => {
            restoreOnselectstart();
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
          });
          const restoreOnselectstart = () => {
            if (document.onselectstart !== originalOnSelectStart)
              document.onselectstart = originalOnSelectStart;
          };
          useEventListener(toRef(scrollbar, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
          useEventListener(toRef(scrollbar, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: unref(ns).b("fade"),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createElementVNode("div", {
                  ref_key: "instance",
                  ref: instance,
                  class: normalizeClass([unref(ns).e("bar"), unref(ns).is(unref(bar).key)]),
                  onMousedown: clickTrackHandler
                }, [
                  createElementVNode("div", {
                    ref_key: "thumb",
                    ref: thumb,
                    class: normalizeClass(unref(ns).e("thumb")),
                    style: normalizeStyle(unref(thumbStyle)),
                    onMousedown: clickThumbHandler
                  }, null, 38)
                ], 34), [
                  [vShow, _ctx.always || visible.value]
                ])
              ]),
              _: 1
            }, 8, ["name"]);
          };
        }
      });
      var Thumb = /* @__PURE__ */ _export_sfc$1(_sfc_main$u, [["__file", "thumb.vue"]]);
      const barProps = buildProps({
        always: {
          type: Boolean,
          default: true
        },
        minSize: {
          type: Number,
          required: true
        }
      });
      const _sfc_main$t = /* @__PURE__ */ defineComponent({
        __name: "bar",
        props: barProps,
        setup(__props, { expose }) {
          const props = __props;
          const scrollbar = inject(scrollbarContextKey);
          const moveX = ref(0);
          const moveY = ref(0);
          const sizeWidth = ref("");
          const sizeHeight = ref("");
          const ratioY = ref(1);
          const ratioX = ref(1);
          const handleScroll = (wrap) => {
            if (wrap) {
              const offsetHeight = wrap.offsetHeight - GAP;
              const offsetWidth = wrap.offsetWidth - GAP;
              moveY.value = wrap.scrollTop * 100 / offsetHeight * ratioY.value;
              moveX.value = wrap.scrollLeft * 100 / offsetWidth * ratioX.value;
            }
          };
          const update = () => {
            const wrap = scrollbar == null ? void 0 : scrollbar.wrapElement;
            if (!wrap)
              return;
            const offsetHeight = wrap.offsetHeight - GAP;
            const offsetWidth = wrap.offsetWidth - GAP;
            const originalHeight = offsetHeight ** 2 / wrap.scrollHeight;
            const originalWidth = offsetWidth ** 2 / wrap.scrollWidth;
            const height = Math.max(originalHeight, props.minSize);
            const width = Math.max(originalWidth, props.minSize);
            ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
            ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
            sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
            sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
          };
          expose({
            handleScroll,
            update
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock(Fragment, null, [
              createVNode(Thumb, {
                move: moveX.value,
                ratio: ratioX.value,
                size: sizeWidth.value,
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"]),
              createVNode(Thumb, {
                move: moveY.value,
                ratio: ratioY.value,
                size: sizeHeight.value,
                vertical: "",
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"])
            ], 64);
          };
        }
      });
      var Bar = /* @__PURE__ */ _export_sfc$1(_sfc_main$t, [["__file", "bar.vue"]]);
      const scrollbarProps = buildProps({
        height: {
          type: [String, Number],
          default: ""
        },
        maxHeight: {
          type: [String, Number],
          default: ""
        },
        native: {
          type: Boolean,
          default: false
        },
        wrapStyle: {
          type: definePropType([String, Object, Array]),
          default: ""
        },
        wrapClass: {
          type: [String, Array],
          default: ""
        },
        viewClass: {
          type: [String, Array],
          default: ""
        },
        viewStyle: {
          type: [String, Array, Object],
          default: ""
        },
        noresize: Boolean,
        tag: {
          type: String,
          default: "div"
        },
        always: Boolean,
        minSize: {
          type: Number,
          default: 20
        },
        id: String,
        role: String,
        ariaLabel: String,
        ariaOrientation: {
          type: String,
          values: ["horizontal", "vertical"]
        }
      });
      const scrollbarEmits = {
        scroll: ({
          scrollTop,
          scrollLeft
        }) => [scrollTop, scrollLeft].every(isNumber)
      };
      const COMPONENT_NAME = "ElScrollbar";
      const __default__$j = defineComponent({
        name: COMPONENT_NAME
      });
      const _sfc_main$s = /* @__PURE__ */ defineComponent({
        ...__default__$j,
        props: scrollbarProps,
        emits: scrollbarEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const ns = useNamespace("scrollbar");
          let stopResizeObserver = void 0;
          let stopResizeListener = void 0;
          const scrollbarRef = ref();
          const wrapRef = ref();
          const resizeRef = ref();
          const barRef = ref();
          const wrapStyle = computed$1(() => {
            const style = {};
            if (props.height)
              style.height = addUnit(props.height);
            if (props.maxHeight)
              style.maxHeight = addUnit(props.maxHeight);
            return [props.wrapStyle, style];
          });
          const wrapKls = computed$1(() => {
            return [
              props.wrapClass,
              ns.e("wrap"),
              { [ns.em("wrap", "hidden-default")]: !props.native }
            ];
          });
          const resizeKls = computed$1(() => {
            return [ns.e("view"), props.viewClass];
          });
          const handleScroll = () => {
            var _a2;
            if (wrapRef.value) {
              (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
              emit("scroll", {
                scrollTop: wrapRef.value.scrollTop,
                scrollLeft: wrapRef.value.scrollLeft
              });
            }
          };
          function scrollTo(arg1, arg2) {
            if (isObject$1(arg1)) {
              wrapRef.value.scrollTo(arg1);
            } else if (isNumber(arg1) && isNumber(arg2)) {
              wrapRef.value.scrollTo(arg1, arg2);
            }
          }
          const setScrollTop = (value) => {
            if (!isNumber(value)) {
              return;
            }
            wrapRef.value.scrollTop = value;
          };
          const setScrollLeft = (value) => {
            if (!isNumber(value)) {
              return;
            }
            wrapRef.value.scrollLeft = value;
          };
          const update = () => {
            var _a2;
            (_a2 = barRef.value) == null ? void 0 : _a2.update();
          };
          watch(() => props.noresize, (noresize) => {
            if (noresize) {
              stopResizeObserver == null ? void 0 : stopResizeObserver();
              stopResizeListener == null ? void 0 : stopResizeListener();
            } else {
              ({ stop: stopResizeObserver } = useResizeObserver(resizeRef, update));
              stopResizeListener = useEventListener("resize", update);
            }
          }, { immediate: true });
          watch(() => [props.maxHeight, props.height], () => {
            if (!props.native)
              nextTick(() => {
                var _a2;
                update();
                if (wrapRef.value) {
                  (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
                }
              });
          });
          provide(scrollbarContextKey, reactive({
            scrollbarElement: scrollbarRef,
            wrapElement: wrapRef
          }));
          onMounted(() => {
            if (!props.native)
              nextTick(() => {
                update();
              });
          });
          onUpdated(() => update());
          expose({
            wrapRef,
            update,
            scrollTo,
            setScrollTop,
            setScrollLeft,
            handleScroll
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "scrollbarRef",
              ref: scrollbarRef,
              class: normalizeClass(unref(ns).b())
            }, [
              createElementVNode("div", {
                ref_key: "wrapRef",
                ref: wrapRef,
                class: normalizeClass(unref(wrapKls)),
                style: normalizeStyle(unref(wrapStyle)),
                onScroll: handleScroll
              }, [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
                  id: _ctx.id,
                  ref_key: "resizeRef",
                  ref: resizeRef,
                  class: normalizeClass(unref(resizeKls)),
                  style: normalizeStyle(_ctx.viewStyle),
                  role: _ctx.role,
                  "aria-label": _ctx.ariaLabel,
                  "aria-orientation": _ctx.ariaOrientation
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
              ], 38),
              !_ctx.native ? (openBlock(), createBlock(Bar, {
                key: 0,
                ref_key: "barRef",
                ref: barRef,
                always: _ctx.always,
                "min-size": _ctx.minSize
              }, null, 8, ["always", "min-size"])) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var Scrollbar = /* @__PURE__ */ _export_sfc$1(_sfc_main$s, [["__file", "scrollbar.vue"]]);
      const ElScrollbar = exports("ab", withInstall(Scrollbar));
      const POPPER_INJECTION_KEY = Symbol("popper");
      const POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");
      const roleTypes = [
        "dialog",
        "grid",
        "group",
        "listbox",
        "menu",
        "navigation",
        "tooltip",
        "tree"
      ];
      const popperProps = buildProps({
        role: {
          type: String,
          values: roleTypes,
          default: "tooltip"
        }
      });
      const __default__$i = defineComponent({
        name: "ElPopper",
        inheritAttrs: false
      });
      const _sfc_main$r = /* @__PURE__ */ defineComponent({
        ...__default__$i,
        props: popperProps,
        setup(__props, { expose }) {
          const props = __props;
          const triggerRef = ref();
          const popperInstanceRef = ref();
          const contentRef = ref();
          const referenceRef = ref();
          const role = computed$1(() => props.role);
          const popperProvides = {
            triggerRef,
            popperInstanceRef,
            contentRef,
            referenceRef,
            role
          };
          expose(popperProvides);
          provide(POPPER_INJECTION_KEY, popperProvides);
          return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
          };
        }
      });
      var Popper = /* @__PURE__ */ _export_sfc$1(_sfc_main$r, [["__file", "popper.vue"]]);
      const popperArrowProps = buildProps({
        arrowOffset: {
          type: Number,
          default: 5
        }
      });
      const __default__$h = defineComponent({
        name: "ElPopperArrow",
        inheritAttrs: false
      });
      const _sfc_main$q = /* @__PURE__ */ defineComponent({
        ...__default__$h,
        props: popperArrowProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("popper");
          const { arrowOffset, arrowRef, arrowStyle } = inject(POPPER_CONTENT_INJECTION_KEY, void 0);
          watch(() => props.arrowOffset, (val) => {
            arrowOffset.value = val;
          });
          onBeforeUnmount(() => {
            arrowRef.value = void 0;
          });
          expose({
            arrowRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              ref_key: "arrowRef",
              ref: arrowRef,
              class: normalizeClass(unref(ns).e("arrow")),
              style: normalizeStyle(unref(arrowStyle)),
              "data-popper-arrow": ""
            }, null, 6);
          };
        }
      });
      var ElPopperArrow = /* @__PURE__ */ _export_sfc$1(_sfc_main$q, [["__file", "arrow.vue"]]);
      const NAME = "ElOnlyChild";
      const OnlyChild = defineComponent({
        name: NAME,
        setup(_2, {
          slots,
          attrs
        }) {
          var _a2;
          const forwardRefInjection = inject(FORWARD_REF_INJECTION_KEY);
          const forwardRefDirective = useForwardRefDirective((_a2 = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a2 : NOOP);
          return () => {
            var _a22;
            const defaultSlot = (_a22 = slots.default) == null ? void 0 : _a22.call(slots, attrs);
            if (!defaultSlot)
              return null;
            if (defaultSlot.length > 1) {
              return null;
            }
            const firstLegitNode = findFirstLegitChild(defaultSlot);
            if (!firstLegitNode) {
              return null;
            }
            return withDirectives(cloneVNode(firstLegitNode, attrs), [[forwardRefDirective]]);
          };
        }
      });
      function findFirstLegitChild(node) {
        if (!node)
          return null;
        const children = node;
        for (const child of children) {
          if (isObject$1(child)) {
            switch (child.type) {
              case Comment:
                continue;
              case Text$1:
              case "svg":
                return wrapTextContent(child);
              case Fragment:
                return findFirstLegitChild(child.children);
              default:
                return child;
            }
          }
          return wrapTextContent(child);
        }
        return null;
      }
      function wrapTextContent(s2) {
        const ns = useNamespace("only-child");
        return createVNode("span", {
          "class": ns.e("content")
        }, [s2]);
      }
      const popperTriggerProps = buildProps({
        virtualRef: {
          type: definePropType(Object)
        },
        virtualTriggering: Boolean,
        onMouseenter: {
          type: definePropType(Function)
        },
        onMouseleave: {
          type: definePropType(Function)
        },
        onClick: {
          type: definePropType(Function)
        },
        onKeydown: {
          type: definePropType(Function)
        },
        onFocus: {
          type: definePropType(Function)
        },
        onBlur: {
          type: definePropType(Function)
        },
        onContextmenu: {
          type: definePropType(Function)
        },
        id: String,
        open: Boolean
      });
      const __default__$g = defineComponent({
        name: "ElPopperTrigger",
        inheritAttrs: false
      });
      const _sfc_main$p = /* @__PURE__ */ defineComponent({
        ...__default__$g,
        props: popperTriggerProps,
        setup(__props, { expose }) {
          const props = __props;
          const { role, triggerRef } = inject(POPPER_INJECTION_KEY, void 0);
          useForwardRef(triggerRef);
          const ariaControls = computed$1(() => {
            return ariaHaspopup.value ? props.id : void 0;
          });
          const ariaDescribedby = computed$1(() => {
            if (role && role.value === "tooltip") {
              return props.open && props.id ? props.id : void 0;
            }
            return void 0;
          });
          const ariaHaspopup = computed$1(() => {
            if (role && role.value !== "tooltip") {
              return role.value;
            }
            return void 0;
          });
          const ariaExpanded = computed$1(() => {
            return ariaHaspopup.value ? `${props.open}` : void 0;
          });
          let virtualTriggerAriaStopWatch = void 0;
          onMounted(() => {
            watch(() => props.virtualRef, (virtualEl) => {
              if (virtualEl) {
                triggerRef.value = unrefElement(virtualEl);
              }
            }, {
              immediate: true
            });
            watch(triggerRef, (el, prevEl) => {
              virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
              virtualTriggerAriaStopWatch = void 0;
              if (isElement(el)) {
                [
                  "onMouseenter",
                  "onMouseleave",
                  "onClick",
                  "onKeydown",
                  "onFocus",
                  "onBlur",
                  "onContextmenu"
                ].forEach((eventName) => {
                  var _a2;
                  const handler = props[eventName];
                  if (handler) {
                    el.addEventListener(eventName.slice(2).toLowerCase(), handler);
                    (_a2 = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a2.call(prevEl, eventName.slice(2).toLowerCase(), handler);
                  }
                });
                virtualTriggerAriaStopWatch = watch([ariaControls, ariaDescribedby, ariaHaspopup, ariaExpanded], (watches) => {
                  [
                    "aria-controls",
                    "aria-describedby",
                    "aria-haspopup",
                    "aria-expanded"
                  ].forEach((key, idx) => {
                    isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                  });
                }, { immediate: true });
              }
              if (isElement(prevEl)) {
                [
                  "aria-controls",
                  "aria-describedby",
                  "aria-haspopup",
                  "aria-expanded"
                ].forEach((key) => prevEl.removeAttribute(key));
              }
            }, {
              immediate: true
            });
          });
          onBeforeUnmount(() => {
            virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
            virtualTriggerAriaStopWatch = void 0;
          });
          expose({
            triggerRef
          });
          return (_ctx, _cache) => {
            return !_ctx.virtualTriggering ? (openBlock(), createBlock(unref(OnlyChild), mergeProps({ key: 0 }, _ctx.$attrs, {
              "aria-controls": unref(ariaControls),
              "aria-describedby": unref(ariaDescribedby),
              "aria-expanded": unref(ariaExpanded),
              "aria-haspopup": unref(ariaHaspopup)
            }), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])) : createCommentVNode("v-if", true);
          };
        }
      });
      var ElPopperTrigger = /* @__PURE__ */ _export_sfc$1(_sfc_main$p, [["__file", "trigger.vue"]]);
      const FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
      const FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
      const FOCUSOUT_PREVENTED = "focus-trap.focusout-prevented";
      const FOCUS_AFTER_TRAPPED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const FOCUSOUT_PREVENTED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
      const ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
      const FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");
      const focusReason = ref();
      const lastUserFocusTimestamp = ref(0);
      const lastAutomatedFocusTimestamp = ref(0);
      let focusReasonUserCount = 0;
      const obtainAllFocusableElements = (element) => {
        const nodes = [];
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
          acceptNode: (node) => {
            const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
            if (node.disabled || node.hidden || isHiddenInput)
              return NodeFilter.FILTER_SKIP;
            return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
          }
        });
        while (walker.nextNode())
          nodes.push(walker.currentNode);
        return nodes;
      };
      const getVisibleElement = (elements, container) => {
        for (const element of elements) {
          if (!isHidden(element, container))
            return element;
        }
      };
      const isHidden = (element, container) => {
        if (getComputedStyle(element).visibility === "hidden")
          return true;
        while (element) {
          if (container && element === container)
            return false;
          if (getComputedStyle(element).display === "none")
            return true;
          element = element.parentElement;
        }
        return false;
      };
      const getEdges = (container) => {
        const focusable = obtainAllFocusableElements(container);
        const first = getVisibleElement(focusable, container);
        const last = getVisibleElement(focusable.reverse(), container);
        return [first, last];
      };
      const isSelectable = (element) => {
        return element instanceof HTMLInputElement && "select" in element;
      };
      const tryFocus = (element, shouldSelect) => {
        if (element && element.focus) {
          const prevFocusedElement = document.activeElement;
          element.focus({ preventScroll: true });
          lastAutomatedFocusTimestamp.value = window.performance.now();
          if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {
            element.select();
          }
        }
      };
      function removeFromStack(list, item) {
        const copy = [...list];
        const idx = list.indexOf(item);
        if (idx !== -1) {
          copy.splice(idx, 1);
        }
        return copy;
      }
      const createFocusableStack = () => {
        let stack = [];
        const push = (layer) => {
          const currentLayer = stack[0];
          if (currentLayer && layer !== currentLayer) {
            currentLayer.pause();
          }
          stack = removeFromStack(stack, layer);
          stack.unshift(layer);
        };
        const remove = (layer) => {
          var _a2, _b;
          stack = removeFromStack(stack, layer);
          (_b = (_a2 = stack[0]) == null ? void 0 : _a2.resume) == null ? void 0 : _b.call(_a2);
        };
        return {
          push,
          remove
        };
      };
      const focusFirstDescendant = (elements, shouldSelect = false) => {
        const prevFocusedElement = document.activeElement;
        for (const element of elements) {
          tryFocus(element, shouldSelect);
          if (document.activeElement !== prevFocusedElement)
            return;
        }
      };
      const focusableStack = createFocusableStack();
      const isFocusCausedByUserEvent = () => {
        return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;
      };
      const notifyFocusReasonPointer = () => {
        focusReason.value = "pointer";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const notifyFocusReasonKeydown = () => {
        focusReason.value = "keyboard";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const useFocusReason = () => {
        onMounted(() => {
          if (focusReasonUserCount === 0) {
            document.addEventListener("mousedown", notifyFocusReasonPointer);
            document.addEventListener("touchstart", notifyFocusReasonPointer);
            document.addEventListener("keydown", notifyFocusReasonKeydown);
          }
          focusReasonUserCount++;
        });
        onBeforeUnmount(() => {
          focusReasonUserCount--;
          if (focusReasonUserCount <= 0) {
            document.removeEventListener("mousedown", notifyFocusReasonPointer);
            document.removeEventListener("touchstart", notifyFocusReasonPointer);
            document.removeEventListener("keydown", notifyFocusReasonKeydown);
          }
        });
        return {
          focusReason,
          lastUserFocusTimestamp,
          lastAutomatedFocusTimestamp
        };
      };
      const createFocusOutPreventedEvent = (detail) => {
        return new CustomEvent(FOCUSOUT_PREVENTED, {
          ...FOCUSOUT_PREVENTED_OPTS,
          detail
        });
      };
      const _sfc_main$o = defineComponent({
        name: "ElFocusTrap",
        inheritAttrs: false,
        props: {
          loop: Boolean,
          trapped: Boolean,
          focusTrapEl: Object,
          focusStartEl: {
            type: [Object, String],
            default: "first"
          }
        },
        emits: [
          ON_TRAP_FOCUS_EVT,
          ON_RELEASE_FOCUS_EVT,
          "focusin",
          "focusout",
          "focusout-prevented",
          "release-requested"
        ],
        setup(props, { emit }) {
          const forwardRef = ref();
          let lastFocusBeforeTrapped;
          let lastFocusAfterTrapped;
          const { focusReason: focusReason2 } = useFocusReason();
          useEscapeKeydown((event) => {
            if (props.trapped && !focusLayer.paused) {
              emit("release-requested", event);
            }
          });
          const focusLayer = {
            paused: false,
            pause() {
              this.paused = true;
            },
            resume() {
              this.paused = false;
            }
          };
          const onKeydown = (e) => {
            if (!props.loop && !props.trapped)
              return;
            if (focusLayer.paused)
              return;
            const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;
            const { loop } = props;
            const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
            const currentFocusingEl = document.activeElement;
            if (isTabbing && currentFocusingEl) {
              const container = currentTarget;
              const [first, last] = getEdges(container);
              const isTabbable = first && last;
              if (!isTabbable) {
                if (currentFocusingEl === container) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                  }
                }
              } else {
                if (!shiftKey && currentFocusingEl === last) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                    if (loop)
                      tryFocus(first, true);
                  }
                } else if (shiftKey && [first, container].includes(currentFocusingEl)) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                    if (loop)
                      tryFocus(last, true);
                  }
                }
              }
            }
          };
          provide(FOCUS_TRAP_INJECTION_KEY, {
            focusTrapRef: forwardRef,
            onKeydown
          });
          watch(() => props.focusTrapEl, (focusTrapEl) => {
            if (focusTrapEl) {
              forwardRef.value = focusTrapEl;
            }
          }, { immediate: true });
          watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
            if (forwardRef2) {
              forwardRef2.addEventListener("keydown", onKeydown);
              forwardRef2.addEventListener("focusin", onFocusIn);
              forwardRef2.addEventListener("focusout", onFocusOut);
            }
            if (oldForwardRef) {
              oldForwardRef.removeEventListener("keydown", onKeydown);
              oldForwardRef.removeEventListener("focusin", onFocusIn);
              oldForwardRef.removeEventListener("focusout", onFocusOut);
            }
          });
          const trapOnFocus = (e) => {
            emit(ON_TRAP_FOCUS_EVT, e);
          };
          const releaseOnFocus = (e) => emit(ON_RELEASE_FOCUS_EVT, e);
          const onFocusIn = (e) => {
            const trapContainer = unref(forwardRef);
            if (!trapContainer)
              return;
            const target = e.target;
            const relatedTarget = e.relatedTarget;
            const isFocusedInTrap = target && trapContainer.contains(target);
            if (!props.trapped) {
              const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);
              if (!isPrevFocusedInTrap) {
                lastFocusBeforeTrapped = relatedTarget;
              }
            }
            if (isFocusedInTrap)
              emit("focusin", e);
            if (focusLayer.paused)
              return;
            if (props.trapped) {
              if (isFocusedInTrap) {
                lastFocusAfterTrapped = target;
              } else {
                tryFocus(lastFocusAfterTrapped, true);
              }
            }
          };
          const onFocusOut = (e) => {
            const trapContainer = unref(forwardRef);
            if (focusLayer.paused || !trapContainer)
              return;
            if (props.trapped) {
              const relatedTarget = e.relatedTarget;
              if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {
                setTimeout(() => {
                  if (!focusLayer.paused && props.trapped) {
                    const focusoutPreventedEvent = createFocusOutPreventedEvent({
                      focusReason: focusReason2.value
                    });
                    emit("focusout-prevented", focusoutPreventedEvent);
                    if (!focusoutPreventedEvent.defaultPrevented) {
                      tryFocus(lastFocusAfterTrapped, true);
                    }
                  }
                }, 0);
              }
            } else {
              const target = e.target;
              const isFocusedInTrap = target && trapContainer.contains(target);
              if (!isFocusedInTrap)
                emit("focusout", e);
            }
          };
          async function startTrap() {
            await nextTick();
            const trapContainer = unref(forwardRef);
            if (trapContainer) {
              focusableStack.push(focusLayer);
              const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;
              lastFocusBeforeTrapped = prevFocusedElement;
              const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
              if (!isPrevFocusContained) {
                const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
                trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
                trapContainer.dispatchEvent(focusEvent);
                if (!focusEvent.defaultPrevented) {
                  nextTick(() => {
                    let focusStartEl = props.focusStartEl;
                    if (!isString(focusStartEl)) {
                      tryFocus(focusStartEl);
                      if (document.activeElement !== focusStartEl) {
                        focusStartEl = "first";
                      }
                    }
                    if (focusStartEl === "first") {
                      focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);
                    }
                    if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                      tryFocus(trapContainer);
                    }
                  });
                }
              }
            }
          }
          function stopTrap() {
            const trapContainer = unref(forwardRef);
            if (trapContainer) {
              trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
              const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {
                ...FOCUS_AFTER_TRAPPED_OPTS,
                detail: {
                  focusReason: focusReason2.value
                }
              });
              trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
              trapContainer.dispatchEvent(releasedEvent);
              if (!releasedEvent.defaultPrevented && (focusReason2.value == "keyboard" || !isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {
                tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);
              }
              trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
              focusableStack.remove(focusLayer);
            }
          }
          onMounted(() => {
            if (props.trapped) {
              startTrap();
            }
            watch(() => props.trapped, (trapped) => {
              if (trapped) {
                startTrap();
              } else {
                stopTrap();
              }
            });
          });
          onBeforeUnmount(() => {
            if (props.trapped) {
              stopTrap();
            }
          });
          return {
            onKeydown
          };
        }
      });
      function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
        return renderSlot(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
      }
      var ElFocusTrap = /* @__PURE__ */ _export_sfc$1(_sfc_main$o, [["render", _sfc_render$6], ["__file", "focus-trap.vue"]]);
      const POSITIONING_STRATEGIES = ["fixed", "absolute"];
      const popperCoreConfigProps = buildProps({
        boundariesPadding: {
          type: Number,
          default: 0
        },
        fallbackPlacements: {
          type: definePropType(Array),
          default: void 0
        },
        gpuAcceleration: {
          type: Boolean,
          default: true
        },
        offset: {
          type: Number,
          default: 12
        },
        placement: {
          type: String,
          values: Ee,
          default: "bottom"
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        strategy: {
          type: String,
          values: POSITIONING_STRATEGIES,
          default: "absolute"
        }
      });
      const popperContentProps = buildProps({
        ...popperCoreConfigProps,
        id: String,
        style: {
          type: definePropType([String, Array, Object])
        },
        className: {
          type: definePropType([String, Array, Object])
        },
        effect: {
          type: String,
          default: "dark"
        },
        visible: Boolean,
        enterable: {
          type: Boolean,
          default: true
        },
        pure: Boolean,
        focusOnShow: {
          type: Boolean,
          default: false
        },
        trapping: {
          type: Boolean,
          default: false
        },
        popperClass: {
          type: definePropType([String, Array, Object])
        },
        popperStyle: {
          type: definePropType([String, Array, Object])
        },
        referenceEl: {
          type: definePropType(Object)
        },
        triggerTargetEl: {
          type: definePropType(Object)
        },
        stopPopperMouseEvent: {
          type: Boolean,
          default: true
        },
        ariaLabel: {
          type: String,
          default: void 0
        },
        virtualTriggering: Boolean,
        zIndex: Number
      });
      const popperContentEmits = {
        mouseenter: (evt) => evt instanceof MouseEvent,
        mouseleave: (evt) => evt instanceof MouseEvent,
        focus: () => true,
        blur: () => true,
        close: () => true
      };
      const buildPopperOptions = (props, modifiers = []) => {
        const { placement, strategy, popperOptions } = props;
        const options = {
          placement,
          strategy,
          ...popperOptions,
          modifiers: [...genModifiers(props), ...modifiers]
        };
        deriveExtraModifiers(options, popperOptions == null ? void 0 : popperOptions.modifiers);
        return options;
      };
      const unwrapMeasurableEl = ($el) => {
        if (!isClient)
          return;
        return unrefElement($el);
      };
      function genModifiers(options) {
        const { offset, gpuAcceleration, fallbackPlacements } = options;
        return [
          {
            name: "offset",
            options: {
              offset: [0, offset != null ? offset : 12]
            }
          },
          {
            name: "preventOverflow",
            options: {
              padding: {
                top: 2,
                bottom: 2,
                left: 5,
                right: 5
              }
            }
          },
          {
            name: "flip",
            options: {
              padding: 5,
              fallbackPlacements
            }
          },
          {
            name: "computeStyles",
            options: {
              gpuAcceleration
            }
          }
        ];
      }
      function deriveExtraModifiers(options, modifiers) {
        if (modifiers) {
          options.modifiers = [...options.modifiers, ...modifiers != null ? modifiers : []];
        }
      }
      const DEFAULT_ARROW_OFFSET = 0;
      const usePopperContent = (props) => {
        const { popperInstanceRef, contentRef, triggerRef, role } = inject(POPPER_INJECTION_KEY, void 0);
        const arrowRef = ref();
        const arrowOffset = ref();
        const eventListenerModifier = computed$1(() => {
          return {
            name: "eventListeners",
            enabled: !!props.visible
          };
        });
        const arrowModifier = computed$1(() => {
          var _a2;
          const arrowEl = unref(arrowRef);
          const offset = (_a2 = unref(arrowOffset)) != null ? _a2 : DEFAULT_ARROW_OFFSET;
          return {
            name: "arrow",
            enabled: !isUndefined$1(arrowEl),
            options: {
              element: arrowEl,
              padding: offset
            }
          };
        });
        const options = computed$1(() => {
          return {
            onFirstUpdate: () => {
              update();
            },
            ...buildPopperOptions(props, [
              unref(arrowModifier),
              unref(eventListenerModifier)
            ])
          };
        });
        const computedReference = computed$1(() => unwrapMeasurableEl(props.referenceEl) || unref(triggerRef));
        const { attributes, state, styles, update, forceUpdate, instanceRef } = usePopper(computedReference, contentRef, options);
        watch(instanceRef, (instance) => popperInstanceRef.value = instance);
        onMounted(() => {
          watch(() => {
            var _a2;
            return (_a2 = unref(computedReference)) == null ? void 0 : _a2.getBoundingClientRect();
          }, () => {
            update();
          });
        });
        return {
          attributes,
          arrowRef,
          contentRef,
          instanceRef,
          state,
          styles,
          role,
          forceUpdate,
          update
        };
      };
      const usePopperContentDOM = (props, {
        attributes,
        styles,
        role
      }) => {
        const { nextZIndex } = useZIndex();
        const ns = useNamespace("popper");
        const contentAttrs = computed$1(() => unref(attributes).popper);
        const contentZIndex = ref(isNumber(props.zIndex) ? props.zIndex : nextZIndex());
        const contentClass = computed$1(() => [
          ns.b(),
          ns.is("pure", props.pure),
          ns.is(props.effect),
          props.popperClass
        ]);
        const contentStyle = computed$1(() => {
          return [
            { zIndex: unref(contentZIndex) },
            unref(styles).popper,
            props.popperStyle || {}
          ];
        });
        const ariaModal = computed$1(() => role.value === "dialog" ? "false" : void 0);
        const arrowStyle = computed$1(() => unref(styles).arrow || {});
        const updateZIndex = () => {
          contentZIndex.value = isNumber(props.zIndex) ? props.zIndex : nextZIndex();
        };
        return {
          ariaModal,
          arrowStyle,
          contentAttrs,
          contentClass,
          contentStyle,
          contentZIndex,
          updateZIndex
        };
      };
      const usePopperContentFocusTrap = (props, emit) => {
        const trapped = ref(false);
        const focusStartRef = ref();
        const onFocusAfterTrapped = () => {
          emit("focus");
        };
        const onFocusAfterReleased = (event) => {
          var _a2;
          if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) !== "pointer") {
            focusStartRef.value = "first";
            emit("blur");
          }
        };
        const onFocusInTrap = (event) => {
          if (props.visible && !trapped.value) {
            if (event.target) {
              focusStartRef.value = event.target;
            }
            trapped.value = true;
          }
        };
        const onFocusoutPrevented = (event) => {
          if (!props.trapping) {
            if (event.detail.focusReason === "pointer") {
              event.preventDefault();
            }
            trapped.value = false;
          }
        };
        const onReleaseRequested = () => {
          trapped.value = false;
          emit("close");
        };
        return {
          focusStartRef,
          trapped,
          onFocusAfterReleased,
          onFocusAfterTrapped,
          onFocusInTrap,
          onFocusoutPrevented,
          onReleaseRequested
        };
      };
      const __default__$f = defineComponent({
        name: "ElPopperContent"
      });
      const _sfc_main$n = /* @__PURE__ */ defineComponent({
        ...__default__$f,
        props: popperContentProps,
        emits: popperContentEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const {
            focusStartRef,
            trapped,
            onFocusAfterReleased,
            onFocusAfterTrapped,
            onFocusInTrap,
            onFocusoutPrevented,
            onReleaseRequested
          } = usePopperContentFocusTrap(props, emit);
          const { attributes, arrowRef, contentRef, styles, instanceRef, role, update } = usePopperContent(props);
          const {
            ariaModal,
            arrowStyle,
            contentAttrs,
            contentClass,
            contentStyle,
            updateZIndex
          } = usePopperContentDOM(props, {
            styles,
            attributes,
            role
          });
          const formItemContext = inject(formItemContextKey, void 0);
          const arrowOffset = ref();
          provide(POPPER_CONTENT_INJECTION_KEY, {
            arrowStyle,
            arrowRef,
            arrowOffset
          });
          if (formItemContext && (formItemContext.addInputId || formItemContext.removeInputId)) {
            provide(formItemContextKey, {
              ...formItemContext,
              addInputId: NOOP,
              removeInputId: NOOP
            });
          }
          let triggerTargetAriaStopWatch = void 0;
          const updatePopper = (shouldUpdateZIndex = true) => {
            update();
            shouldUpdateZIndex && updateZIndex();
          };
          const togglePopperAlive = () => {
            updatePopper(false);
            if (props.visible && props.focusOnShow) {
              trapped.value = true;
            } else if (props.visible === false) {
              trapped.value = false;
            }
          };
          onMounted(() => {
            watch(() => props.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {
              triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
              triggerTargetAriaStopWatch = void 0;
              const el = unref(triggerTargetEl || contentRef.value);
              const prevEl = unref(prevTriggerTargetEl || contentRef.value);
              if (isElement(el)) {
                triggerTargetAriaStopWatch = watch([role, () => props.ariaLabel, ariaModal, () => props.id], (watches) => {
                  ["role", "aria-label", "aria-modal", "id"].forEach((key, idx) => {
                    isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                  });
                }, { immediate: true });
              }
              if (prevEl !== el && isElement(prevEl)) {
                ["role", "aria-label", "aria-modal", "id"].forEach((key) => {
                  prevEl.removeAttribute(key);
                });
              }
            }, { immediate: true });
            watch(() => props.visible, togglePopperAlive, { immediate: true });
          });
          onBeforeUnmount(() => {
            triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
            triggerTargetAriaStopWatch = void 0;
          });
          expose({
            popperContentRef: contentRef,
            popperInstanceRef: instanceRef,
            updatePopper,
            contentStyle
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", mergeProps({
              ref_key: "contentRef",
              ref: contentRef
            }, unref(contentAttrs), {
              style: unref(contentStyle),
              class: unref(contentClass),
              tabindex: "-1",
              onMouseenter: _cache[0] || (_cache[0] = (e) => _ctx.$emit("mouseenter", e)),
              onMouseleave: _cache[1] || (_cache[1] = (e) => _ctx.$emit("mouseleave", e))
            }), [
              createVNode(unref(ElFocusTrap), {
                trapped: unref(trapped),
                "trap-on-focus-in": true,
                "focus-trap-el": unref(contentRef),
                "focus-start-el": unref(focusStartRef),
                onFocusAfterTrapped: unref(onFocusAfterTrapped),
                onFocusAfterReleased: unref(onFocusAfterReleased),
                onFocusin: unref(onFocusInTrap),
                onFocusoutPrevented: unref(onFocusoutPrevented),
                onReleaseRequested: unref(onReleaseRequested)
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
            ], 16);
          };
        }
      });
      var ElPopperContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$n, [["__file", "content.vue"]]);
      const ElPopper = withInstall(Popper);
      const TOOLTIP_INJECTION_KEY = Symbol("elTooltip");
      const useTooltipContentProps = exports("a7", buildProps({
        ...useDelayedToggleProps,
        ...popperContentProps,
        appendTo: {
          type: definePropType([String, Object])
        },
        content: {
          type: String,
          default: ""
        },
        rawContent: {
          type: Boolean,
          default: false
        },
        persistent: Boolean,
        ariaLabel: String,
        visible: {
          type: definePropType(Boolean),
          default: null
        },
        transition: String,
        teleported: {
          type: Boolean,
          default: true
        },
        disabled: Boolean
      }));
      const useTooltipTriggerProps = buildProps({
        ...popperTriggerProps,
        disabled: Boolean,
        trigger: {
          type: definePropType([String, Array]),
          default: "hover"
        },
        triggerKeys: {
          type: definePropType(Array),
          default: () => [EVENT_CODE.enter, EVENT_CODE.space]
        }
      });
      const {
        useModelToggleProps: useTooltipModelToggleProps,
        useModelToggleEmits: useTooltipModelToggleEmits,
        useModelToggle: useTooltipModelToggle
      } = createModelToggleComposable("visible");
      const useTooltipProps = buildProps({
        ...popperProps,
        ...useTooltipModelToggleProps,
        ...useTooltipContentProps,
        ...useTooltipTriggerProps,
        ...popperArrowProps,
        showArrow: {
          type: Boolean,
          default: true
        }
      });
      const tooltipEmits = [
        ...useTooltipModelToggleEmits,
        "before-show",
        "before-hide",
        "show",
        "hide",
        "open",
        "close"
      ];
      const isTriggerType = (trigger, type) => {
        if (isArray$1(trigger)) {
          return trigger.includes(type);
        }
        return trigger === type;
      };
      const whenTrigger = (trigger, type, handler) => {
        return (e) => {
          isTriggerType(unref(trigger), type) && handler(e);
        };
      };
      const __default__$e = defineComponent({
        name: "ElTooltipTrigger"
      });
      const _sfc_main$m = /* @__PURE__ */ defineComponent({
        ...__default__$e,
        props: useTooltipTriggerProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("tooltip");
          const { controlled, id, open, onOpen, onClose, onToggle } = inject(TOOLTIP_INJECTION_KEY, void 0);
          const triggerRef = ref(null);
          const stopWhenControlledOrDisabled = () => {
            if (unref(controlled) || props.disabled) {
              return true;
            }
          };
          const trigger = toRef(props, "trigger");
          const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "hover", onOpen));
          const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "hover", onClose));
          const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "click", (e) => {
            if (e.button === 0) {
              onToggle(e);
            }
          }));
          const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "focus", onOpen));
          const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "focus", onClose));
          const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "contextmenu", (e) => {
            e.preventDefault();
            onToggle(e);
          }));
          const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e) => {
            const { code: code2 } = e;
            if (props.triggerKeys.includes(code2)) {
              e.preventDefault();
              onToggle(e);
            }
          });
          expose({
            triggerRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElPopperTrigger), {
              id: unref(id),
              "virtual-ref": _ctx.virtualRef,
              open: unref(open),
              "virtual-triggering": _ctx.virtualTriggering,
              class: normalizeClass(unref(ns).e("trigger")),
              onBlur: unref(onBlur),
              onClick: unref(onClick),
              onContextmenu: unref(onContextMenu),
              onFocus: unref(onFocus),
              onMouseenter: unref(onMouseenter),
              onMouseleave: unref(onMouseleave),
              onKeydown: unref(onKeydown)
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
          };
        }
      });
      var ElTooltipTrigger = /* @__PURE__ */ _export_sfc$1(_sfc_main$m, [["__file", "trigger.vue"]]);
      const __default__$d = defineComponent({
        name: "ElTooltipContent",
        inheritAttrs: false
      });
      const _sfc_main$l = /* @__PURE__ */ defineComponent({
        ...__default__$d,
        props: useTooltipContentProps,
        setup(__props, { expose }) {
          const props = __props;
          const { selector } = usePopperContainerId();
          const ns = useNamespace("tooltip");
          const contentRef = ref(null);
          const destroyed = ref(false);
          const {
            controlled,
            id,
            open,
            trigger,
            onClose,
            onOpen,
            onShow,
            onHide,
            onBeforeShow,
            onBeforeHide
          } = inject(TOOLTIP_INJECTION_KEY, void 0);
          const transitionClass = computed$1(() => {
            return props.transition || `${ns.namespace.value}-fade-in-linear`;
          });
          const persistentRef = computed$1(() => {
            return props.persistent;
          });
          onBeforeUnmount(() => {
            destroyed.value = true;
          });
          const shouldRender = computed$1(() => {
            return unref(persistentRef) ? true : unref(open);
          });
          const shouldShow = computed$1(() => {
            return props.disabled ? false : unref(open);
          });
          const appendTo = computed$1(() => {
            return props.appendTo || selector.value;
          });
          const contentStyle = computed$1(() => {
            var _a2;
            return (_a2 = props.style) != null ? _a2 : {};
          });
          const ariaHidden = computed$1(() => !unref(open));
          const onTransitionLeave = () => {
            onHide();
          };
          const stopWhenControlled = () => {
            if (unref(controlled))
              return true;
          };
          const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
            if (props.enterable && unref(trigger) === "hover") {
              onOpen();
            }
          });
          const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
            if (unref(trigger) === "hover") {
              onClose();
            }
          });
          const onBeforeEnter = () => {
            var _a2, _b;
            (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
            onBeforeShow == null ? void 0 : onBeforeShow();
          };
          const onBeforeLeave = () => {
            onBeforeHide == null ? void 0 : onBeforeHide();
          };
          const onAfterShow = () => {
            onShow();
            stopHandle = onClickOutside(computed$1(() => {
              var _a2;
              return (_a2 = contentRef.value) == null ? void 0 : _a2.popperContentRef;
            }), () => {
              if (unref(controlled))
                return;
              const $trigger = unref(trigger);
              if ($trigger !== "hover") {
                onClose();
              }
            });
          };
          const onBlur = () => {
            if (!props.virtualTriggering) {
              onClose();
            }
          };
          let stopHandle;
          watch(() => unref(open), (val) => {
            if (!val) {
              stopHandle == null ? void 0 : stopHandle();
            }
          }, {
            flush: "post"
          });
          watch(() => props.content, () => {
            var _a2, _b;
            (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          });
          expose({
            contentRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Teleport, {
              disabled: !_ctx.teleported,
              to: unref(appendTo)
            }, [
              createVNode(Transition, {
                name: unref(transitionClass),
                onAfterLeave: onTransitionLeave,
                onBeforeEnter,
                onAfterEnter: onAfterShow,
                onBeforeLeave
              }, {
                default: withCtx(() => [
                  unref(shouldRender) ? withDirectives((openBlock(), createBlock(unref(ElPopperContent), mergeProps({
                    key: 0,
                    id: unref(id),
                    ref_key: "contentRef",
                    ref: contentRef
                  }, _ctx.$attrs, {
                    "aria-label": _ctx.ariaLabel,
                    "aria-hidden": unref(ariaHidden),
                    "boundaries-padding": _ctx.boundariesPadding,
                    "fallback-placements": _ctx.fallbackPlacements,
                    "gpu-acceleration": _ctx.gpuAcceleration,
                    offset: _ctx.offset,
                    placement: _ctx.placement,
                    "popper-options": _ctx.popperOptions,
                    strategy: _ctx.strategy,
                    effect: _ctx.effect,
                    enterable: _ctx.enterable,
                    pure: _ctx.pure,
                    "popper-class": _ctx.popperClass,
                    "popper-style": [_ctx.popperStyle, unref(contentStyle)],
                    "reference-el": _ctx.referenceEl,
                    "trigger-target-el": _ctx.triggerTargetEl,
                    visible: unref(shouldShow),
                    "z-index": _ctx.zIndex,
                    onMouseenter: unref(onContentEnter),
                    onMouseleave: unref(onContentLeave),
                    onBlur,
                    onClose: unref(onClose)
                  }), {
                    default: withCtx(() => [
                      !destroyed.value ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                    ]),
                    _: 3
                  }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
                    [vShow, unref(shouldShow)]
                  ]) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["name"])
            ], 8, ["disabled", "to"]);
          };
        }
      });
      var ElTooltipContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$l, [["__file", "content.vue"]]);
      const _hoisted_1$e = ["innerHTML"];
      const _hoisted_2$b = { key: 1 };
      const __default__$c = defineComponent({
        name: "ElTooltip"
      });
      const _sfc_main$k = /* @__PURE__ */ defineComponent({
        ...__default__$c,
        props: useTooltipProps,
        emits: tooltipEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          usePopperContainer();
          const id = useId();
          const popperRef = ref();
          const contentRef = ref();
          const updatePopper = () => {
            var _a2;
            const popperComponent = unref(popperRef);
            if (popperComponent) {
              (_a2 = popperComponent.popperInstanceRef) == null ? void 0 : _a2.update();
            }
          };
          const open = ref(false);
          const toggleReason = ref();
          const { show, hide, hasUpdateHandler } = useTooltipModelToggle({
            indicator: open,
            toggleReason
          });
          const { onOpen, onClose } = useDelayedToggle({
            showAfter: toRef(props, "showAfter"),
            hideAfter: toRef(props, "hideAfter"),
            autoClose: toRef(props, "autoClose"),
            open: show,
            close: hide
          });
          const controlled = computed$1(() => isBoolean(props.visible) && !hasUpdateHandler.value);
          provide(TOOLTIP_INJECTION_KEY, {
            controlled,
            id,
            open: readonly(open),
            trigger: toRef(props, "trigger"),
            onOpen: (event) => {
              onOpen(event);
            },
            onClose: (event) => {
              onClose(event);
            },
            onToggle: (event) => {
              if (unref(open)) {
                onClose(event);
              } else {
                onOpen(event);
              }
            },
            onShow: () => {
              emit("show", toggleReason.value);
            },
            onHide: () => {
              emit("hide", toggleReason.value);
            },
            onBeforeShow: () => {
              emit("before-show", toggleReason.value);
            },
            onBeforeHide: () => {
              emit("before-hide", toggleReason.value);
            },
            updatePopper
          });
          watch(() => props.disabled, (disabled) => {
            if (disabled && open.value) {
              open.value = false;
            }
          });
          const isFocusInsideContent = (event) => {
            var _a2, _b;
            const popperContent = (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.contentRef) == null ? void 0 : _b.popperContentRef;
            const activeElement = (event == null ? void 0 : event.relatedTarget) || document.activeElement;
            return popperContent && popperContent.contains(activeElement);
          };
          onDeactivated(() => open.value && hide());
          expose({
            popperRef,
            contentRef,
            isFocusInsideContent,
            updatePopper,
            onOpen,
            onClose,
            hide
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElPopper), {
              ref_key: "popperRef",
              ref: popperRef,
              role: _ctx.role
            }, {
              default: withCtx(() => [
                createVNode(ElTooltipTrigger, {
                  disabled: _ctx.disabled,
                  trigger: _ctx.trigger,
                  "trigger-keys": _ctx.triggerKeys,
                  "virtual-ref": _ctx.virtualRef,
                  "virtual-triggering": _ctx.virtualTriggering
                }, {
                  default: withCtx(() => [
                    _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
                createVNode(ElTooltipContent, {
                  ref_key: "contentRef",
                  ref: contentRef,
                  "aria-label": _ctx.ariaLabel,
                  "boundaries-padding": _ctx.boundariesPadding,
                  content: _ctx.content,
                  disabled: _ctx.disabled,
                  effect: _ctx.effect,
                  enterable: _ctx.enterable,
                  "fallback-placements": _ctx.fallbackPlacements,
                  "hide-after": _ctx.hideAfter,
                  "gpu-acceleration": _ctx.gpuAcceleration,
                  offset: _ctx.offset,
                  persistent: _ctx.persistent,
                  "popper-class": _ctx.popperClass,
                  "popper-style": _ctx.popperStyle,
                  placement: _ctx.placement,
                  "popper-options": _ctx.popperOptions,
                  pure: _ctx.pure,
                  "raw-content": _ctx.rawContent,
                  "reference-el": _ctx.referenceEl,
                  "trigger-target-el": _ctx.triggerTargetEl,
                  "show-after": _ctx.showAfter,
                  strategy: _ctx.strategy,
                  teleported: _ctx.teleported,
                  transition: _ctx.transition,
                  "virtual-triggering": _ctx.virtualTriggering,
                  "z-index": _ctx.zIndex,
                  "append-to": _ctx.appendTo
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "content", {}, () => [
                      _ctx.rawContent ? (openBlock(), createElementBlock("span", {
                        key: 0,
                        innerHTML: _ctx.content
                      }, null, 8, _hoisted_1$e)) : (openBlock(), createElementBlock("span", _hoisted_2$b, toDisplayString(_ctx.content), 1))
                    ]),
                    _ctx.showArrow ? (openBlock(), createBlock(unref(ElPopperArrow), {
                      key: 0,
                      "arrow-offset": _ctx.arrowOffset
                    }, null, 8, ["arrow-offset"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
              ]),
              _: 3
            }, 8, ["role"]);
          };
        }
      });
      var Tooltip = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["__file", "tooltip.vue"]]);
      const ElTooltip = exports("O", withInstall(Tooltip));
      const buttonGroupContextKey = Symbol("buttonGroupContextKey");
      const useButton = (props, emit) => {
        useDeprecated({
          from: "type.text",
          replacement: "link",
          version: "3.0.0",
          scope: "props",
          ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
        }, computed$1(() => props.type === "text"));
        const buttonGroupContext = inject(buttonGroupContextKey, void 0);
        const globalConfig2 = useGlobalConfig("button");
        const { form } = useFormItem();
        const _size = useFormSize(computed$1(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));
        const _disabled = useFormDisabled();
        const _ref = ref();
        const slots = useSlots();
        const _type = computed$1(() => props.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || "");
        const autoInsertSpace = computed$1(() => {
          var _a2, _b, _c;
          return (_c = (_b = props.autoInsertSpace) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.autoInsertSpace) != null ? _c : false;
        });
        const _props = computed$1(() => {
          if (props.tag === "button") {
            return {
              ariaDisabled: _disabled.value || props.loading,
              disabled: _disabled.value || props.loading,
              autofocus: props.autofocus,
              type: props.nativeType
            };
          }
          return {};
        });
        const shouldAddSpace = computed$1(() => {
          var _a2;
          const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
          if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
            const slot = defaultSlot[0];
            if ((slot == null ? void 0 : slot.type) === Text$1) {
              const text = slot.children;
              return new RegExp("^\\p{Unified_Ideograph}{2}$", "u").test(text.trim());
            }
          }
          return false;
        });
        const handleClick = (evt) => {
          if (props.nativeType === "reset") {
            form == null ? void 0 : form.resetFields();
          }
          emit("click", evt);
        };
        return {
          _disabled,
          _size,
          _type,
          _ref,
          _props,
          shouldAddSpace,
          handleClick
        };
      };
      const buttonTypes = exports("ai", [
        "default",
        "primary",
        "success",
        "warning",
        "info",
        "danger",
        "text",
        ""
      ]);
      const buttonNativeTypes = ["button", "submit", "reset"];
      const buttonProps = buildProps({
        size: useSizeProp,
        disabled: Boolean,
        type: {
          type: String,
          values: buttonTypes,
          default: ""
        },
        icon: {
          type: iconPropType
        },
        nativeType: {
          type: String,
          values: buttonNativeTypes,
          default: "button"
        },
        loading: Boolean,
        loadingIcon: {
          type: iconPropType,
          default: () => loading_default
        },
        plain: Boolean,
        text: Boolean,
        link: Boolean,
        bg: Boolean,
        autofocus: Boolean,
        round: Boolean,
        circle: Boolean,
        color: String,
        dark: Boolean,
        autoInsertSpace: {
          type: Boolean,
          default: void 0
        },
        tag: {
          type: definePropType([String, Object]),
          default: "button"
        }
      });
      const buttonEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      function bound01(n, max) {
        if (isOnePointZero(n)) {
          n = "100%";
        }
        var isPercent = isPercentage(n);
        n = max === 360 ? n : Math.min(max, Math.max(0, parseFloat(n)));
        if (isPercent) {
          n = parseInt(String(n * max), 10) / 100;
        }
        if (Math.abs(n - max) < 1e-6) {
          return 1;
        }
        if (max === 360) {
          n = (n < 0 ? n % max + max : n % max) / parseFloat(String(max));
        } else {
          n = n % max / parseFloat(String(max));
        }
        return n;
      }
      function clamp01(val) {
        return Math.min(1, Math.max(0, val));
      }
      function isOnePointZero(n) {
        return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
      }
      function isPercentage(n) {
        return typeof n === "string" && n.indexOf("%") !== -1;
      }
      function boundAlpha(a2) {
        a2 = parseFloat(a2);
        if (isNaN(a2) || a2 < 0 || a2 > 1) {
          a2 = 1;
        }
        return a2;
      }
      function convertToPercentage(n) {
        if (n <= 1) {
          return "".concat(Number(n) * 100, "%");
        }
        return n;
      }
      function pad2(c2) {
        return c2.length === 1 ? "0" + c2 : String(c2);
      }
      function rgbToRgb(r, g, b2) {
        return {
          r: bound01(r, 255) * 255,
          g: bound01(g, 255) * 255,
          b: bound01(b2, 255) * 255
        };
      }
      function rgbToHsl(r, g, b2) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b2 = bound01(b2, 255);
        var max = Math.max(r, g, b2);
        var min = Math.min(r, g, b2);
        var h2 = 0;
        var s2 = 0;
        var l2 = (max + min) / 2;
        if (max === min) {
          s2 = 0;
          h2 = 0;
        } else {
          var d2 = max - min;
          s2 = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
          switch (max) {
            case r:
              h2 = (g - b2) / d2 + (g < b2 ? 6 : 0);
              break;
            case g:
              h2 = (b2 - r) / d2 + 2;
              break;
            case b2:
              h2 = (r - g) / d2 + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s: s2, l: l2 };
      }
      function hue2rgb(p2, q2, t) {
        if (t < 0) {
          t += 1;
        }
        if (t > 1) {
          t -= 1;
        }
        if (t < 1 / 6) {
          return p2 + (q2 - p2) * (6 * t);
        }
        if (t < 1 / 2) {
          return q2;
        }
        if (t < 2 / 3) {
          return p2 + (q2 - p2) * (2 / 3 - t) * 6;
        }
        return p2;
      }
      function hslToRgb(h2, s2, l2) {
        var r;
        var g;
        var b2;
        h2 = bound01(h2, 360);
        s2 = bound01(s2, 100);
        l2 = bound01(l2, 100);
        if (s2 === 0) {
          g = l2;
          b2 = l2;
          r = l2;
        } else {
          var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
          var p2 = 2 * l2 - q2;
          r = hue2rgb(p2, q2, h2 + 1 / 3);
          g = hue2rgb(p2, q2, h2);
          b2 = hue2rgb(p2, q2, h2 - 1 / 3);
        }
        return { r: r * 255, g: g * 255, b: b2 * 255 };
      }
      function rgbToHsv(r, g, b2) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b2 = bound01(b2, 255);
        var max = Math.max(r, g, b2);
        var min = Math.min(r, g, b2);
        var h2 = 0;
        var v2 = max;
        var d2 = max - min;
        var s2 = max === 0 ? 0 : d2 / max;
        if (max === min) {
          h2 = 0;
        } else {
          switch (max) {
            case r:
              h2 = (g - b2) / d2 + (g < b2 ? 6 : 0);
              break;
            case g:
              h2 = (b2 - r) / d2 + 2;
              break;
            case b2:
              h2 = (r - g) / d2 + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s: s2, v: v2 };
      }
      function hsvToRgb(h2, s2, v2) {
        h2 = bound01(h2, 360) * 6;
        s2 = bound01(s2, 100);
        v2 = bound01(v2, 100);
        var i = Math.floor(h2);
        var f2 = h2 - i;
        var p2 = v2 * (1 - s2);
        var q2 = v2 * (1 - f2 * s2);
        var t = v2 * (1 - (1 - f2) * s2);
        var mod = i % 6;
        var r = [v2, q2, p2, p2, t, v2][mod];
        var g = [t, v2, v2, q2, p2, p2][mod];
        var b2 = [p2, p2, t, v2, v2, q2][mod];
        return { r: r * 255, g: g * 255, b: b2 * 255 };
      }
      function rgbToHex(r, g, b2, allow3Char) {
        var hex = [
          pad2(Math.round(r).toString(16)),
          pad2(Math.round(g).toString(16)),
          pad2(Math.round(b2).toString(16))
        ];
        if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }
        return hex.join("");
      }
      function rgbaToHex(r, g, b2, a2, allow4Char) {
        var hex = [
          pad2(Math.round(r).toString(16)),
          pad2(Math.round(g).toString(16)),
          pad2(Math.round(b2).toString(16)),
          pad2(convertDecimalToHex(a2))
        ];
        if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
        }
        return hex.join("");
      }
      function convertDecimalToHex(d2) {
        return Math.round(parseFloat(d2) * 255).toString(16);
      }
      function convertHexToDecimal(h2) {
        return parseIntFromHex(h2) / 255;
      }
      function parseIntFromHex(val) {
        return parseInt(val, 16);
      }
      function numberInputToObject(color) {
        return {
          r: color >> 16,
          g: (color & 65280) >> 8,
          b: color & 255
        };
      }
      var names = {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        goldenrod: "#daa520",
        gold: "#ffd700",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavenderblush: "#fff0f5",
        lavender: "#e6e6fa",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        rebeccapurple: "#663399",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32"
      };
      function inputToRGB(color) {
        var rgb = { r: 0, g: 0, b: 0 };
        var a2 = 1;
        var s2 = null;
        var v2 = null;
        var l2 = null;
        var ok = false;
        var format = false;
        if (typeof color === "string") {
          color = stringInputToObject(color);
        }
        if (typeof color === "object") {
          if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s2 = convertToPercentage(color.s);
            v2 = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s2, v2);
            ok = true;
            format = "hsv";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s2 = convertToPercentage(color.s);
            l2 = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s2, l2);
            ok = true;
            format = "hsl";
          }
          if (Object.prototype.hasOwnProperty.call(color, "a")) {
            a2 = color.a;
          }
        }
        a2 = boundAlpha(a2);
        return {
          ok,
          format: color.format || format,
          r: Math.min(255, Math.max(rgb.r, 0)),
          g: Math.min(255, Math.max(rgb.g, 0)),
          b: Math.min(255, Math.max(rgb.b, 0)),
          a: a2
        };
      }
      var CSS_INTEGER = "[-\\+]?\\d+%?";
      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var matchers = {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
      function stringInputToObject(color) {
        color = color.trim().toLowerCase();
        if (color.length === 0) {
          return false;
        }
        var named = false;
        if (names[color]) {
          color = names[color];
          named = true;
        } else if (color === "transparent") {
          return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }
        var match = matchers.rgb.exec(color);
        if (match) {
          return { r: match[1], g: match[2], b: match[3] };
        }
        match = matchers.rgba.exec(color);
        if (match) {
          return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        match = matchers.hsl.exec(color);
        if (match) {
          return { h: match[1], s: match[2], l: match[3] };
        }
        match = matchers.hsla.exec(color);
        if (match) {
          return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        match = matchers.hsv.exec(color);
        if (match) {
          return { h: match[1], s: match[2], v: match[3] };
        }
        match = matchers.hsva.exec(color);
        if (match) {
          return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        match = matchers.hex8.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
          };
        }
        match = matchers.hex6.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
          };
        }
        match = matchers.hex4.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1] + match[1]),
            g: parseIntFromHex(match[2] + match[2]),
            b: parseIntFromHex(match[3] + match[3]),
            a: convertHexToDecimal(match[4] + match[4]),
            format: named ? "name" : "hex8"
          };
        }
        match = matchers.hex3.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1] + match[1]),
            g: parseIntFromHex(match[2] + match[2]),
            b: parseIntFromHex(match[3] + match[3]),
            format: named ? "name" : "hex"
          };
        }
        return false;
      }
      function isValidCSSUnit(color) {
        return Boolean(matchers.CSS_UNIT.exec(String(color)));
      }
      var TinyColor = exports("aZ", (
        /** @class */
        function() {
          function TinyColor2(color, opts) {
            if (color === void 0) {
              color = "";
            }
            if (opts === void 0) {
              opts = {};
            }
            var _a2;
            if (color instanceof TinyColor2) {
              return color;
            }
            if (typeof color === "number") {
              color = numberInputToObject(color);
            }
            this.originalInput = color;
            var rgb = inputToRGB(color);
            this.originalInput = color;
            this.r = rgb.r;
            this.g = rgb.g;
            this.b = rgb.b;
            this.a = rgb.a;
            this.roundA = Math.round(100 * this.a) / 100;
            this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
            this.gradientType = opts.gradientType;
            if (this.r < 1) {
              this.r = Math.round(this.r);
            }
            if (this.g < 1) {
              this.g = Math.round(this.g);
            }
            if (this.b < 1) {
              this.b = Math.round(this.b);
            }
            this.isValid = rgb.ok;
          }
          TinyColor2.prototype.isDark = function() {
            return this.getBrightness() < 128;
          };
          TinyColor2.prototype.isLight = function() {
            return !this.isDark();
          };
          TinyColor2.prototype.getBrightness = function() {
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
          };
          TinyColor2.prototype.getLuminance = function() {
            var rgb = this.toRgb();
            var R2;
            var G2;
            var B2;
            var RsRGB = rgb.r / 255;
            var GsRGB = rgb.g / 255;
            var BsRGB = rgb.b / 255;
            if (RsRGB <= 0.03928) {
              R2 = RsRGB / 12.92;
            } else {
              R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
            }
            if (GsRGB <= 0.03928) {
              G2 = GsRGB / 12.92;
            } else {
              G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
            }
            if (BsRGB <= 0.03928) {
              B2 = BsRGB / 12.92;
            } else {
              B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
            }
            return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
          };
          TinyColor2.prototype.getAlpha = function() {
            return this.a;
          };
          TinyColor2.prototype.setAlpha = function(alpha) {
            this.a = boundAlpha(alpha);
            this.roundA = Math.round(100 * this.a) / 100;
            return this;
          };
          TinyColor2.prototype.isMonochrome = function() {
            var s2 = this.toHsl().s;
            return s2 === 0;
          };
          TinyColor2.prototype.toHsv = function() {
            var hsv = rgbToHsv(this.r, this.g, this.b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
          };
          TinyColor2.prototype.toHsvString = function() {
            var hsv = rgbToHsv(this.r, this.g, this.b);
            var h2 = Math.round(hsv.h * 360);
            var s2 = Math.round(hsv.s * 100);
            var v2 = Math.round(hsv.v * 100);
            return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toHsl = function() {
            var hsl = rgbToHsl(this.r, this.g, this.b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
          };
          TinyColor2.prototype.toHslString = function() {
            var hsl = rgbToHsl(this.r, this.g, this.b);
            var h2 = Math.round(hsl.h * 360);
            var s2 = Math.round(hsl.s * 100);
            var l2 = Math.round(hsl.l * 100);
            return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toHex = function(allow3Char) {
            if (allow3Char === void 0) {
              allow3Char = false;
            }
            return rgbToHex(this.r, this.g, this.b, allow3Char);
          };
          TinyColor2.prototype.toHexString = function(allow3Char) {
            if (allow3Char === void 0) {
              allow3Char = false;
            }
            return "#" + this.toHex(allow3Char);
          };
          TinyColor2.prototype.toHex8 = function(allow4Char) {
            if (allow4Char === void 0) {
              allow4Char = false;
            }
            return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
          };
          TinyColor2.prototype.toHex8String = function(allow4Char) {
            if (allow4Char === void 0) {
              allow4Char = false;
            }
            return "#" + this.toHex8(allow4Char);
          };
          TinyColor2.prototype.toHexShortString = function(allowShortChar) {
            if (allowShortChar === void 0) {
              allowShortChar = false;
            }
            return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
          };
          TinyColor2.prototype.toRgb = function() {
            return {
              r: Math.round(this.r),
              g: Math.round(this.g),
              b: Math.round(this.b),
              a: this.a
            };
          };
          TinyColor2.prototype.toRgbString = function() {
            var r = Math.round(this.r);
            var g = Math.round(this.g);
            var b2 = Math.round(this.b);
            return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b2, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b2, ", ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toPercentageRgb = function() {
            var fmt = function(x2) {
              return "".concat(Math.round(bound01(x2, 255) * 100), "%");
            };
            return {
              r: fmt(this.r),
              g: fmt(this.g),
              b: fmt(this.b),
              a: this.a
            };
          };
          TinyColor2.prototype.toPercentageRgbString = function() {
            var rnd = function(x2) {
              return Math.round(bound01(x2, 255) * 100);
            };
            return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toName = function() {
            if (this.a === 0) {
              return "transparent";
            }
            if (this.a < 1) {
              return false;
            }
            var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
            for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
              var _b = _a2[_i], key = _b[0], value = _b[1];
              if (hex === value) {
                return key;
              }
            }
            return false;
          };
          TinyColor2.prototype.toString = function(format) {
            var formatSet = Boolean(format);
            format = format !== null && format !== void 0 ? format : this.format;
            var formattedString = false;
            var hasAlpha = this.a < 1 && this.a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format.startsWith("hex") || format === "name");
            if (needsAlphaFormat) {
              if (format === "name" && this.a === 0) {
                return this.toName();
              }
              return this.toRgbString();
            }
            if (format === "rgb") {
              formattedString = this.toRgbString();
            }
            if (format === "prgb") {
              formattedString = this.toPercentageRgbString();
            }
            if (format === "hex" || format === "hex6") {
              formattedString = this.toHexString();
            }
            if (format === "hex3") {
              formattedString = this.toHexString(true);
            }
            if (format === "hex4") {
              formattedString = this.toHex8String(true);
            }
            if (format === "hex8") {
              formattedString = this.toHex8String();
            }
            if (format === "name") {
              formattedString = this.toName();
            }
            if (format === "hsl") {
              formattedString = this.toHslString();
            }
            if (format === "hsv") {
              formattedString = this.toHsvString();
            }
            return formattedString || this.toHexString();
          };
          TinyColor2.prototype.toNumber = function() {
            return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
          };
          TinyColor2.prototype.clone = function() {
            return new TinyColor2(this.toString());
          };
          TinyColor2.prototype.lighten = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.l += amount / 100;
            hsl.l = clamp01(hsl.l);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.brighten = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var rgb = this.toRgb();
            rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
            rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
            rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
            return new TinyColor2(rgb);
          };
          TinyColor2.prototype.darken = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.l -= amount / 100;
            hsl.l = clamp01(hsl.l);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.tint = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            return this.mix("white", amount);
          };
          TinyColor2.prototype.shade = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            return this.mix("black", amount);
          };
          TinyColor2.prototype.desaturate = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.s -= amount / 100;
            hsl.s = clamp01(hsl.s);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.saturate = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.s += amount / 100;
            hsl.s = clamp01(hsl.s);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.greyscale = function() {
            return this.desaturate(100);
          };
          TinyColor2.prototype.spin = function(amount) {
            var hsl = this.toHsl();
            var hue = (hsl.h + amount) % 360;
            hsl.h = hue < 0 ? 360 + hue : hue;
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.mix = function(color, amount) {
            if (amount === void 0) {
              amount = 50;
            }
            var rgb1 = this.toRgb();
            var rgb2 = new TinyColor2(color).toRgb();
            var p2 = amount / 100;
            var rgba = {
              r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
              g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
              b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
              a: (rgb2.a - rgb1.a) * p2 + rgb1.a
            };
            return new TinyColor2(rgba);
          };
          TinyColor2.prototype.analogous = function(results, slices) {
            if (results === void 0) {
              results = 6;
            }
            if (slices === void 0) {
              slices = 30;
            }
            var hsl = this.toHsl();
            var part = 360 / slices;
            var ret = [this];
            for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
              hsl.h = (hsl.h + part) % 360;
              ret.push(new TinyColor2(hsl));
            }
            return ret;
          };
          TinyColor2.prototype.complement = function() {
            var hsl = this.toHsl();
            hsl.h = (hsl.h + 180) % 360;
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.monochromatic = function(results) {
            if (results === void 0) {
              results = 6;
            }
            var hsv = this.toHsv();
            var h2 = hsv.h;
            var s2 = hsv.s;
            var v2 = hsv.v;
            var res = [];
            var modification = 1 / results;
            while (results--) {
              res.push(new TinyColor2({ h: h2, s: s2, v: v2 }));
              v2 = (v2 + modification) % 1;
            }
            return res;
          };
          TinyColor2.prototype.splitcomplement = function() {
            var hsl = this.toHsl();
            var h2 = hsl.h;
            return [
              this,
              new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
              new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
            ];
          };
          TinyColor2.prototype.onBackground = function(background) {
            var fg = this.toRgb();
            var bg = new TinyColor2(background).toRgb();
            var alpha = fg.a + bg.a * (1 - fg.a);
            return new TinyColor2({
              r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
              g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
              b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
              a: alpha
            });
          };
          TinyColor2.prototype.triad = function() {
            return this.polyad(3);
          };
          TinyColor2.prototype.tetrad = function() {
            return this.polyad(4);
          };
          TinyColor2.prototype.polyad = function(n) {
            var hsl = this.toHsl();
            var h2 = hsl.h;
            var result = [this];
            var increment = 360 / n;
            for (var i = 1; i < n; i++) {
              result.push(new TinyColor2({ h: (h2 + i * increment) % 360, s: hsl.s, l: hsl.l }));
            }
            return result;
          };
          TinyColor2.prototype.equals = function(color) {
            return this.toRgbString() === new TinyColor2(color).toRgbString();
          };
          return TinyColor2;
        }()
      ));
      function darken(color, amount = 20) {
        return color.mix("#141414", amount).toString();
      }
      function useButtonCustomStyle(props) {
        const _disabled = useFormDisabled();
        const ns = useNamespace("button");
        return computed$1(() => {
          let styles = {};
          const buttonColor = props.color;
          if (buttonColor) {
            const color = new TinyColor(buttonColor);
            const activeBgColor = props.dark ? color.tint(20).toString() : darken(color, 20);
            if (props.plain) {
              styles = ns.cssVarBlock({
                "bg-color": props.dark ? darken(color, 90) : color.tint(90).toString(),
                "text-color": buttonColor,
                "border-color": props.dark ? darken(color, 50) : color.tint(50).toString(),
                "hover-text-color": `var(${ns.cssVarName("color-white")})`,
                "hover-bg-color": buttonColor,
                "hover-border-color": buttonColor,
                "active-bg-color": activeBgColor,
                "active-text-color": `var(${ns.cssVarName("color-white")})`,
                "active-border-color": activeBgColor
              });
              if (_disabled.value) {
                styles[ns.cssVarBlockName("disabled-bg-color")] = props.dark ? darken(color, 90) : color.tint(90).toString();
                styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? darken(color, 50) : color.tint(50).toString();
                styles[ns.cssVarBlockName("disabled-border-color")] = props.dark ? darken(color, 80) : color.tint(80).toString();
              }
            } else {
              const hoverBgColor = props.dark ? darken(color, 30) : color.tint(30).toString();
              const textColor = color.isDark() ? `var(${ns.cssVarName("color-white")})` : `var(${ns.cssVarName("color-black")})`;
              styles = ns.cssVarBlock({
                "bg-color": buttonColor,
                "text-color": textColor,
                "border-color": buttonColor,
                "hover-bg-color": hoverBgColor,
                "hover-text-color": textColor,
                "hover-border-color": hoverBgColor,
                "active-bg-color": activeBgColor,
                "active-border-color": activeBgColor
              });
              if (_disabled.value) {
                const disabledButtonColor = props.dark ? darken(color, 50) : color.tint(50).toString();
                styles[ns.cssVarBlockName("disabled-bg-color")] = disabledButtonColor;
                styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? "rgba(255, 255, 255, 0.5)" : `var(${ns.cssVarName("color-white")})`;
                styles[ns.cssVarBlockName("disabled-border-color")] = disabledButtonColor;
              }
            }
          }
          return styles;
        });
      }
      const __default__$b = defineComponent({
        name: "ElButton"
      });
      const _sfc_main$j = /* @__PURE__ */ defineComponent({
        ...__default__$b,
        props: buttonProps,
        emits: buttonEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const buttonStyle = useButtonCustomStyle(props);
          const ns = useNamespace("button");
          const { _ref, _size, _type, _disabled, _props, shouldAddSpace, handleClick } = useButton(props, emit);
          const buttonKls = computed$1(() => [
            ns.b(),
            ns.m(_type.value),
            ns.m(_size.value),
            ns.is("disabled", _disabled.value),
            ns.is("loading", props.loading),
            ns.is("plain", props.plain),
            ns.is("round", props.round),
            ns.is("circle", props.circle),
            ns.is("text", props.text),
            ns.is("link", props.link),
            ns.is("has-bg", props.bg)
          ]);
          expose({
            ref: _ref,
            size: _size,
            type: _type,
            disabled: _disabled,
            shouldAddSpace
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), mergeProps({
              ref_key: "_ref",
              ref: _ref
            }, unref(_props), {
              class: unref(buttonKls),
              style: unref(buttonStyle),
              onClick: unref(handleClick)
            }), {
              default: withCtx(() => [
                _ctx.loading ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  _ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }) : (openBlock(), createBlock(unref(ElIcon), {
                    key: 1,
                    class: normalizeClass(unref(ns).is("loading"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.loadingIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"]))
                ], 64)) : _ctx.icon || _ctx.$slots.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                  default: withCtx(() => [
                    _ctx.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon), { key: 0 })) : renderSlot(_ctx.$slots, "icon", { key: 1 })
                  ]),
                  _: 3
                })) : createCommentVNode("v-if", true),
                _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
                  key: 2,
                  class: normalizeClass({ [unref(ns).em("text", "expand")]: unref(shouldAddSpace) })
                }, [
                  renderSlot(_ctx.$slots, "default")
                ], 2)) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16, ["class", "style", "onClick"]);
          };
        }
      });
      var Button = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["__file", "button.vue"]]);
      const buttonGroupProps = {
        size: buttonProps.size,
        type: buttonProps.type
      };
      const __default__$a = defineComponent({
        name: "ElButtonGroup"
      });
      const _sfc_main$i = /* @__PURE__ */ defineComponent({
        ...__default__$a,
        props: buttonGroupProps,
        setup(__props) {
          const props = __props;
          provide(buttonGroupContextKey, reactive({
            size: toRef(props, "size"),
            type: toRef(props, "type")
          }));
          const ns = useNamespace("button");
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(`${unref(ns).b("group")}`)
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var ButtonGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["__file", "button-group.vue"]]);
      const ElButton = exports("a", withInstall(Button, {
        ButtonGroup
      }));
      const ElButtonGroup = exports("bD", withNoopInstall(ButtonGroup));
      const nodeList = /* @__PURE__ */ new Map();
      let startClick;
      if (isClient) {
        document.addEventListener("mousedown", (e) => startClick = e);
        document.addEventListener("mouseup", (e) => {
          for (const handlers of nodeList.values()) {
            for (const { documentHandler } of handlers) {
              documentHandler(e, startClick);
            }
          }
        });
      }
      function createDocumentHandler(el, binding) {
        let excludes = [];
        if (Array.isArray(binding.arg)) {
          excludes = binding.arg;
        } else if (isElement(binding.arg)) {
          excludes.push(binding.arg);
        }
        return function(mouseup, mousedown) {
          const popperRef = binding.instance.popperRef;
          const mouseUpTarget = mouseup.target;
          const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
          const isBound = !binding || !binding.instance;
          const isTargetExists = !mouseUpTarget || !mouseDownTarget;
          const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
          const isSelf = el === mouseUpTarget;
          const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
          const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
          if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
            return;
          }
          binding.value(mouseup, mousedown);
        };
      }
      const ClickOutside = exports("a6", {
        beforeMount(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          nodeList.get(el).push({
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          });
        },
        updated(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          const handlers = nodeList.get(el);
          const oldHandlerIndex = handlers.findIndex((item) => item.bindingFn === binding.oldValue);
          const newHandler = {
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          };
          if (oldHandlerIndex >= 0) {
            handlers.splice(oldHandlerIndex, 1, newHandler);
          } else {
            handlers.push(newHandler);
          }
        },
        unmounted(el) {
          nodeList.delete(el);
        }
      });
      var v = false, o, f, s, u, d, N, l, p, m, w, D, x, E, M, F;
      function a() {
        if (!v) {
          v = true;
          var e = navigator.userAgent, n = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e), i = /(Mac OS X)|(Windows)|(Linux)/.exec(e);
          if (x = /\b(iPhone|iP[ao]d)/.exec(e), E = /\b(iP[ao]d)/.exec(e), w = /Android/i.exec(e), M = /FBAN\/\w+;/i.exec(e), F = /Mobile/i.exec(e), D = !!/Win64/.exec(e), n) {
            o = n[1] ? parseFloat(n[1]) : n[5] ? parseFloat(n[5]) : NaN, o && document && document.documentMode && (o = document.documentMode);
            var r = /(?:Trident\/(\d+.\d+))/.exec(e);
            N = r ? parseFloat(r[1]) + 4 : o, f = n[2] ? parseFloat(n[2]) : NaN, s = n[3] ? parseFloat(n[3]) : NaN, u = n[4] ? parseFloat(n[4]) : NaN, u ? (n = /(?:Chrome\/(\d+\.\d+))/.exec(e), d = n && n[1] ? parseFloat(n[1]) : NaN) : d = NaN;
          } else
            o = f = s = d = u = NaN;
          if (i) {
            if (i[1]) {
              var t = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);
              l = t ? parseFloat(t[1].replace("_", ".")) : true;
            } else
              l = false;
            p = !!i[2], m = !!i[3];
          } else
            l = p = m = false;
        }
      }
      var _ = { ie: function() {
        return a() || o;
      }, ieCompatibilityMode: function() {
        return a() || N > o;
      }, ie64: function() {
        return _.ie() && D;
      }, firefox: function() {
        return a() || f;
      }, opera: function() {
        return a() || s;
      }, webkit: function() {
        return a() || u;
      }, safari: function() {
        return _.webkit();
      }, chrome: function() {
        return a() || d;
      }, windows: function() {
        return a() || p;
      }, osx: function() {
        return a() || l;
      }, linux: function() {
        return a() || m;
      }, iphone: function() {
        return a() || x;
      }, mobile: function() {
        return a() || x || E || w || F;
      }, nativeApp: function() {
        return a() || M;
      }, android: function() {
        return a() || w;
      }, ipad: function() {
        return a() || E;
      } }, A = _;
      var c = !!(typeof window < "u" && window.document && window.document.createElement), U = { canUseDOM: c, canUseWorkers: typeof Worker < "u", canUseEventListeners: c && !!(window.addEventListener || window.attachEvent), canUseViewport: c && !!window.screen, isInWorker: !c }, h = U;
      var X;
      h.canUseDOM && (X = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== true);
      function S(e, n) {
        if (!h.canUseDOM || n && !("addEventListener" in document))
          return false;
        var i = "on" + e, r = i in document;
        if (!r) {
          var t = document.createElement("div");
          t.setAttribute(i, "return;"), r = typeof t[i] == "function";
        }
        return !r && X && e === "wheel" && (r = document.implementation.hasFeature("Events.wheel", "3.0")), r;
      }
      var b = S;
      var O = 10, I = 40, P = 800;
      function T(e) {
        var n = 0, i = 0, r = 0, t = 0;
        return "detail" in e && (i = e.detail), "wheelDelta" in e && (i = -e.wheelDelta / 120), "wheelDeltaY" in e && (i = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (n = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (n = i, i = 0), r = n * O, t = i * O, "deltaY" in e && (t = e.deltaY), "deltaX" in e && (r = e.deltaX), (r || t) && e.deltaMode && (e.deltaMode == 1 ? (r *= I, t *= I) : (r *= P, t *= P)), r && !n && (n = r < 1 ? -1 : 1), t && !i && (i = t < 1 ? -1 : 1), { spinX: n, spinY: i, pixelX: r, pixelY: t };
      }
      T.getEventType = function() {
        return A.firefox() ? "DOMMouseScroll" : b("wheel") ? "wheel" : "mousewheel";
      };
      var Y = T;
      /**
      * Checks if an event is supported in the current execution environment.
      *
      * NOTE: This will not work correctly for non-generic events such as `change`,
      * `reset`, `load`, `error`, and `select`.
      *
      * Borrows from Modernizr.
      *
      * @param {string} eventNameSuffix Event name, e.g. "click".
      * @param {?boolean} capture Check if the capture phase is supported.
      * @return {boolean} True if the event is supported.
      * @internal
      * @license Modernizr 3.0.0pre (Custom Build) | MIT
      */
      const mousewheel = function(element, callback) {
        if (element && element.addEventListener) {
          const fn2 = function(event) {
            const normalized = Y(event);
            callback && Reflect.apply(callback, this, [event, normalized]);
          };
          element.addEventListener("wheel", fn2, { passive: true });
        }
      };
      const Mousewheel = {
        beforeMount(el, binding) {
          mousewheel(el, binding.value);
        }
      };
      const checkboxProps = {
        modelValue: {
          type: [Number, String, Boolean],
          default: void 0
        },
        label: {
          type: [String, Boolean, Number, Object],
          default: void 0
        },
        value: {
          type: [String, Boolean, Number, Object],
          default: void 0
        },
        indeterminate: Boolean,
        disabled: Boolean,
        checked: Boolean,
        name: {
          type: String,
          default: void 0
        },
        trueValue: {
          type: [String, Number],
          default: void 0
        },
        falseValue: {
          type: [String, Number],
          default: void 0
        },
        trueLabel: {
          type: [String, Number],
          default: void 0
        },
        falseLabel: {
          type: [String, Number],
          default: void 0
        },
        id: {
          type: String,
          default: void 0
        },
        controls: {
          type: String,
          default: void 0
        },
        border: Boolean,
        size: useSizeProp,
        tabindex: [String, Number],
        validateEvent: {
          type: Boolean,
          default: true
        }
      };
      const checkboxEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isString(val) || isNumber(val) || isBoolean(val),
        change: (val) => isString(val) || isNumber(val) || isBoolean(val)
      };
      const checkboxGroupContextKey = Symbol("checkboxGroupContextKey");
      const useCheckboxDisabled = ({
        model,
        isChecked
      }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isLimitDisabled = computed$1(() => {
          var _a2, _b;
          const max = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a2.value;
          const min = (_b = checkboxGroup == null ? void 0 : checkboxGroup.min) == null ? void 0 : _b.value;
          return !isUndefined(max) && model.value.length >= max && !isChecked.value || !isUndefined(min) && model.value.length <= min && isChecked.value;
        });
        const isDisabled = useFormDisabled(computed$1(() => (checkboxGroup == null ? void 0 : checkboxGroup.disabled.value) || isLimitDisabled.value));
        return {
          isDisabled,
          isLimitDisabled
        };
      };
      const useCheckboxEvent = (props, {
        model,
        isLimitExceeded,
        hasOwnLabel,
        isDisabled,
        isLabeledByFormItem
      }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const { formItem } = useFormItem();
        const { emit } = getCurrentInstance();
        function getLabeledValue(value) {
          var _a2, _b, _c, _d;
          return [true, props.trueValue, props.trueLabel].includes(value) ? (_b = (_a2 = props.trueValue) != null ? _a2 : props.trueLabel) != null ? _b : true : (_d = (_c = props.falseValue) != null ? _c : props.falseLabel) != null ? _d : false;
        }
        function emitChangeEvent(checked, e) {
          emit("change", getLabeledValue(checked), e);
        }
        function handleChange(e) {
          if (isLimitExceeded.value)
            return;
          const target = e.target;
          emit("change", getLabeledValue(target.checked), e);
        }
        async function onClickRoot(e) {
          if (isLimitExceeded.value)
            return;
          if (!hasOwnLabel.value && !isDisabled.value && isLabeledByFormItem.value) {
            const eventTargets = e.composedPath();
            const hasLabel = eventTargets.some((item) => item.tagName === "LABEL");
            if (!hasLabel) {
              model.value = getLabeledValue([false, props.falseValue, props.falseLabel].includes(model.value));
              await nextTick();
              emitChangeEvent(model.value, e);
            }
          }
        }
        const validateEvent = computed$1(() => (checkboxGroup == null ? void 0 : checkboxGroup.validateEvent) || props.validateEvent);
        watch(() => props.modelValue, () => {
          if (validateEvent.value) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
        });
        return {
          handleChange,
          onClickRoot
        };
      };
      const useCheckboxModel = (props) => {
        const selfModel = ref(false);
        const { emit } = getCurrentInstance();
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isGroup = computed$1(() => isUndefined(checkboxGroup) === false);
        const isLimitExceeded = ref(false);
        const model = computed$1({
          get() {
            var _a2, _b;
            return isGroup.value ? (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.modelValue) == null ? void 0 : _a2.value : (_b = props.modelValue) != null ? _b : selfModel.value;
          },
          set(val) {
            var _a2, _b;
            if (isGroup.value && isArray$1(val)) {
              isLimitExceeded.value = ((_a2 = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a2.value) !== void 0 && val.length > (checkboxGroup == null ? void 0 : checkboxGroup.max.value) && val.length > model.value.length;
              isLimitExceeded.value === false && ((_b = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _b.call(checkboxGroup, val));
            } else {
              emit(UPDATE_MODEL_EVENT, val);
              selfModel.value = val;
            }
          }
        });
        return {
          model,
          isGroup,
          isLimitExceeded
        };
      };
      const useCheckboxStatus = (props, slots, { model }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isFocused = ref(false);
        const actualValue = computed$1(() => {
          if (!isPropAbsent(props.value)) {
            return props.value;
          }
          return props.label;
        });
        const isChecked = computed$1(() => {
          const value = model.value;
          if (isBoolean(value)) {
            return value;
          } else if (isArray$1(value)) {
            if (isObject$1(actualValue.value)) {
              return value.map(toRaw$1).some((o2) => isEqual(o2, actualValue.value));
            } else {
              return value.map(toRaw$1).includes(actualValue.value);
            }
          } else if (value !== null && value !== void 0) {
            return value === props.trueValue || value === props.trueLabel;
          } else {
            return !!value;
          }
        });
        const checkboxButtonSize = useFormSize(computed$1(() => {
          var _a2;
          return (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a2.value;
        }), {
          prop: true
        });
        const checkboxSize = useFormSize(computed$1(() => {
          var _a2;
          return (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a2.value;
        }));
        const hasOwnLabel = computed$1(() => {
          return !!slots.default || !isPropAbsent(actualValue.value);
        });
        return {
          checkboxButtonSize,
          isChecked,
          isFocused,
          checkboxSize,
          hasOwnLabel,
          actualValue
        };
      };
      const useCheckbox = (props, slots) => {
        const { formItem: elFormItem } = useFormItem();
        const { model, isGroup, isLimitExceeded } = useCheckboxModel(props);
        const {
          isFocused,
          isChecked,
          checkboxButtonSize,
          checkboxSize,
          hasOwnLabel,
          actualValue
        } = useCheckboxStatus(props, slots, { model });
        const { isDisabled } = useCheckboxDisabled({ model, isChecked });
        const { inputId, isLabeledByFormItem } = useFormItemInputId(props, {
          formItemContext: elFormItem,
          disableIdGeneration: hasOwnLabel,
          disableIdManagement: isGroup
        });
        const { handleChange, onClickRoot } = useCheckboxEvent(props, {
          model,
          isLimitExceeded,
          hasOwnLabel,
          isDisabled,
          isLabeledByFormItem
        });
        const setStoreValue = () => {
          function addToStore() {
            var _a2, _b;
            if (isArray$1(model.value) && !model.value.includes(actualValue.value)) {
              model.value.push(actualValue.value);
            } else {
              model.value = (_b = (_a2 = props.trueValue) != null ? _a2 : props.trueLabel) != null ? _b : true;
            }
          }
          props.checked && addToStore();
        };
        setStoreValue();
        useDeprecated({
          from: "label act as value",
          replacement: "value",
          version: "3.0.0",
          scope: "el-checkbox",
          ref: "https://element-plus.org/en-US/component/checkbox.html"
        }, computed$1(() => isGroup.value && isPropAbsent(props.value)));
        useDeprecated({
          from: "true-label",
          replacement: "true-value",
          version: "3.0.0",
          scope: "el-checkbox",
          ref: "https://element-plus.org/en-US/component/checkbox.html"
        }, computed$1(() => !!props.trueLabel));
        useDeprecated({
          from: "false-label",
          replacement: "false-value",
          version: "3.0.0",
          scope: "el-checkbox",
          ref: "https://element-plus.org/en-US/component/checkbox.html"
        }, computed$1(() => !!props.falseLabel));
        return {
          inputId,
          isLabeledByFormItem,
          isChecked,
          isDisabled,
          isFocused,
          checkboxButtonSize,
          checkboxSize,
          hasOwnLabel,
          model,
          actualValue,
          handleChange,
          onClickRoot
        };
      };
      const _hoisted_1$d = ["id", "indeterminate", "name", "tabindex", "disabled", "true-value", "false-value"];
      const _hoisted_2$a = ["id", "indeterminate", "disabled", "value", "name", "tabindex"];
      const __default__$9 = defineComponent({
        name: "ElCheckbox"
      });
      const _sfc_main$h = /* @__PURE__ */ defineComponent({
        ...__default__$9,
        props: checkboxProps,
        emits: checkboxEmits,
        setup(__props) {
          const props = __props;
          const slots = useSlots();
          const {
            inputId,
            isLabeledByFormItem,
            isChecked,
            isDisabled,
            isFocused,
            checkboxSize,
            hasOwnLabel,
            model,
            actualValue,
            handleChange,
            onClickRoot
          } = useCheckbox(props, slots);
          const ns = useNamespace("checkbox");
          const compKls = computed$1(() => {
            return [
              ns.b(),
              ns.m(checkboxSize.value),
              ns.is("disabled", isDisabled.value),
              ns.is("bordered", props.border),
              ns.is("checked", isChecked.value)
            ];
          });
          const spanKls = computed$1(() => {
            return [
              ns.e("input"),
              ns.is("disabled", isDisabled.value),
              ns.is("checked", isChecked.value),
              ns.is("indeterminate", props.indeterminate),
              ns.is("focus", isFocused.value)
            ];
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(!unref(hasOwnLabel) && unref(isLabeledByFormItem) ? "span" : "label"), {
              class: normalizeClass(unref(compKls)),
              "aria-controls": _ctx.indeterminate ? _ctx.controls : null,
              onClick: unref(onClickRoot)
            }, {
              default: withCtx(() => {
                var _a2, _b;
                return [
                  createElementVNode("span", {
                    class: normalizeClass(unref(spanKls))
                  }, [
                    _ctx.trueValue || _ctx.falseValue || _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
                      key: 0,
                      id: unref(inputId),
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(model) ? model.value = $event : null),
                      class: normalizeClass(unref(ns).e("original")),
                      type: "checkbox",
                      indeterminate: _ctx.indeterminate,
                      name: _ctx.name,
                      tabindex: _ctx.tabindex,
                      disabled: unref(isDisabled),
                      "true-value": (_a2 = _ctx.trueValue) != null ? _a2 : _ctx.trueLabel,
                      "false-value": (_b = _ctx.falseValue) != null ? _b : _ctx.falseLabel,
                      onChange: _cache[1] || (_cache[1] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                      onFocus: _cache[2] || (_cache[2] = ($event) => isFocused.value = true),
                      onBlur: _cache[3] || (_cache[3] = ($event) => isFocused.value = false),
                      onClick: _cache[4] || (_cache[4] = withModifiers(() => {
                      }, ["stop"]))
                    }, null, 42, _hoisted_1$d)), [
                      [vModelCheckbox, unref(model)]
                    ]) : withDirectives((openBlock(), createElementBlock("input", {
                      key: 1,
                      id: unref(inputId),
                      "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => isRef(model) ? model.value = $event : null),
                      class: normalizeClass(unref(ns).e("original")),
                      type: "checkbox",
                      indeterminate: _ctx.indeterminate,
                      disabled: unref(isDisabled),
                      value: unref(actualValue),
                      name: _ctx.name,
                      tabindex: _ctx.tabindex,
                      onChange: _cache[6] || (_cache[6] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                      onFocus: _cache[7] || (_cache[7] = ($event) => isFocused.value = true),
                      onBlur: _cache[8] || (_cache[8] = ($event) => isFocused.value = false),
                      onClick: _cache[9] || (_cache[9] = withModifiers(() => {
                      }, ["stop"]))
                    }, null, 42, _hoisted_2$a)), [
                      [vModelCheckbox, unref(model)]
                    ]),
                    createElementVNode("span", {
                      class: normalizeClass(unref(ns).e("inner"))
                    }, null, 2)
                  ], 2),
                  unref(hasOwnLabel) ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass(unref(ns).e("label"))
                  }, [
                    renderSlot(_ctx.$slots, "default"),
                    !_ctx.$slots.default ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      createTextVNode(toDisplayString(_ctx.label), 1)
                    ], 64)) : createCommentVNode("v-if", true)
                  ], 2)) : createCommentVNode("v-if", true)
                ];
              }),
              _: 3
            }, 8, ["class", "aria-controls", "onClick"]);
          };
        }
      });
      var Checkbox = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["__file", "checkbox.vue"]]);
      const _hoisted_1$c = ["name", "tabindex", "disabled", "true-value", "false-value"];
      const _hoisted_2$9 = ["name", "tabindex", "disabled", "value"];
      const __default__$8 = defineComponent({
        name: "ElCheckboxButton"
      });
      const _sfc_main$g = /* @__PURE__ */ defineComponent({
        ...__default__$8,
        props: checkboxProps,
        emits: checkboxEmits,
        setup(__props) {
          const props = __props;
          const slots = useSlots();
          const {
            isFocused,
            isChecked,
            isDisabled,
            checkboxButtonSize,
            model,
            actualValue,
            handleChange
          } = useCheckbox(props, slots);
          const checkboxGroup = inject(checkboxGroupContextKey, void 0);
          const ns = useNamespace("checkbox");
          const activeStyle = computed$1(() => {
            var _a2, _b, _c, _d;
            const fillValue = (_b = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.fill) == null ? void 0 : _a2.value) != null ? _b : "";
            return {
              backgroundColor: fillValue,
              borderColor: fillValue,
              color: (_d = (_c = checkboxGroup == null ? void 0 : checkboxGroup.textColor) == null ? void 0 : _c.value) != null ? _d : "",
              boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : void 0
            };
          });
          const labelKls = computed$1(() => {
            return [
              ns.b("button"),
              ns.bm("button", checkboxButtonSize.value),
              ns.is("disabled", isDisabled.value),
              ns.is("checked", isChecked.value),
              ns.is("focus", isFocused.value)
            ];
          });
          return (_ctx, _cache) => {
            var _a2, _b;
            return openBlock(), createElementBlock("label", {
              class: normalizeClass(unref(labelKls))
            }, [
              _ctx.trueValue || _ctx.falseValue || _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
                key: 0,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(model) ? model.value = $event : null),
                class: normalizeClass(unref(ns).be("button", "original")),
                type: "checkbox",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: unref(isDisabled),
                "true-value": (_a2 = _ctx.trueValue) != null ? _a2 : _ctx.trueLabel,
                "false-value": (_b = _ctx.falseValue) != null ? _b : _ctx.falseLabel,
                onChange: _cache[1] || (_cache[1] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                onFocus: _cache[2] || (_cache[2] = ($event) => isFocused.value = true),
                onBlur: _cache[3] || (_cache[3] = ($event) => isFocused.value = false),
                onClick: _cache[4] || (_cache[4] = withModifiers(() => {
                }, ["stop"]))
              }, null, 42, _hoisted_1$c)), [
                [vModelCheckbox, unref(model)]
              ]) : withDirectives((openBlock(), createElementBlock("input", {
                key: 1,
                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => isRef(model) ? model.value = $event : null),
                class: normalizeClass(unref(ns).be("button", "original")),
                type: "checkbox",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: unref(isDisabled),
                value: unref(actualValue),
                onChange: _cache[6] || (_cache[6] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                onFocus: _cache[7] || (_cache[7] = ($event) => isFocused.value = true),
                onBlur: _cache[8] || (_cache[8] = ($event) => isFocused.value = false),
                onClick: _cache[9] || (_cache[9] = withModifiers(() => {
                }, ["stop"]))
              }, null, 42, _hoisted_2$9)), [
                [vModelCheckbox, unref(model)]
              ]),
              _ctx.$slots.default || _ctx.label ? (openBlock(), createElementBlock("span", {
                key: 2,
                class: normalizeClass(unref(ns).be("button", "inner")),
                style: normalizeStyle(unref(isChecked) ? unref(activeStyle) : void 0)
              }, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString(_ctx.label), 1)
                ])
              ], 6)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var CheckboxButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$g, [["__file", "checkbox-button.vue"]]);
      const checkboxGroupProps = buildProps({
        modelValue: {
          type: definePropType(Array),
          default: () => []
        },
        disabled: Boolean,
        min: Number,
        max: Number,
        size: useSizeProp,
        label: String,
        fill: String,
        textColor: String,
        tag: {
          type: String,
          default: "div"
        },
        validateEvent: {
          type: Boolean,
          default: true
        }
      });
      const checkboxGroupEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isArray$1(val),
        change: (val) => isArray$1(val)
      };
      const __default__$7 = defineComponent({
        name: "ElCheckboxGroup"
      });
      const _sfc_main$f = /* @__PURE__ */ defineComponent({
        ...__default__$7,
        props: checkboxGroupProps,
        emits: checkboxGroupEmits,
        setup(__props, { emit }) {
          const props = __props;
          const ns = useNamespace("checkbox");
          const { formItem } = useFormItem();
          const { inputId: groupId, isLabeledByFormItem } = useFormItemInputId(props, {
            formItemContext: formItem
          });
          const changeEvent = async (value) => {
            emit(UPDATE_MODEL_EVENT, value);
            await nextTick();
            emit("change", value);
          };
          const modelValue = computed$1({
            get() {
              return props.modelValue;
            },
            set(val) {
              changeEvent(val);
            }
          });
          provide(checkboxGroupContextKey, {
            ...pick(toRefs(props), [
              "size",
              "min",
              "max",
              "disabled",
              "validateEvent",
              "fill",
              "textColor"
            ]),
            modelValue,
            changeEvent
          });
          watch(() => props.modelValue, () => {
            if (props.validateEvent) {
              formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
            }
          });
          return (_ctx, _cache) => {
            var _a2;
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
              id: unref(groupId),
              class: normalizeClass(unref(ns).b("group")),
              role: "group",
              "aria-label": !unref(isLabeledByFormItem) ? _ctx.label || "checkbox-group" : void 0,
              "aria-labelledby": unref(isLabeledByFormItem) ? (_a2 = unref(formItem)) == null ? void 0 : _a2.labelId : void 0
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
          };
        }
      });
      var CheckboxGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["__file", "checkbox-group.vue"]]);
      const ElCheckbox = exports("bC", withInstall(Checkbox, {
        CheckboxButton,
        CheckboxGroup
      }));
      withNoopInstall(CheckboxButton);
      withNoopInstall(CheckboxGroup);
      const tagProps = exports("a8", buildProps({
        type: {
          type: String,
          values: ["primary", "success", "info", "warning", "danger"],
          default: "primary"
        },
        closable: Boolean,
        disableTransitions: Boolean,
        hit: Boolean,
        color: String,
        size: {
          type: String,
          values: componentSizes
        },
        effect: {
          type: String,
          values: ["dark", "light", "plain"],
          default: "light"
        },
        round: Boolean
      }));
      const tagEmits = {
        close: (evt) => evt instanceof MouseEvent,
        click: (evt) => evt instanceof MouseEvent
      };
      const __default__$6 = defineComponent({
        name: "ElTag"
      });
      const _sfc_main$e = /* @__PURE__ */ defineComponent({
        ...__default__$6,
        props: tagProps,
        emits: tagEmits,
        setup(__props, { emit }) {
          const props = __props;
          const tagSize = useFormSize();
          const ns = useNamespace("tag");
          const containerKls = computed$1(() => {
            const { type, hit, effect, closable, round } = props;
            return [
              ns.b(),
              ns.is("closable", closable),
              ns.m(type || "primary"),
              ns.m(tagSize.value),
              ns.m(effect),
              ns.is("hit", hit),
              ns.is("round", round)
            ];
          });
          const handleClose = (event) => {
            emit("close", event);
          };
          const handleClick = (event) => {
            emit("click", event);
          };
          return (_ctx, _cache) => {
            return _ctx.disableTransitions ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: normalizeClass(unref(containerKls)),
              style: normalizeStyle({ backgroundColor: _ctx.color }),
              onClick: handleClick
            }, [
              createElementVNode("span", {
                class: normalizeClass(unref(ns).e("content"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2),
              _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
                key: 0,
                class: normalizeClass(unref(ns).e("close")),
                onClick: withModifiers(handleClose, ["stop"])
              }, {
                default: withCtx(() => [
                  createVNode(unref(close_default))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
            ], 6)) : (openBlock(), createBlock(Transition, {
              key: 1,
              name: `${unref(ns).namespace.value}-zoom-in-center`,
              appear: ""
            }, {
              default: withCtx(() => [
                createElementVNode("span", {
                  class: normalizeClass(unref(containerKls)),
                  style: normalizeStyle({ backgroundColor: _ctx.color }),
                  onClick: handleClick
                }, [
                  createElementVNode("span", {
                    class: normalizeClass(unref(ns).e("content"))
                  }, [
                    renderSlot(_ctx.$slots, "default")
                  ], 2),
                  _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(ns).e("close")),
                    onClick: withModifiers(handleClose, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(close_default))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                ], 6)
              ]),
              _: 3
            }, 8, ["name"]));
          };
        }
      });
      var Tag = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["__file", "tag.vue"]]);
      const ElTag = exports("aa", withInstall(Tag));
      const overlayProps = buildProps({
        mask: {
          type: Boolean,
          default: true
        },
        customMaskEvent: {
          type: Boolean,
          default: false
        },
        overlayClass: {
          type: definePropType([
            String,
            Array,
            Object
          ])
        },
        zIndex: {
          type: definePropType([String, Number])
        }
      });
      const overlayEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      const BLOCK = "overlay";
      var Overlay = defineComponent({
        name: "ElOverlay",
        props: overlayProps,
        emits: overlayEmits,
        setup(props, { slots, emit }) {
          const ns = useNamespace(BLOCK);
          const onMaskClick = (e) => {
            emit("click", e);
          };
          const { onClick, onMousedown, onMouseup } = useSameTarget(props.customMaskEvent ? void 0 : onMaskClick);
          return () => {
            return props.mask ? createVNode("div", {
              class: [ns.b(), props.overlayClass],
              style: {
                zIndex: props.zIndex
              },
              onClick,
              onMousedown,
              onMouseup
            }, [renderSlot(slots, "default")], PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : h$1("div", {
              class: props.overlayClass,
              style: {
                zIndex: props.zIndex,
                position: "fixed",
                top: "0px",
                right: "0px",
                bottom: "0px",
                left: "0px"
              }
            }, [renderSlot(slots, "default")]);
          };
        }
      });
      const ElOverlay = Overlay;
      const dialogInjectionKey = Symbol("dialogInjectionKey");
      const dialogContentProps = buildProps({
        center: Boolean,
        alignCenter: Boolean,
        closeIcon: {
          type: iconPropType
        },
        draggable: Boolean,
        overflow: Boolean,
        fullscreen: Boolean,
        showClose: {
          type: Boolean,
          default: true
        },
        title: {
          type: String,
          default: ""
        },
        ariaLevel: {
          type: String,
          default: "2"
        }
      });
      const dialogContentEmits = {
        close: () => true
      };
      const _hoisted_1$b = ["aria-level"];
      const _hoisted_2$8 = ["aria-label"];
      const _hoisted_3$6 = ["id"];
      const __default__$5 = defineComponent({ name: "ElDialogContent" });
      const _sfc_main$d = /* @__PURE__ */ defineComponent({
        ...__default__$5,
        props: dialogContentProps,
        emits: dialogContentEmits,
        setup(__props) {
          const props = __props;
          const { t } = useLocale();
          const { Close } = CloseComponents;
          const { dialogRef, headerRef, bodyId, ns, style } = inject(dialogInjectionKey);
          const { focusTrapRef } = inject(FOCUS_TRAP_INJECTION_KEY);
          const dialogKls = computed$1(() => [
            ns.b(),
            ns.is("fullscreen", props.fullscreen),
            ns.is("draggable", props.draggable),
            ns.is("align-center", props.alignCenter),
            { [ns.m("center")]: props.center }
          ]);
          const composedDialogRef = composeRefs(focusTrapRef, dialogRef);
          const draggable = computed$1(() => props.draggable);
          const overflow = computed$1(() => props.overflow);
          useDraggable(dialogRef, headerRef, draggable, overflow);
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref: unref(composedDialogRef),
              class: normalizeClass(unref(dialogKls)),
              style: normalizeStyle(unref(style)),
              tabindex: "-1"
            }, [
              createElementVNode("header", {
                ref_key: "headerRef",
                ref: headerRef,
                class: normalizeClass([unref(ns).e("header"), { "show-close": _ctx.showClose }])
              }, [
                renderSlot(_ctx.$slots, "header", {}, () => [
                  createElementVNode("span", {
                    role: "heading",
                    "aria-level": _ctx.ariaLevel,
                    class: normalizeClass(unref(ns).e("title"))
                  }, toDisplayString(_ctx.title), 11, _hoisted_1$b)
                ]),
                _ctx.showClose ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  "aria-label": unref(t)("el.dialog.close"),
                  class: normalizeClass(unref(ns).e("headerbtn")),
                  type: "button",
                  onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
                }, [
                  createVNode(unref(ElIcon), {
                    class: normalizeClass(unref(ns).e("close"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.closeIcon || unref(Close))))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ], 10, _hoisted_2$8)) : createCommentVNode("v-if", true)
              ], 2),
              createElementVNode("div", {
                id: unref(bodyId),
                class: normalizeClass(unref(ns).e("body"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 10, _hoisted_3$6),
              _ctx.$slots.footer ? (openBlock(), createElementBlock("footer", {
                key: 0,
                class: normalizeClass(unref(ns).e("footer"))
              }, [
                renderSlot(_ctx.$slots, "footer")
              ], 2)) : createCommentVNode("v-if", true)
            ], 6);
          };
        }
      });
      var ElDialogContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$d, [["__file", "dialog-content.vue"]]);
      const dialogProps = buildProps({
        ...dialogContentProps,
        appendToBody: Boolean,
        appendTo: {
          type: definePropType(String),
          default: "body"
        },
        beforeClose: {
          type: definePropType(Function)
        },
        destroyOnClose: Boolean,
        closeOnClickModal: {
          type: Boolean,
          default: true
        },
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        lockScroll: {
          type: Boolean,
          default: true
        },
        modal: {
          type: Boolean,
          default: true
        },
        openDelay: {
          type: Number,
          default: 0
        },
        closeDelay: {
          type: Number,
          default: 0
        },
        top: {
          type: String
        },
        modelValue: Boolean,
        modalClass: String,
        width: {
          type: [String, Number]
        },
        zIndex: {
          type: Number
        },
        trapFocus: {
          type: Boolean,
          default: false
        },
        headerAriaLevel: {
          type: String,
          default: "2"
        }
      });
      const dialogEmits = {
        open: () => true,
        opened: () => true,
        close: () => true,
        closed: () => true,
        [UPDATE_MODEL_EVENT]: (value) => isBoolean(value),
        openAutoFocus: () => true,
        closeAutoFocus: () => true
      };
      const useDialog = (props, targetRef) => {
        var _a2;
        const instance = getCurrentInstance();
        const emit = instance.emit;
        const { nextZIndex } = useZIndex();
        let lastPosition = "";
        const titleId = useId();
        const bodyId = useId();
        const visible = ref(false);
        const closed = ref(false);
        const rendered = ref(false);
        const zIndex2 = ref((_a2 = props.zIndex) != null ? _a2 : nextZIndex());
        let openTimer = void 0;
        let closeTimer = void 0;
        const namespace = useGlobalConfig("namespace", defaultNamespace);
        const style = computed$1(() => {
          const style2 = {};
          const varPrefix = `--${namespace.value}-dialog`;
          if (!props.fullscreen) {
            if (props.top) {
              style2[`${varPrefix}-margin-top`] = props.top;
            }
            if (props.width) {
              style2[`${varPrefix}-width`] = addUnit(props.width);
            }
          }
          return style2;
        });
        const overlayDialogStyle = computed$1(() => {
          if (props.alignCenter) {
            return { display: "flex" };
          }
          return {};
        });
        function afterEnter() {
          emit("opened");
        }
        function afterLeave() {
          emit("closed");
          emit(UPDATE_MODEL_EVENT, false);
          if (props.destroyOnClose) {
            rendered.value = false;
          }
        }
        function beforeLeave() {
          emit("close");
        }
        function open() {
          closeTimer == null ? void 0 : closeTimer();
          openTimer == null ? void 0 : openTimer();
          if (props.openDelay && props.openDelay > 0) {
            ({ stop: openTimer } = useTimeoutFn(() => doOpen(), props.openDelay));
          } else {
            doOpen();
          }
        }
        function close() {
          openTimer == null ? void 0 : openTimer();
          closeTimer == null ? void 0 : closeTimer();
          if (props.closeDelay && props.closeDelay > 0) {
            ({ stop: closeTimer } = useTimeoutFn(() => doClose(), props.closeDelay));
          } else {
            doClose();
          }
        }
        function handleClose() {
          function hide(shouldCancel) {
            if (shouldCancel)
              return;
            closed.value = true;
            visible.value = false;
          }
          if (props.beforeClose) {
            props.beforeClose(hide);
          } else {
            close();
          }
        }
        function onModalClick() {
          if (props.closeOnClickModal) {
            handleClose();
          }
        }
        function doOpen() {
          if (!isClient)
            return;
          visible.value = true;
        }
        function doClose() {
          visible.value = false;
        }
        function onOpenAutoFocus() {
          emit("openAutoFocus");
        }
        function onCloseAutoFocus() {
          emit("closeAutoFocus");
        }
        function onFocusoutPrevented(event) {
          var _a22;
          if (((_a22 = event.detail) == null ? void 0 : _a22.focusReason) === "pointer") {
            event.preventDefault();
          }
        }
        if (props.lockScroll) {
          useLockscreen(visible);
        }
        function onCloseRequested() {
          if (props.closeOnPressEscape) {
            handleClose();
          }
        }
        watch(() => props.modelValue, (val) => {
          if (val) {
            closed.value = false;
            open();
            rendered.value = true;
            zIndex2.value = isUndefined$1(props.zIndex) ? nextZIndex() : zIndex2.value++;
            nextTick(() => {
              emit("open");
              if (targetRef.value) {
                targetRef.value.scrollTop = 0;
              }
            });
          } else {
            if (visible.value) {
              close();
            }
          }
        });
        watch(() => props.fullscreen, (val) => {
          if (!targetRef.value)
            return;
          if (val) {
            lastPosition = targetRef.value.style.transform;
            targetRef.value.style.transform = "";
          } else {
            targetRef.value.style.transform = lastPosition;
          }
        });
        onMounted(() => {
          if (props.modelValue) {
            visible.value = true;
            rendered.value = true;
            open();
          }
        });
        return {
          afterEnter,
          afterLeave,
          beforeLeave,
          handleClose,
          onModalClick,
          close,
          doClose,
          onOpenAutoFocus,
          onCloseAutoFocus,
          onCloseRequested,
          onFocusoutPrevented,
          titleId,
          bodyId,
          closed,
          style,
          overlayDialogStyle,
          rendered,
          visible,
          zIndex: zIndex2
        };
      };
      const _hoisted_1$a = ["aria-label", "aria-labelledby", "aria-describedby"];
      const __default__$4 = defineComponent({
        name: "ElDialog",
        inheritAttrs: false
      });
      const _sfc_main$c = /* @__PURE__ */ defineComponent({
        ...__default__$4,
        props: dialogProps,
        emits: dialogEmits,
        setup(__props, { expose }) {
          const props = __props;
          const slots = useSlots();
          useDeprecated({
            scope: "el-dialog",
            from: "the title slot",
            replacement: "the header slot",
            version: "3.0.0",
            ref: "https://element-plus.org/en-US/component/dialog.html#slots"
          }, computed$1(() => !!slots.title));
          const ns = useNamespace("dialog");
          const dialogRef = ref();
          const headerRef = ref();
          const dialogContentRef = ref();
          const {
            visible,
            titleId,
            bodyId,
            style,
            overlayDialogStyle,
            rendered,
            zIndex: zIndex2,
            afterEnter,
            afterLeave,
            beforeLeave,
            handleClose,
            onModalClick,
            onOpenAutoFocus,
            onCloseAutoFocus,
            onCloseRequested,
            onFocusoutPrevented
          } = useDialog(props, dialogRef);
          provide(dialogInjectionKey, {
            dialogRef,
            headerRef,
            bodyId,
            ns,
            rendered,
            style
          });
          const overlayEvent = useSameTarget(onModalClick);
          const draggable = computed$1(() => props.draggable && !props.fullscreen);
          expose({
            visible,
            dialogContentRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Teleport, {
              to: _ctx.appendTo,
              disabled: _ctx.appendTo !== "body" ? false : !_ctx.appendToBody
            }, [
              createVNode(Transition, {
                name: "dialog-fade",
                onAfterEnter: unref(afterEnter),
                onAfterLeave: unref(afterLeave),
                onBeforeLeave: unref(beforeLeave),
                persisted: ""
              }, {
                default: withCtx(() => [
                  withDirectives(createVNode(unref(ElOverlay), {
                    "custom-mask-event": "",
                    mask: _ctx.modal,
                    "overlay-class": _ctx.modalClass,
                    "z-index": unref(zIndex2)
                  }, {
                    default: withCtx(() => [
                      createElementVNode("div", {
                        role: "dialog",
                        "aria-modal": "true",
                        "aria-label": _ctx.title || void 0,
                        "aria-labelledby": !_ctx.title ? unref(titleId) : void 0,
                        "aria-describedby": unref(bodyId),
                        class: normalizeClass(`${unref(ns).namespace.value}-overlay-dialog`),
                        style: normalizeStyle(unref(overlayDialogStyle)),
                        onClick: _cache[0] || (_cache[0] = (...args) => unref(overlayEvent).onClick && unref(overlayEvent).onClick(...args)),
                        onMousedown: _cache[1] || (_cache[1] = (...args) => unref(overlayEvent).onMousedown && unref(overlayEvent).onMousedown(...args)),
                        onMouseup: _cache[2] || (_cache[2] = (...args) => unref(overlayEvent).onMouseup && unref(overlayEvent).onMouseup(...args))
                      }, [
                        createVNode(unref(ElFocusTrap), {
                          loop: "",
                          trapped: unref(visible),
                          "focus-start-el": "container",
                          onFocusAfterTrapped: unref(onOpenAutoFocus),
                          onFocusAfterReleased: unref(onCloseAutoFocus),
                          onFocusoutPrevented: unref(onFocusoutPrevented),
                          onReleaseRequested: unref(onCloseRequested)
                        }, {
                          default: withCtx(() => [
                            unref(rendered) ? (openBlock(), createBlock(ElDialogContent, mergeProps({
                              key: 0,
                              ref_key: "dialogContentRef",
                              ref: dialogContentRef
                            }, _ctx.$attrs, {
                              center: _ctx.center,
                              "align-center": _ctx.alignCenter,
                              "close-icon": _ctx.closeIcon,
                              draggable: unref(draggable),
                              overflow: _ctx.overflow,
                              fullscreen: _ctx.fullscreen,
                              "show-close": _ctx.showClose,
                              title: _ctx.title,
                              "aria-level": _ctx.headerAriaLevel,
                              onClose: unref(handleClose)
                            }), createSlots({
                              header: withCtx(() => [
                                !_ctx.$slots.title ? renderSlot(_ctx.$slots, "header", {
                                  key: 0,
                                  close: unref(handleClose),
                                  titleId: unref(titleId),
                                  titleClass: unref(ns).e("title")
                                }) : renderSlot(_ctx.$slots, "title", { key: 1 })
                              ]),
                              default: withCtx(() => [
                                renderSlot(_ctx.$slots, "default")
                              ]),
                              _: 2
                            }, [
                              _ctx.$slots.footer ? {
                                name: "footer",
                                fn: withCtx(() => [
                                  renderSlot(_ctx.$slots, "footer")
                                ])
                              } : void 0
                            ]), 1040, ["center", "align-center", "close-icon", "draggable", "overflow", "fullscreen", "show-close", "title", "aria-level", "onClose"])) : createCommentVNode("v-if", true)
                          ]),
                          _: 3
                        }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
                      ], 46, _hoisted_1$a)
                    ]),
                    _: 3
                  }, 8, ["mask", "overlay-class", "z-index"]), [
                    [vShow, unref(visible)]
                  ])
                ]),
                _: 3
              }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
            ], 8, ["to", "disabled"]);
          };
        }
      });
      var Dialog = /* @__PURE__ */ _export_sfc$1(_sfc_main$c, [["__file", "dialog.vue"]]);
      const ElDialog = exports("bB", withInstall(Dialog));
      const imageViewerProps = buildProps({
        urlList: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        zIndex: {
          type: Number
        },
        initialIndex: {
          type: Number,
          default: 0
        },
        infinite: {
          type: Boolean,
          default: true
        },
        hideOnClickModal: Boolean,
        teleported: Boolean,
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        zoomRate: {
          type: Number,
          default: 1.2
        },
        minScale: {
          type: Number,
          default: 0.2
        },
        maxScale: {
          type: Number,
          default: 7
        },
        crossorigin: {
          type: definePropType(String)
        }
      });
      const imageViewerEmits = {
        close: () => true,
        switch: (index) => isNumber(index),
        rotate: (deg) => isNumber(deg)
      };
      const _hoisted_1$9 = ["src", "crossorigin"];
      const __default__$3 = defineComponent({
        name: "ElImageViewer"
      });
      const _sfc_main$b = /* @__PURE__ */ defineComponent({
        ...__default__$3,
        props: imageViewerProps,
        emits: imageViewerEmits,
        setup(__props, { expose, emit }) {
          var _a2;
          const props = __props;
          const modes = {
            CONTAIN: {
              name: "contain",
              icon: markRaw(full_screen_default)
            },
            ORIGINAL: {
              name: "original",
              icon: markRaw(scale_to_original_default)
            }
          };
          const { t } = useLocale();
          const ns = useNamespace("image-viewer");
          const { nextZIndex } = useZIndex();
          const wrapper = ref();
          const imgRefs = ref([]);
          const scopeEventListener = effectScope();
          const loading = ref(true);
          const activeIndex = ref(props.initialIndex);
          const mode = shallowRef(modes.CONTAIN);
          const transform = ref({
            scale: 1,
            deg: 0,
            offsetX: 0,
            offsetY: 0,
            enableTransition: false
          });
          const zIndex2 = ref((_a2 = props.zIndex) != null ? _a2 : nextZIndex());
          const isSingle = computed$1(() => {
            const { urlList } = props;
            return urlList.length <= 1;
          });
          const isFirst = computed$1(() => {
            return activeIndex.value === 0;
          });
          const isLast = computed$1(() => {
            return activeIndex.value === props.urlList.length - 1;
          });
          const currentImg = computed$1(() => {
            return props.urlList[activeIndex.value];
          });
          const arrowPrevKls = computed$1(() => [
            ns.e("btn"),
            ns.e("prev"),
            ns.is("disabled", !props.infinite && isFirst.value)
          ]);
          const arrowNextKls = computed$1(() => [
            ns.e("btn"),
            ns.e("next"),
            ns.is("disabled", !props.infinite && isLast.value)
          ]);
          const imgStyle = computed$1(() => {
            const { scale, deg, offsetX, offsetY, enableTransition } = transform.value;
            let translateX = offsetX / scale;
            let translateY = offsetY / scale;
            switch (deg % 360) {
              case 90:
              case -270:
                [translateX, translateY] = [translateY, -translateX];
                break;
              case 180:
              case -180:
                [translateX, translateY] = [-translateX, -translateY];
                break;
              case 270:
              case -90:
                [translateX, translateY] = [-translateY, translateX];
                break;
            }
            const style = {
              transform: `scale(${scale}) rotate(${deg}deg) translate(${translateX}px, ${translateY}px)`,
              transition: enableTransition ? "transform .3s" : ""
            };
            if (mode.value.name === modes.CONTAIN.name) {
              style.maxWidth = style.maxHeight = "100%";
            }
            return style;
          });
          function hide() {
            unregisterEventListener();
            emit("close");
          }
          function registerEventListener() {
            const keydownHandler = throttle((e) => {
              switch (e.code) {
                case EVENT_CODE.esc:
                  props.closeOnPressEscape && hide();
                  break;
                case EVENT_CODE.space:
                  toggleMode();
                  break;
                case EVENT_CODE.left:
                  prev();
                  break;
                case EVENT_CODE.up:
                  handleActions("zoomIn");
                  break;
                case EVENT_CODE.right:
                  next();
                  break;
                case EVENT_CODE.down:
                  handleActions("zoomOut");
                  break;
              }
            });
            const mousewheelHandler = throttle((e) => {
              const delta = e.deltaY || e.deltaX;
              handleActions(delta < 0 ? "zoomIn" : "zoomOut", {
                zoomRate: props.zoomRate,
                enableTransition: false
              });
            });
            scopeEventListener.run(() => {
              useEventListener(document, "keydown", keydownHandler);
              useEventListener(document, "wheel", mousewheelHandler);
            });
          }
          function unregisterEventListener() {
            scopeEventListener.stop();
          }
          function handleImgLoad() {
            loading.value = false;
          }
          function handleImgError(e) {
            loading.value = false;
            e.target.alt = t("el.image.error");
          }
          function handleMouseDown(e) {
            if (loading.value || e.button !== 0 || !wrapper.value)
              return;
            transform.value.enableTransition = false;
            const { offsetX, offsetY } = transform.value;
            const startX = e.pageX;
            const startY = e.pageY;
            const dragHandler = throttle((ev) => {
              transform.value = {
                ...transform.value,
                offsetX: offsetX + ev.pageX - startX,
                offsetY: offsetY + ev.pageY - startY
              };
            });
            const removeMousemove = useEventListener(document, "mousemove", dragHandler);
            useEventListener(document, "mouseup", () => {
              removeMousemove();
            });
            e.preventDefault();
          }
          function reset() {
            transform.value = {
              scale: 1,
              deg: 0,
              offsetX: 0,
              offsetY: 0,
              enableTransition: false
            };
          }
          function toggleMode() {
            if (loading.value)
              return;
            const modeNames = keysOf(modes);
            const modeValues = Object.values(modes);
            const currentMode = mode.value.name;
            const index = modeValues.findIndex((i) => i.name === currentMode);
            const nextIndex = (index + 1) % modeNames.length;
            mode.value = modes[modeNames[nextIndex]];
            reset();
          }
          function setActiveItem(index) {
            const len = props.urlList.length;
            activeIndex.value = (index + len) % len;
          }
          function prev() {
            if (isFirst.value && !props.infinite)
              return;
            setActiveItem(activeIndex.value - 1);
          }
          function next() {
            if (isLast.value && !props.infinite)
              return;
            setActiveItem(activeIndex.value + 1);
          }
          function handleActions(action, options = {}) {
            if (loading.value)
              return;
            const { minScale, maxScale } = props;
            const { zoomRate, rotateDeg, enableTransition } = {
              zoomRate: props.zoomRate,
              rotateDeg: 90,
              enableTransition: true,
              ...options
            };
            switch (action) {
              case "zoomOut":
                if (transform.value.scale > minScale) {
                  transform.value.scale = Number.parseFloat((transform.value.scale / zoomRate).toFixed(3));
                }
                break;
              case "zoomIn":
                if (transform.value.scale < maxScale) {
                  transform.value.scale = Number.parseFloat((transform.value.scale * zoomRate).toFixed(3));
                }
                break;
              case "clockwise":
                transform.value.deg += rotateDeg;
                emit("rotate", transform.value.deg);
                break;
              case "anticlockwise":
                transform.value.deg -= rotateDeg;
                emit("rotate", transform.value.deg);
                break;
            }
            transform.value.enableTransition = enableTransition;
          }
          watch(currentImg, () => {
            nextTick(() => {
              const $img = imgRefs.value[0];
              if (!($img == null ? void 0 : $img.complete)) {
                loading.value = true;
              }
            });
          });
          watch(activeIndex, (val) => {
            reset();
            emit("switch", val);
          });
          onMounted(() => {
            var _a22, _b;
            registerEventListener();
            (_b = (_a22 = wrapper.value) == null ? void 0 : _a22.focus) == null ? void 0 : _b.call(_a22);
          });
          expose({
            setActiveItem
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Teleport, {
              to: "body",
              disabled: !_ctx.teleported
            }, [
              createVNode(Transition, {
                name: "viewer-fade",
                appear: ""
              }, {
                default: withCtx(() => [
                  createElementVNode("div", {
                    ref_key: "wrapper",
                    ref: wrapper,
                    tabindex: -1,
                    class: normalizeClass(unref(ns).e("wrapper")),
                    style: normalizeStyle({ zIndex: zIndex2.value })
                  }, [
                    createElementVNode("div", {
                      class: normalizeClass(unref(ns).e("mask")),
                      onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.hideOnClickModal && hide(), ["self"]))
                    }, null, 2),
                    createCommentVNode(" CLOSE "),
                    createElementVNode("span", {
                      class: normalizeClass([unref(ns).e("btn"), unref(ns).e("close")]),
                      onClick: hide
                    }, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(close_default))
                        ]),
                        _: 1
                      })
                    ], 2),
                    createCommentVNode(" ARROW "),
                    !unref(isSingle) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      createElementVNode("span", {
                        class: normalizeClass(unref(arrowPrevKls)),
                        onClick: prev
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(arrow_left_default))
                          ]),
                          _: 1
                        })
                      ], 2),
                      createElementVNode("span", {
                        class: normalizeClass(unref(arrowNextKls)),
                        onClick: next
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(arrow_right_default))
                          ]),
                          _: 1
                        })
                      ], 2)
                    ], 64)) : createCommentVNode("v-if", true),
                    createCommentVNode(" ACTIONS "),
                    createElementVNode("div", {
                      class: normalizeClass([unref(ns).e("btn"), unref(ns).e("actions")])
                    }, [
                      createElementVNode("div", {
                        class: normalizeClass(unref(ns).e("actions__inner"))
                      }, [
                        createVNode(unref(ElIcon), {
                          onClick: _cache[1] || (_cache[1] = ($event) => handleActions("zoomOut"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(zoom_out_default))
                          ]),
                          _: 1
                        }),
                        createVNode(unref(ElIcon), {
                          onClick: _cache[2] || (_cache[2] = ($event) => handleActions("zoomIn"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(zoom_in_default))
                          ]),
                          _: 1
                        }),
                        createElementVNode("i", {
                          class: normalizeClass(unref(ns).e("actions__divider"))
                        }, null, 2),
                        createVNode(unref(ElIcon), { onClick: toggleMode }, {
                          default: withCtx(() => [
                            (openBlock(), createBlock(resolveDynamicComponent(unref(mode).icon)))
                          ]),
                          _: 1
                        }),
                        createElementVNode("i", {
                          class: normalizeClass(unref(ns).e("actions__divider"))
                        }, null, 2),
                        createVNode(unref(ElIcon), {
                          onClick: _cache[3] || (_cache[3] = ($event) => handleActions("anticlockwise"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(refresh_left_default))
                          ]),
                          _: 1
                        }),
                        createVNode(unref(ElIcon), {
                          onClick: _cache[4] || (_cache[4] = ($event) => handleActions("clockwise"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(refresh_right_default))
                          ]),
                          _: 1
                        })
                      ], 2)
                    ], 2),
                    createCommentVNode(" CANVAS "),
                    createElementVNode("div", {
                      class: normalizeClass(unref(ns).e("canvas"))
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.urlList, (url, i) => {
                        return withDirectives((openBlock(), createElementBlock("img", {
                          ref_for: true,
                          ref: (el) => imgRefs.value[i] = el,
                          key: url,
                          src: url,
                          style: normalizeStyle(unref(imgStyle)),
                          class: normalizeClass(unref(ns).e("img")),
                          crossorigin: _ctx.crossorigin,
                          onLoad: handleImgLoad,
                          onError: handleImgError,
                          onMousedown: handleMouseDown
                        }, null, 46, _hoisted_1$9)), [
                          [vShow, i === activeIndex.value]
                        ]);
                      }), 128))
                    ], 2),
                    renderSlot(_ctx.$slots, "default")
                  ], 6)
                ]),
                _: 3
              })
            ], 8, ["disabled"]);
          };
        }
      });
      var ImageViewer = /* @__PURE__ */ _export_sfc$1(_sfc_main$b, [["__file", "image-viewer.vue"]]);
      const ElImageViewer = withInstall(ImageViewer);
      const imageProps = buildProps({
        hideOnClickModal: Boolean,
        src: {
          type: String,
          default: ""
        },
        fit: {
          type: String,
          values: ["", "contain", "cover", "fill", "none", "scale-down"],
          default: ""
        },
        loading: {
          type: String,
          values: ["eager", "lazy"]
        },
        lazy: Boolean,
        scrollContainer: {
          type: definePropType([String, Object])
        },
        previewSrcList: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        previewTeleported: Boolean,
        zIndex: {
          type: Number
        },
        initialIndex: {
          type: Number,
          default: 0
        },
        infinite: {
          type: Boolean,
          default: true
        },
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        zoomRate: {
          type: Number,
          default: 1.2
        },
        minScale: {
          type: Number,
          default: 0.2
        },
        maxScale: {
          type: Number,
          default: 7
        },
        crossorigin: {
          type: definePropType(String)
        }
      });
      const imageEmits = {
        load: (evt) => evt instanceof Event,
        error: (evt) => evt instanceof Event,
        switch: (val) => isNumber(val),
        close: () => true,
        show: () => true
      };
      const _hoisted_1$8 = ["src", "loading", "crossorigin"];
      const _hoisted_2$7 = { key: 0 };
      const __default__$2 = defineComponent({
        name: "ElImage",
        inheritAttrs: false
      });
      const _sfc_main$a = /* @__PURE__ */ defineComponent({
        ...__default__$2,
        props: imageProps,
        emits: imageEmits,
        setup(__props, { emit }) {
          const props = __props;
          let prevOverflow = "";
          const { t } = useLocale();
          const ns = useNamespace("image");
          const rawAttrs = useAttrs$1();
          const attrs = useAttrs();
          const imageSrc = ref();
          const hasLoadError = ref(false);
          const isLoading = ref(true);
          const showViewer = ref(false);
          const container = ref();
          const _scrollContainer = ref();
          const supportLoading = isClient && "loading" in HTMLImageElement.prototype;
          let stopScrollListener;
          let stopWheelListener;
          const imageKls = computed$1(() => [
            ns.e("inner"),
            preview.value && ns.e("preview"),
            isLoading.value && ns.is("loading")
          ]);
          const containerStyle = computed$1(() => rawAttrs.style);
          const imageStyle = computed$1(() => {
            const { fit } = props;
            if (isClient && fit) {
              return { objectFit: fit };
            }
            return {};
          });
          const preview = computed$1(() => {
            const { previewSrcList } = props;
            return Array.isArray(previewSrcList) && previewSrcList.length > 0;
          });
          const imageIndex = computed$1(() => {
            const { previewSrcList, initialIndex } = props;
            let previewIndex = initialIndex;
            if (initialIndex > previewSrcList.length - 1) {
              previewIndex = 0;
            }
            return previewIndex;
          });
          const isManual = computed$1(() => {
            if (props.loading === "eager")
              return false;
            return !supportLoading && props.loading === "lazy" || props.lazy;
          });
          const loadImage = () => {
            if (!isClient)
              return;
            isLoading.value = true;
            hasLoadError.value = false;
            imageSrc.value = props.src;
          };
          function handleLoad(event) {
            isLoading.value = false;
            hasLoadError.value = false;
            emit("load", event);
          }
          function handleError(event) {
            isLoading.value = false;
            hasLoadError.value = true;
            emit("error", event);
          }
          function handleLazyLoad() {
            if (isInContainer(container.value, _scrollContainer.value)) {
              loadImage();
              removeLazyLoadListener();
            }
          }
          const lazyLoadHandler = useThrottleFn(handleLazyLoad, 200, true);
          async function addLazyLoadListener() {
            var _a2;
            if (!isClient)
              return;
            await nextTick();
            const { scrollContainer } = props;
            if (isElement(scrollContainer)) {
              _scrollContainer.value = scrollContainer;
            } else if (isString(scrollContainer) && scrollContainer !== "") {
              _scrollContainer.value = (_a2 = document.querySelector(scrollContainer)) != null ? _a2 : void 0;
            } else if (container.value) {
              _scrollContainer.value = getScrollContainer(container.value);
            }
            if (_scrollContainer.value) {
              stopScrollListener = useEventListener(_scrollContainer, "scroll", lazyLoadHandler);
              setTimeout(() => handleLazyLoad(), 100);
            }
          }
          function removeLazyLoadListener() {
            if (!isClient || !_scrollContainer.value || !lazyLoadHandler)
              return;
            stopScrollListener == null ? void 0 : stopScrollListener();
            _scrollContainer.value = void 0;
          }
          function wheelHandler(e) {
            if (!e.ctrlKey)
              return;
            if (e.deltaY < 0) {
              e.preventDefault();
              return false;
            } else if (e.deltaY > 0) {
              e.preventDefault();
              return false;
            }
          }
          function clickHandler() {
            if (!preview.value)
              return;
            stopWheelListener = useEventListener("wheel", wheelHandler, {
              passive: false
            });
            prevOverflow = document.body.style.overflow;
            document.body.style.overflow = "hidden";
            showViewer.value = true;
            emit("show");
          }
          function closeViewer() {
            stopWheelListener == null ? void 0 : stopWheelListener();
            document.body.style.overflow = prevOverflow;
            showViewer.value = false;
            emit("close");
          }
          function switchViewer(val) {
            emit("switch", val);
          }
          watch(() => props.src, () => {
            if (isManual.value) {
              isLoading.value = true;
              hasLoadError.value = false;
              removeLazyLoadListener();
              addLazyLoadListener();
            } else {
              loadImage();
            }
          });
          onMounted(() => {
            if (isManual.value) {
              addLazyLoadListener();
            } else {
              loadImage();
            }
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "container",
              ref: container,
              class: normalizeClass([unref(ns).b(), _ctx.$attrs.class]),
              style: normalizeStyle(unref(containerStyle))
            }, [
              hasLoadError.value ? renderSlot(_ctx.$slots, "error", { key: 0 }, () => [
                createElementVNode("div", {
                  class: normalizeClass(unref(ns).e("error"))
                }, toDisplayString(unref(t)("el.image.error")), 3)
              ]) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                imageSrc.value !== void 0 ? (openBlock(), createElementBlock("img", mergeProps({ key: 0 }, unref(attrs), {
                  src: imageSrc.value,
                  loading: _ctx.loading,
                  style: unref(imageStyle),
                  class: unref(imageKls),
                  crossorigin: _ctx.crossorigin,
                  onClick: clickHandler,
                  onLoad: handleLoad,
                  onError: handleError
                }), null, 16, _hoisted_1$8)) : createCommentVNode("v-if", true),
                isLoading.value ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(unref(ns).e("wrapper"))
                }, [
                  renderSlot(_ctx.$slots, "placeholder", {}, () => [
                    createElementVNode("div", {
                      class: normalizeClass(unref(ns).e("placeholder"))
                    }, null, 2)
                  ])
                ], 2)) : createCommentVNode("v-if", true)
              ], 64)),
              unref(preview) ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                showViewer.value ? (openBlock(), createBlock(unref(ElImageViewer), {
                  key: 0,
                  "z-index": _ctx.zIndex,
                  "initial-index": unref(imageIndex),
                  infinite: _ctx.infinite,
                  "zoom-rate": _ctx.zoomRate,
                  "min-scale": _ctx.minScale,
                  "max-scale": _ctx.maxScale,
                  "url-list": _ctx.previewSrcList,
                  "hide-on-click-modal": _ctx.hideOnClickModal,
                  teleported: _ctx.previewTeleported,
                  "close-on-press-escape": _ctx.closeOnPressEscape,
                  onClose: closeViewer,
                  onSwitch: switchViewer
                }, {
                  default: withCtx(() => [
                    _ctx.$slots.viewer ? (openBlock(), createElementBlock("div", _hoisted_2$7, [
                      renderSlot(_ctx.$slots, "viewer")
                    ])) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["z-index", "initial-index", "infinite", "zoom-rate", "min-scale", "max-scale", "url-list", "hide-on-click-modal", "teleported", "close-on-press-escape"])) : createCommentVNode("v-if", true)
              ], 64)) : createCommentVNode("v-if", true)
            ], 6);
          };
        }
      });
      var Image = /* @__PURE__ */ _export_sfc$1(_sfc_main$a, [["__file", "image.vue"]]);
      const ElImage = exports("bA", withInstall(Image));
      const linkProps = buildProps({
        type: {
          type: String,
          values: ["primary", "success", "warning", "info", "danger", "default"],
          default: "default"
        },
        underline: {
          type: Boolean,
          default: true
        },
        disabled: { type: Boolean, default: false },
        href: { type: String, default: "" },
        target: {
          type: String,
          default: "_self"
        },
        icon: {
          type: iconPropType
        }
      });
      const linkEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      const _hoisted_1$7 = ["href", "target"];
      const __default__$1 = defineComponent({
        name: "ElLink"
      });
      const _sfc_main$9 = /* @__PURE__ */ defineComponent({
        ...__default__$1,
        props: linkProps,
        emits: linkEmits,
        setup(__props, { emit }) {
          const props = __props;
          const ns = useNamespace("link");
          const linkKls = computed$1(() => [
            ns.b(),
            ns.m(props.type),
            ns.is("disabled", props.disabled),
            ns.is("underline", props.underline && !props.disabled)
          ]);
          function handleClick(event) {
            if (!props.disabled)
              emit("click", event);
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("a", {
              class: normalizeClass(unref(linkKls)),
              href: _ctx.disabled || !_ctx.href ? void 0 : _ctx.href,
              target: _ctx.disabled || !_ctx.href ? void 0 : _ctx.target,
              onClick: handleClick
            }, [
              _ctx.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
                ]),
                _: 1
              })) : createCommentVNode("v-if", true),
              _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
                key: 1,
                class: normalizeClass(unref(ns).e("inner"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2)) : createCommentVNode("v-if", true),
              _ctx.$slots.icon ? renderSlot(_ctx.$slots, "icon", { key: 2 }) : createCommentVNode("v-if", true)
            ], 10, _hoisted_1$7);
          };
        }
      });
      var Link = /* @__PURE__ */ _export_sfc$1(_sfc_main$9, [["__file", "link.vue"]]);
      const ElLink = exports("bx", withInstall(Link));
      const getCell = function(event) {
        var _a2;
        return (_a2 = event.target) == null ? void 0 : _a2.closest("td");
      };
      const orderBy = function(array, sortKey, reverse, sortMethod, sortBy) {
        if (!sortKey && !sortMethod && (!sortBy || Array.isArray(sortBy) && !sortBy.length)) {
          return array;
        }
        if (typeof reverse === "string") {
          reverse = reverse === "descending" ? -1 : 1;
        } else {
          reverse = reverse && reverse < 0 ? -1 : 1;
        }
        const getKey = sortMethod ? null : function(value, index) {
          if (sortBy) {
            if (!Array.isArray(sortBy)) {
              sortBy = [sortBy];
            }
            return sortBy.map((by) => {
              if (typeof by === "string") {
                return get(value, by);
              } else {
                return by(value, index, array);
              }
            });
          }
          if (sortKey !== "$key") {
            if (isObject$1(value) && "$value" in value)
              value = value.$value;
          }
          return [isObject$1(value) ? get(value, sortKey) : value];
        };
        const compare = function(a2, b2) {
          if (sortMethod) {
            return sortMethod(a2.value, b2.value);
          }
          for (let i = 0, len = a2.key.length; i < len; i++) {
            if (a2.key[i] < b2.key[i]) {
              return -1;
            }
            if (a2.key[i] > b2.key[i]) {
              return 1;
            }
          }
          return 0;
        };
        return array.map((value, index) => {
          return {
            value,
            index,
            key: getKey ? getKey(value, index) : null
          };
        }).sort((a2, b2) => {
          let order = compare(a2, b2);
          if (!order) {
            order = a2.index - b2.index;
          }
          return order * +reverse;
        }).map((item) => item.value);
      };
      const getColumnById = function(table, columnId) {
        let column = null;
        table.columns.forEach((item) => {
          if (item.id === columnId) {
            column = item;
          }
        });
        return column;
      };
      const getColumnByKey = function(table, columnKey) {
        let column = null;
        for (let i = 0; i < table.columns.length; i++) {
          const item = table.columns[i];
          if (item.columnKey === columnKey) {
            column = item;
            break;
          }
        }
        if (!column)
          throwError("ElTable", `No column matching with column-key: ${columnKey}`);
        return column;
      };
      const getColumnByCell = function(table, cell, namespace) {
        const matches = (cell.className || "").match(new RegExp(`${namespace}-table_[^\\s]+`, "gm"));
        if (matches) {
          return getColumnById(table, matches[0]);
        }
        return null;
      };
      const getRowIdentity = (row, rowKey) => {
        if (!row)
          throw new Error("Row is required when get row identity");
        if (typeof rowKey === "string") {
          if (!rowKey.includes(".")) {
            return `${row[rowKey]}`;
          }
          const key = rowKey.split(".");
          let current = row;
          for (const element of key) {
            current = current[element];
          }
          return `${current}`;
        } else if (typeof rowKey === "function") {
          return rowKey.call(null, row);
        }
      };
      const getKeysMap = function(array, rowKey) {
        const arrayMap2 = {};
        (array || []).forEach((row, index) => {
          arrayMap2[getRowIdentity(row, rowKey)] = { row, index };
        });
        return arrayMap2;
      };
      function mergeOptions(defaults2, config) {
        const options = {};
        let key;
        for (key in defaults2) {
          options[key] = defaults2[key];
        }
        for (key in config) {
          if (hasOwn(config, key)) {
            const value = config[key];
            if (typeof value !== "undefined") {
              options[key] = value;
            }
          }
        }
        return options;
      }
      function parseWidth(width) {
        if (width === "")
          return width;
        if (width !== void 0) {
          width = Number.parseInt(width, 10);
          if (Number.isNaN(width)) {
            width = "";
          }
        }
        return width;
      }
      function parseMinWidth(minWidth) {
        if (minWidth === "")
          return minWidth;
        if (minWidth !== void 0) {
          minWidth = parseWidth(minWidth);
          if (Number.isNaN(minWidth)) {
            minWidth = 80;
          }
        }
        return minWidth;
      }
      function parseHeight(height) {
        if (typeof height === "number") {
          return height;
        }
        if (typeof height === "string") {
          if (/^\d+(?:px)?$/.test(height)) {
            return Number.parseInt(height, 10);
          } else {
            return height;
          }
        }
        return null;
      }
      function compose(...funcs) {
        if (funcs.length === 0) {
          return (arg) => arg;
        }
        if (funcs.length === 1) {
          return funcs[0];
        }
        return funcs.reduce((a2, b2) => (...args) => a2(b2(...args)));
      }
      function toggleRowStatus(statusArr, row, newVal) {
        let changed = false;
        const index = statusArr.indexOf(row);
        const included = index !== -1;
        const toggleStatus = (type) => {
          if (type === "add") {
            statusArr.push(row);
          } else {
            statusArr.splice(index, 1);
          }
          changed = true;
          if (isArray$1(row.children)) {
            row.children.forEach((item) => {
              toggleRowStatus(statusArr, item, newVal != null ? newVal : !included);
            });
          }
        };
        if (isBoolean(newVal)) {
          if (newVal && !included) {
            toggleStatus("add");
          } else if (!newVal && included) {
            toggleStatus("remove");
          }
        } else {
          included ? toggleStatus("remove") : toggleStatus("add");
        }
        return changed;
      }
      function walkTreeNode(root2, cb, childrenKey = "children", lazyKey = "hasChildren") {
        const isNil2 = (array) => !(Array.isArray(array) && array.length);
        function _walker(parent, children, level) {
          cb(parent, children, level);
          children.forEach((item) => {
            if (item[lazyKey]) {
              cb(item, null, level + 1);
              return;
            }
            const children2 = item[childrenKey];
            if (!isNil2(children2)) {
              _walker(item, children2, level + 1);
            }
          });
        }
        root2.forEach((item) => {
          if (item[lazyKey]) {
            cb(item, null, 0);
            return;
          }
          const children = item[childrenKey];
          if (!isNil2(children)) {
            _walker(item, children, 0);
          }
        });
      }
      let removePopper = null;
      function createTablePopper(props, popperContent, trigger, table) {
        if ((removePopper == null ? void 0 : removePopper.trigger) === trigger) {
          return;
        }
        removePopper == null ? void 0 : removePopper();
        const parentNode = table == null ? void 0 : table.refs.tableWrapper;
        const ns = parentNode == null ? void 0 : parentNode.dataset.prefix;
        const popperOptions = {
          strategy: "fixed",
          ...props.popperOptions
        };
        const vm = createVNode(ElTooltip, {
          content: popperContent,
          virtualTriggering: true,
          virtualRef: trigger,
          appendTo: parentNode,
          placement: "top",
          transition: "none",
          offset: 0,
          hideAfter: 0,
          ...props,
          popperOptions,
          onHide: () => {
            removePopper == null ? void 0 : removePopper();
          }
        });
        vm.appContext = { ...table.appContext, ...table };
        const container = document.createElement("div");
        render(vm, container);
        vm.component.exposed.onOpen();
        const scrollContainer = parentNode == null ? void 0 : parentNode.querySelector(`.${ns}-scrollbar__wrap`);
        removePopper = () => {
          render(null, container);
          scrollContainer == null ? void 0 : scrollContainer.removeEventListener("scroll", removePopper);
          removePopper = null;
        };
        removePopper.trigger = trigger;
        scrollContainer == null ? void 0 : scrollContainer.addEventListener("scroll", removePopper);
      }
      function getCurrentColumns(column) {
        if (column.children) {
          return flatMap(column.children, getCurrentColumns);
        } else {
          return [column];
        }
      }
      function getColSpan(colSpan, column) {
        return colSpan + column.colSpan;
      }
      const isFixedColumn = (index, fixed, store, realColumns) => {
        let start = 0;
        let after = index;
        const columns = store.states.columns.value;
        if (realColumns) {
          const curColumns = getCurrentColumns(realColumns[index]);
          const preColumns = columns.slice(0, columns.indexOf(curColumns[0]));
          start = preColumns.reduce(getColSpan, 0);
          after = start + curColumns.reduce(getColSpan, 0) - 1;
        } else {
          start = index;
        }
        let fixedLayout;
        switch (fixed) {
          case "left":
            if (after < store.states.fixedLeafColumnsLength.value) {
              fixedLayout = "left";
            }
            break;
          case "right":
            if (start >= columns.length - store.states.rightFixedLeafColumnsLength.value) {
              fixedLayout = "right";
            }
            break;
          default:
            if (after < store.states.fixedLeafColumnsLength.value) {
              fixedLayout = "left";
            } else if (start >= columns.length - store.states.rightFixedLeafColumnsLength.value) {
              fixedLayout = "right";
            }
        }
        return fixedLayout ? {
          direction: fixedLayout,
          start,
          after
        } : {};
      };
      const getFixedColumnsClass = (namespace, index, fixed, store, realColumns, offset = 0) => {
        const classes = [];
        const { direction, start, after } = isFixedColumn(index, fixed, store, realColumns);
        if (direction) {
          const isLeft = direction === "left";
          classes.push(`${namespace}-fixed-column--${direction}`);
          if (isLeft && after + offset === store.states.fixedLeafColumnsLength.value - 1) {
            classes.push("is-last-column");
          } else if (!isLeft && start - offset === store.states.columns.value.length - store.states.rightFixedLeafColumnsLength.value) {
            classes.push("is-first-column");
          }
        }
        return classes;
      };
      function getOffset(offset, column) {
        return offset + (column.realWidth === null || Number.isNaN(column.realWidth) ? Number(column.width) : column.realWidth);
      }
      const getFixedColumnOffset = (index, fixed, store, realColumns) => {
        const {
          direction,
          start = 0,
          after = 0
        } = isFixedColumn(index, fixed, store, realColumns);
        if (!direction) {
          return;
        }
        const styles = {};
        const isLeft = direction === "left";
        const columns = store.states.columns.value;
        if (isLeft) {
          styles.left = columns.slice(0, start).reduce(getOffset, 0);
        } else {
          styles.right = columns.slice(after + 1).reverse().reduce(getOffset, 0);
        }
        return styles;
      };
      const ensurePosition = (style, key) => {
        if (!style)
          return;
        if (!Number.isNaN(style[key])) {
          style[key] = `${style[key]}px`;
        }
      };
      function useExpand(watcherData) {
        const instance = getCurrentInstance();
        const defaultExpandAll = ref(false);
        const expandRows = ref([]);
        const updateExpandRows = () => {
          const data = watcherData.data.value || [];
          const rowKey = watcherData.rowKey.value;
          if (defaultExpandAll.value) {
            expandRows.value = data.slice();
          } else if (rowKey) {
            const expandRowsMap = getKeysMap(expandRows.value, rowKey);
            expandRows.value = data.reduce((prev, row) => {
              const rowId = getRowIdentity(row, rowKey);
              const rowInfo = expandRowsMap[rowId];
              if (rowInfo) {
                prev.push(row);
              }
              return prev;
            }, []);
          } else {
            expandRows.value = [];
          }
        };
        const toggleRowExpansion = (row, expanded) => {
          const changed = toggleRowStatus(expandRows.value, row, expanded);
          if (changed) {
            instance.emit("expand-change", row, expandRows.value.slice());
          }
        };
        const setExpandRowKeys = (rowKeys) => {
          instance.store.assertRowKey();
          const data = watcherData.data.value || [];
          const rowKey = watcherData.rowKey.value;
          const keysMap = getKeysMap(data, rowKey);
          expandRows.value = rowKeys.reduce((prev, cur) => {
            const info = keysMap[cur];
            if (info) {
              prev.push(info.row);
            }
            return prev;
          }, []);
        };
        const isRowExpanded = (row) => {
          const rowKey = watcherData.rowKey.value;
          if (rowKey) {
            const expandMap = getKeysMap(expandRows.value, rowKey);
            return !!expandMap[getRowIdentity(row, rowKey)];
          }
          return expandRows.value.includes(row);
        };
        return {
          updateExpandRows,
          toggleRowExpansion,
          setExpandRowKeys,
          isRowExpanded,
          states: {
            expandRows,
            defaultExpandAll
          }
        };
      }
      function useCurrent(watcherData) {
        const instance = getCurrentInstance();
        const _currentRowKey = ref(null);
        const currentRow = ref(null);
        const setCurrentRowKey = (key) => {
          instance.store.assertRowKey();
          _currentRowKey.value = key;
          setCurrentRowByKey(key);
        };
        const restoreCurrentRowKey = () => {
          _currentRowKey.value = null;
        };
        const setCurrentRowByKey = (key) => {
          const { data, rowKey } = watcherData;
          let _currentRow = null;
          if (rowKey.value) {
            _currentRow = (unref(data) || []).find((item) => getRowIdentity(item, rowKey.value) === key);
          }
          currentRow.value = _currentRow;
          instance.emit("current-change", currentRow.value, null);
        };
        const updateCurrentRow = (_currentRow) => {
          const oldCurrentRow = currentRow.value;
          if (_currentRow && _currentRow !== oldCurrentRow) {
            currentRow.value = _currentRow;
            instance.emit("current-change", currentRow.value, oldCurrentRow);
            return;
          }
          if (!_currentRow && oldCurrentRow) {
            currentRow.value = null;
            instance.emit("current-change", null, oldCurrentRow);
          }
        };
        const updateCurrentRowData = () => {
          const rowKey = watcherData.rowKey.value;
          const data = watcherData.data.value || [];
          const oldCurrentRow = currentRow.value;
          if (!data.includes(oldCurrentRow) && oldCurrentRow) {
            if (rowKey) {
              const currentRowKey = getRowIdentity(oldCurrentRow, rowKey);
              setCurrentRowByKey(currentRowKey);
            } else {
              currentRow.value = null;
            }
            if (currentRow.value === null) {
              instance.emit("current-change", null, oldCurrentRow);
            }
          } else if (_currentRowKey.value) {
            setCurrentRowByKey(_currentRowKey.value);
            restoreCurrentRowKey();
          }
        };
        return {
          setCurrentRowKey,
          restoreCurrentRowKey,
          setCurrentRowByKey,
          updateCurrentRow,
          updateCurrentRowData,
          states: {
            _currentRowKey,
            currentRow
          }
        };
      }
      function useTree(watcherData) {
        const expandRowKeys = ref([]);
        const treeData = ref({});
        const indent = ref(16);
        const lazy = ref(false);
        const lazyTreeNodeMap = ref({});
        const lazyColumnIdentifier = ref("hasChildren");
        const childrenColumnName = ref("children");
        const instance = getCurrentInstance();
        const normalizedData = computed$1(() => {
          if (!watcherData.rowKey.value)
            return {};
          const data = watcherData.data.value || [];
          return normalize(data);
        });
        const normalizedLazyNode = computed$1(() => {
          const rowKey = watcherData.rowKey.value;
          const keys2 = Object.keys(lazyTreeNodeMap.value);
          const res = {};
          if (!keys2.length)
            return res;
          keys2.forEach((key) => {
            if (lazyTreeNodeMap.value[key].length) {
              const item = { children: [] };
              lazyTreeNodeMap.value[key].forEach((row) => {
                const currentRowKey = getRowIdentity(row, rowKey);
                item.children.push(currentRowKey);
                if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) {
                  res[currentRowKey] = { children: [] };
                }
              });
              res[key] = item;
            }
          });
          return res;
        });
        const normalize = (data) => {
          const rowKey = watcherData.rowKey.value;
          const res = {};
          walkTreeNode(data, (parent, children, level) => {
            const parentId = getRowIdentity(parent, rowKey);
            if (Array.isArray(children)) {
              res[parentId] = {
                children: children.map((row) => getRowIdentity(row, rowKey)),
                level
              };
            } else if (lazy.value) {
              res[parentId] = {
                children: [],
                lazy: true,
                level
              };
            }
          }, childrenColumnName.value, lazyColumnIdentifier.value);
          return res;
        };
        const updateTreeData = (ifChangeExpandRowKeys = false, ifExpandAll = ((_a2) => (_a2 = instance.store) == null ? void 0 : _a2.states.defaultExpandAll.value)()) => {
          var _a2;
          const nested = normalizedData.value;
          const normalizedLazyNode_ = normalizedLazyNode.value;
          const keys2 = Object.keys(nested);
          const newTreeData = {};
          if (keys2.length) {
            const oldTreeData = unref(treeData);
            const rootLazyRowKeys = [];
            const getExpanded = (oldValue, key) => {
              if (ifChangeExpandRowKeys) {
                if (expandRowKeys.value) {
                  return ifExpandAll || expandRowKeys.value.includes(key);
                } else {
                  return !!(ifExpandAll || (oldValue == null ? void 0 : oldValue.expanded));
                }
              } else {
                const included = ifExpandAll || expandRowKeys.value && expandRowKeys.value.includes(key);
                return !!((oldValue == null ? void 0 : oldValue.expanded) || included);
              }
            };
            keys2.forEach((key) => {
              const oldValue = oldTreeData[key];
              const newValue = { ...nested[key] };
              newValue.expanded = getExpanded(oldValue, key);
              if (newValue.lazy) {
                const { loaded = false, loading = false } = oldValue || {};
                newValue.loaded = !!loaded;
                newValue.loading = !!loading;
                rootLazyRowKeys.push(key);
              }
              newTreeData[key] = newValue;
            });
            const lazyKeys = Object.keys(normalizedLazyNode_);
            if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {
              lazyKeys.forEach((key) => {
                const oldValue = oldTreeData[key];
                const lazyNodeChildren = normalizedLazyNode_[key].children;
                if (rootLazyRowKeys.includes(key)) {
                  if (newTreeData[key].children.length !== 0) {
                    throw new Error("[ElTable]children must be an empty array.");
                  }
                  newTreeData[key].children = lazyNodeChildren;
                } else {
                  const { loaded = false, loading = false } = oldValue || {};
                  newTreeData[key] = {
                    lazy: true,
                    loaded: !!loaded,
                    loading: !!loading,
                    expanded: getExpanded(oldValue, key),
                    children: lazyNodeChildren,
                    level: ""
                  };
                }
              });
            }
          }
          treeData.value = newTreeData;
          (_a2 = instance.store) == null ? void 0 : _a2.updateTableScrollY();
        };
        watch(() => expandRowKeys.value, () => {
          updateTreeData(true);
        });
        watch(() => normalizedData.value, () => {
          updateTreeData();
        });
        watch(() => normalizedLazyNode.value, () => {
          updateTreeData();
        });
        const updateTreeExpandKeys = (value) => {
          expandRowKeys.value = value;
          updateTreeData();
        };
        const toggleTreeExpansion = (row, expanded) => {
          instance.store.assertRowKey();
          const rowKey = watcherData.rowKey.value;
          const id = getRowIdentity(row, rowKey);
          const data = id && treeData.value[id];
          if (id && data && "expanded" in data) {
            const oldExpanded = data.expanded;
            expanded = typeof expanded === "undefined" ? !data.expanded : expanded;
            treeData.value[id].expanded = expanded;
            if (oldExpanded !== expanded) {
              instance.emit("expand-change", row, expanded);
            }
            instance.store.updateTableScrollY();
          }
        };
        const loadOrToggle = (row) => {
          instance.store.assertRowKey();
          const rowKey = watcherData.rowKey.value;
          const id = getRowIdentity(row, rowKey);
          const data = treeData.value[id];
          if (lazy.value && data && "loaded" in data && !data.loaded) {
            loadData(row, id, data);
          } else {
            toggleTreeExpansion(row, void 0);
          }
        };
        const loadData = (row, key, treeNode) => {
          const { load } = instance.props;
          if (load && !treeData.value[key].loaded) {
            treeData.value[key].loading = true;
            load(row, treeNode, (data) => {
              if (!Array.isArray(data)) {
                throw new TypeError("[ElTable] data must be an array");
              }
              treeData.value[key].loading = false;
              treeData.value[key].loaded = true;
              treeData.value[key].expanded = true;
              if (data.length) {
                lazyTreeNodeMap.value[key] = data;
              }
              instance.emit("expand-change", row, true);
            });
          }
        };
        return {
          loadData,
          loadOrToggle,
          toggleTreeExpansion,
          updateTreeExpandKeys,
          updateTreeData,
          normalize,
          states: {
            expandRowKeys,
            treeData,
            indent,
            lazy,
            lazyTreeNodeMap,
            lazyColumnIdentifier,
            childrenColumnName
          }
        };
      }
      const sortData = (data, states) => {
        const sortingColumn = states.sortingColumn;
        if (!sortingColumn || typeof sortingColumn.sortable === "string") {
          return data;
        }
        return orderBy(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);
      };
      const doFlattenColumns = (columns) => {
        const result = [];
        columns.forEach((column) => {
          if (column.children && column.children.length > 0) {
            result.push.apply(result, doFlattenColumns(column.children));
          } else {
            result.push(column);
          }
        });
        return result;
      };
      function useWatcher$1() {
        var _a2;
        const instance = getCurrentInstance();
        const { size: tableSize } = toRefs((_a2 = instance.proxy) == null ? void 0 : _a2.$props);
        const rowKey = ref(null);
        const data = ref([]);
        const _data = ref([]);
        const isComplex = ref(false);
        const _columns = ref([]);
        const originColumns = ref([]);
        const columns = ref([]);
        const fixedColumns = ref([]);
        const rightFixedColumns = ref([]);
        const leafColumns = ref([]);
        const fixedLeafColumns = ref([]);
        const rightFixedLeafColumns = ref([]);
        const updateOrderFns = [];
        const leafColumnsLength = ref(0);
        const fixedLeafColumnsLength = ref(0);
        const rightFixedLeafColumnsLength = ref(0);
        const isAllSelected = ref(false);
        const selection = ref([]);
        const reserveSelection = ref(false);
        const selectOnIndeterminate = ref(false);
        const selectable = ref(null);
        const filters = ref({});
        const filteredData = ref(null);
        const sortingColumn = ref(null);
        const sortProp = ref(null);
        const sortOrder = ref(null);
        const hoverRow = ref(null);
        watch(data, () => instance.state && scheduleLayout(false), {
          deep: true
        });
        const assertRowKey = () => {
          if (!rowKey.value)
            throw new Error("[ElTable] prop row-key is required");
        };
        const updateChildFixed = (column) => {
          var _a22;
          (_a22 = column.children) == null ? void 0 : _a22.forEach((childColumn) => {
            childColumn.fixed = column.fixed;
            updateChildFixed(childColumn);
          });
        };
        const updateColumns = () => {
          _columns.value.forEach((column) => {
            updateChildFixed(column);
          });
          fixedColumns.value = _columns.value.filter((column) => column.fixed === true || column.fixed === "left");
          rightFixedColumns.value = _columns.value.filter((column) => column.fixed === "right");
          if (fixedColumns.value.length > 0 && _columns.value[0] && _columns.value[0].type === "selection" && !_columns.value[0].fixed) {
            _columns.value[0].fixed = true;
            fixedColumns.value.unshift(_columns.value[0]);
          }
          const notFixedColumns = _columns.value.filter((column) => !column.fixed);
          originColumns.value = [].concat(fixedColumns.value).concat(notFixedColumns).concat(rightFixedColumns.value);
          const leafColumns2 = doFlattenColumns(notFixedColumns);
          const fixedLeafColumns2 = doFlattenColumns(fixedColumns.value);
          const rightFixedLeafColumns2 = doFlattenColumns(rightFixedColumns.value);
          leafColumnsLength.value = leafColumns2.length;
          fixedLeafColumnsLength.value = fixedLeafColumns2.length;
          rightFixedLeafColumnsLength.value = rightFixedLeafColumns2.length;
          columns.value = [].concat(fixedLeafColumns2).concat(leafColumns2).concat(rightFixedLeafColumns2);
          isComplex.value = fixedColumns.value.length > 0 || rightFixedColumns.value.length > 0;
        };
        const scheduleLayout = (needUpdateColumns, immediate = false) => {
          if (needUpdateColumns) {
            updateColumns();
          }
          if (immediate) {
            instance.state.doLayout();
          } else {
            instance.state.debouncedUpdateLayout();
          }
        };
        const isSelected = (row) => {
          return selection.value.includes(row);
        };
        const clearSelection = () => {
          isAllSelected.value = false;
          const oldSelection = selection.value;
          if (oldSelection.length) {
            selection.value = [];
            instance.emit("selection-change", []);
          }
        };
        const cleanSelection = () => {
          let deleted;
          if (rowKey.value) {
            deleted = [];
            const selectedMap = getKeysMap(selection.value, rowKey.value);
            const dataMap = getKeysMap(data.value, rowKey.value);
            for (const key in selectedMap) {
              if (hasOwn(selectedMap, key) && !dataMap[key]) {
                deleted.push(selectedMap[key].row);
              }
            }
          } else {
            deleted = selection.value.filter((item) => !data.value.includes(item));
          }
          if (deleted.length) {
            const newSelection = selection.value.filter((item) => !deleted.includes(item));
            selection.value = newSelection;
            instance.emit("selection-change", newSelection.slice());
          }
        };
        const getSelectionRows = () => {
          return (selection.value || []).slice();
        };
        const toggleRowSelection = (row, selected = void 0, emitChange = true) => {
          const changed = toggleRowStatus(selection.value, row, selected);
          if (changed) {
            const newSelection = (selection.value || []).slice();
            if (emitChange) {
              instance.emit("select", newSelection, row);
            }
            instance.emit("selection-change", newSelection);
          }
        };
        const _toggleAllSelection = () => {
          var _a22, _b;
          const value = selectOnIndeterminate.value ? !isAllSelected.value : !(isAllSelected.value || selection.value.length);
          isAllSelected.value = value;
          let selectionChanged = false;
          let childrenCount = 0;
          const rowKey2 = (_b = (_a22 = instance == null ? void 0 : instance.store) == null ? void 0 : _a22.states) == null ? void 0 : _b.rowKey.value;
          data.value.forEach((row, index) => {
            const rowIndex = index + childrenCount;
            if (selectable.value) {
              if (selectable.value.call(null, row, rowIndex) && toggleRowStatus(selection.value, row, value)) {
                selectionChanged = true;
              }
            } else {
              if (toggleRowStatus(selection.value, row, value)) {
                selectionChanged = true;
              }
            }
            childrenCount += getChildrenCount(getRowIdentity(row, rowKey2));
          });
          if (selectionChanged) {
            instance.emit("selection-change", selection.value ? selection.value.slice() : []);
          }
          instance.emit("select-all", selection.value);
        };
        const updateSelectionByRowKey = () => {
          const selectedMap = getKeysMap(selection.value, rowKey.value);
          data.value.forEach((row) => {
            const rowId = getRowIdentity(row, rowKey.value);
            const rowInfo = selectedMap[rowId];
            if (rowInfo) {
              selection.value[rowInfo.index] = row;
            }
          });
        };
        const updateAllSelected = () => {
          var _a22, _b, _c;
          if (((_a22 = data.value) == null ? void 0 : _a22.length) === 0) {
            isAllSelected.value = false;
            return;
          }
          let selectedMap;
          if (rowKey.value) {
            selectedMap = getKeysMap(selection.value, rowKey.value);
          }
          const isSelected2 = function(row) {
            if (selectedMap) {
              return !!selectedMap[getRowIdentity(row, rowKey.value)];
            } else {
              return selection.value.includes(row);
            }
          };
          let isAllSelected_ = true;
          let selectedCount = 0;
          let childrenCount = 0;
          for (let i = 0, j = (data.value || []).length; i < j; i++) {
            const keyProp = (_c = (_b = instance == null ? void 0 : instance.store) == null ? void 0 : _b.states) == null ? void 0 : _c.rowKey.value;
            const rowIndex = i + childrenCount;
            const item = data.value[i];
            const isRowSelectable = selectable.value && selectable.value.call(null, item, rowIndex);
            if (!isSelected2(item)) {
              if (!selectable.value || isRowSelectable) {
                isAllSelected_ = false;
                break;
              }
            } else {
              selectedCount++;
            }
            childrenCount += getChildrenCount(getRowIdentity(item, keyProp));
          }
          if (selectedCount === 0)
            isAllSelected_ = false;
          isAllSelected.value = isAllSelected_;
        };
        const getChildrenCount = (rowKey2) => {
          var _a22;
          if (!instance || !instance.store)
            return 0;
          const { treeData } = instance.store.states;
          let count = 0;
          const children = (_a22 = treeData.value[rowKey2]) == null ? void 0 : _a22.children;
          if (children) {
            count += children.length;
            children.forEach((childKey) => {
              count += getChildrenCount(childKey);
            });
          }
          return count;
        };
        const updateFilters = (columns2, values) => {
          if (!Array.isArray(columns2)) {
            columns2 = [columns2];
          }
          const filters_ = {};
          columns2.forEach((col) => {
            filters.value[col.id] = values;
            filters_[col.columnKey || col.id] = values;
          });
          return filters_;
        };
        const updateSort = (column, prop, order) => {
          if (sortingColumn.value && sortingColumn.value !== column) {
            sortingColumn.value.order = null;
          }
          sortingColumn.value = column;
          sortProp.value = prop;
          sortOrder.value = order;
        };
        const execFilter = () => {
          let sourceData = unref(_data);
          Object.keys(filters.value).forEach((columnId) => {
            const values = filters.value[columnId];
            if (!values || values.length === 0)
              return;
            const column = getColumnById({
              columns: columns.value
            }, columnId);
            if (column && column.filterMethod) {
              sourceData = sourceData.filter((row) => {
                return values.some((value) => column.filterMethod.call(null, value, row, column));
              });
            }
          });
          filteredData.value = sourceData;
        };
        const execSort = () => {
          data.value = sortData(filteredData.value, {
            sortingColumn: sortingColumn.value,
            sortProp: sortProp.value,
            sortOrder: sortOrder.value
          });
        };
        const execQuery = (ignore = void 0) => {
          if (!(ignore && ignore.filter)) {
            execFilter();
          }
          execSort();
        };
        const clearFilter = (columnKeys) => {
          const { tableHeaderRef } = instance.refs;
          if (!tableHeaderRef)
            return;
          const panels = Object.assign({}, tableHeaderRef.filterPanels);
          const keys2 = Object.keys(panels);
          if (!keys2.length)
            return;
          if (typeof columnKeys === "string") {
            columnKeys = [columnKeys];
          }
          if (Array.isArray(columnKeys)) {
            const columns_ = columnKeys.map((key) => getColumnByKey({
              columns: columns.value
            }, key));
            keys2.forEach((key) => {
              const column = columns_.find((col) => col.id === key);
              if (column) {
                column.filteredValue = [];
              }
            });
            instance.store.commit("filterChange", {
              column: columns_,
              values: [],
              silent: true,
              multi: true
            });
          } else {
            keys2.forEach((key) => {
              const column = columns.value.find((col) => col.id === key);
              if (column) {
                column.filteredValue = [];
              }
            });
            filters.value = {};
            instance.store.commit("filterChange", {
              column: {},
              values: [],
              silent: true
            });
          }
        };
        const clearSort = () => {
          if (!sortingColumn.value)
            return;
          updateSort(null, null, null);
          instance.store.commit("changeSortCondition", {
            silent: true
          });
        };
        const {
          setExpandRowKeys,
          toggleRowExpansion,
          updateExpandRows,
          states: expandStates,
          isRowExpanded
        } = useExpand({
          data,
          rowKey
        });
        const {
          updateTreeExpandKeys,
          toggleTreeExpansion,
          updateTreeData,
          loadOrToggle,
          states: treeStates
        } = useTree({
          data,
          rowKey
        });
        const {
          updateCurrentRowData,
          updateCurrentRow,
          setCurrentRowKey,
          states: currentData
        } = useCurrent({
          data,
          rowKey
        });
        const setExpandRowKeysAdapter = (val) => {
          setExpandRowKeys(val);
          updateTreeExpandKeys(val);
        };
        const toggleRowExpansionAdapter = (row, expanded) => {
          const hasExpandColumn = columns.value.some(({ type }) => type === "expand");
          if (hasExpandColumn) {
            toggleRowExpansion(row, expanded);
          } else {
            toggleTreeExpansion(row, expanded);
          }
        };
        return {
          assertRowKey,
          updateColumns,
          scheduleLayout,
          isSelected,
          clearSelection,
          cleanSelection,
          getSelectionRows,
          toggleRowSelection,
          _toggleAllSelection,
          toggleAllSelection: null,
          updateSelectionByRowKey,
          updateAllSelected,
          updateFilters,
          updateCurrentRow,
          updateSort,
          execFilter,
          execSort,
          execQuery,
          clearFilter,
          clearSort,
          toggleRowExpansion,
          setExpandRowKeysAdapter,
          setCurrentRowKey,
          toggleRowExpansionAdapter,
          isRowExpanded,
          updateExpandRows,
          updateCurrentRowData,
          loadOrToggle,
          updateTreeData,
          states: {
            tableSize,
            rowKey,
            data,
            _data,
            isComplex,
            _columns,
            originColumns,
            columns,
            fixedColumns,
            rightFixedColumns,
            leafColumns,
            fixedLeafColumns,
            rightFixedLeafColumns,
            updateOrderFns,
            leafColumnsLength,
            fixedLeafColumnsLength,
            rightFixedLeafColumnsLength,
            isAllSelected,
            selection,
            reserveSelection,
            selectOnIndeterminate,
            selectable,
            filters,
            filteredData,
            sortingColumn,
            sortProp,
            sortOrder,
            hoverRow,
            ...expandStates,
            ...treeStates,
            ...currentData
          }
        };
      }
      function replaceColumn(array, column) {
        return array.map((item) => {
          var _a2;
          if (item.id === column.id) {
            return column;
          } else if ((_a2 = item.children) == null ? void 0 : _a2.length) {
            item.children = replaceColumn(item.children, column);
          }
          return item;
        });
      }
      function sortColumn(array) {
        array.forEach((item) => {
          var _a2, _b;
          item.no = (_a2 = item.getColumnIndex) == null ? void 0 : _a2.call(item);
          if ((_b = item.children) == null ? void 0 : _b.length) {
            sortColumn(item.children);
          }
        });
        array.sort((cur, pre) => cur.no - pre.no);
      }
      function useStore() {
        const instance = getCurrentInstance();
        const watcher = useWatcher$1();
        const ns = useNamespace("table");
        const mutations = {
          setData(states, data) {
            const dataInstanceChanged = unref(states._data) !== data;
            states.data.value = data;
            states._data.value = data;
            instance.store.execQuery();
            instance.store.updateCurrentRowData();
            instance.store.updateExpandRows();
            instance.store.updateTreeData(instance.store.states.defaultExpandAll.value);
            if (unref(states.reserveSelection)) {
              instance.store.assertRowKey();
              instance.store.updateSelectionByRowKey();
            } else {
              if (dataInstanceChanged) {
                instance.store.clearSelection();
              } else {
                instance.store.cleanSelection();
              }
            }
            instance.store.updateAllSelected();
            if (instance.$ready) {
              instance.store.scheduleLayout();
            }
          },
          insertColumn(states, column, parent, updateColumnOrder) {
            const array = unref(states._columns);
            let newColumns = [];
            if (!parent) {
              array.push(column);
              newColumns = array;
            } else {
              if (parent && !parent.children) {
                parent.children = [];
              }
              parent.children.push(column);
              newColumns = replaceColumn(array, parent);
            }
            sortColumn(newColumns);
            states._columns.value = newColumns;
            states.updateOrderFns.push(updateColumnOrder);
            if (column.type === "selection") {
              states.selectable.value = column.selectable;
              states.reserveSelection.value = column.reserveSelection;
            }
            if (instance.$ready) {
              instance.store.updateColumns();
              instance.store.scheduleLayout();
            }
          },
          updateColumnOrder(states, column) {
            var _a2;
            const newColumnIndex = (_a2 = column.getColumnIndex) == null ? void 0 : _a2.call(column);
            if (newColumnIndex === column.no)
              return;
            sortColumn(states._columns.value);
            if (instance.$ready) {
              instance.store.updateColumns();
            }
          },
          removeColumn(states, column, parent, updateColumnOrder) {
            const array = unref(states._columns) || [];
            if (parent) {
              parent.children.splice(parent.children.findIndex((item) => item.id === column.id), 1);
              nextTick(() => {
                var _a2;
                if (((_a2 = parent.children) == null ? void 0 : _a2.length) === 0) {
                  delete parent.children;
                }
              });
              states._columns.value = replaceColumn(array, parent);
            } else {
              const index = array.indexOf(column);
              if (index > -1) {
                array.splice(index, 1);
                states._columns.value = array;
              }
            }
            const updateFnIndex = states.updateOrderFns.indexOf(updateColumnOrder);
            updateFnIndex > -1 && states.updateOrderFns.splice(updateFnIndex, 1);
            if (instance.$ready) {
              instance.store.updateColumns();
              instance.store.scheduleLayout();
            }
          },
          sort(states, options) {
            const { prop, order, init } = options;
            if (prop) {
              const column = unref(states.columns).find((column2) => column2.property === prop);
              if (column) {
                column.order = order;
                instance.store.updateSort(column, prop, order);
                instance.store.commit("changeSortCondition", { init });
              }
            }
          },
          changeSortCondition(states, options) {
            const { sortingColumn, sortProp, sortOrder } = states;
            const columnValue = unref(sortingColumn), propValue = unref(sortProp), orderValue = unref(sortOrder);
            if (orderValue === null) {
              states.sortingColumn.value = null;
              states.sortProp.value = null;
            }
            const ignore = { filter: true };
            instance.store.execQuery(ignore);
            if (!options || !(options.silent || options.init)) {
              instance.emit("sort-change", {
                column: columnValue,
                prop: propValue,
                order: orderValue
              });
            }
            instance.store.updateTableScrollY();
          },
          filterChange(_states, options) {
            const { column, values, silent } = options;
            const newFilters = instance.store.updateFilters(column, values);
            instance.store.execQuery();
            if (!silent) {
              instance.emit("filter-change", newFilters);
            }
            instance.store.updateTableScrollY();
          },
          toggleAllSelection() {
            instance.store.toggleAllSelection();
          },
          rowSelectedChanged(_states, row) {
            instance.store.toggleRowSelection(row);
            instance.store.updateAllSelected();
          },
          setHoverRow(states, row) {
            states.hoverRow.value = row;
          },
          setCurrentRow(_states, row) {
            instance.store.updateCurrentRow(row);
          }
        };
        const commit = function(name, ...args) {
          const mutations2 = instance.store.mutations;
          if (mutations2[name]) {
            mutations2[name].apply(instance, [instance.store.states].concat(args));
          } else {
            throw new Error(`Action not found: ${name}`);
          }
        };
        const updateTableScrollY = function() {
          nextTick(() => instance.layout.updateScrollY.apply(instance.layout));
        };
        return {
          ns,
          ...watcher,
          mutations,
          commit,
          updateTableScrollY
        };
      }
      const InitialStateMap = {
        rowKey: "rowKey",
        defaultExpandAll: "defaultExpandAll",
        selectOnIndeterminate: "selectOnIndeterminate",
        indent: "indent",
        lazy: "lazy",
        data: "data",
        ["treeProps.hasChildren"]: {
          key: "lazyColumnIdentifier",
          default: "hasChildren"
        },
        ["treeProps.children"]: {
          key: "childrenColumnName",
          default: "children"
        }
      };
      function createStore(table, props) {
        if (!table) {
          throw new Error("Table is required.");
        }
        const store = useStore();
        store.toggleAllSelection = debounce(store._toggleAllSelection, 10);
        Object.keys(InitialStateMap).forEach((key) => {
          handleValue(getArrKeysValue(props, key), key, store);
        });
        proxyTableProps(store, props);
        return store;
      }
      function proxyTableProps(store, props) {
        Object.keys(InitialStateMap).forEach((key) => {
          watch(() => getArrKeysValue(props, key), (value) => {
            handleValue(value, key, store);
          });
        });
      }
      function handleValue(value, propsKey, store) {
        let newVal = value;
        let storeKey = InitialStateMap[propsKey];
        if (typeof InitialStateMap[propsKey] === "object") {
          storeKey = storeKey.key;
          newVal = newVal || InitialStateMap[propsKey].default;
        }
        store.states[storeKey].value = newVal;
      }
      function getArrKeysValue(props, keys2) {
        if (keys2.includes(".")) {
          const keyList = keys2.split(".");
          let value = props;
          keyList.forEach((key) => {
            value = value[key];
          });
          return value;
        } else {
          return props[keys2];
        }
      }
      class TableLayout {
        constructor(options) {
          this.observers = [];
          this.table = null;
          this.store = null;
          this.columns = [];
          this.fit = true;
          this.showHeader = true;
          this.height = ref(null);
          this.scrollX = ref(false);
          this.scrollY = ref(false);
          this.bodyWidth = ref(null);
          this.fixedWidth = ref(null);
          this.rightFixedWidth = ref(null);
          this.gutterWidth = 0;
          for (const name in options) {
            if (hasOwn(options, name)) {
              if (isRef(this[name])) {
                this[name].value = options[name];
              } else {
                this[name] = options[name];
              }
            }
          }
          if (!this.table) {
            throw new Error("Table is required for Table Layout");
          }
          if (!this.store) {
            throw new Error("Store is required for Table Layout");
          }
        }
        updateScrollY() {
          const height = this.height.value;
          if (height === null)
            return false;
          const scrollBarRef = this.table.refs.scrollBarRef;
          if (this.table.vnode.el && (scrollBarRef == null ? void 0 : scrollBarRef.wrapRef)) {
            let scrollY = true;
            const prevScrollY = this.scrollY.value;
            scrollY = scrollBarRef.wrapRef.scrollHeight > scrollBarRef.wrapRef.clientHeight;
            this.scrollY.value = scrollY;
            return prevScrollY !== scrollY;
          }
          return false;
        }
        setHeight(value, prop = "height") {
          if (!isClient)
            return;
          const el = this.table.vnode.el;
          value = parseHeight(value);
          this.height.value = Number(value);
          if (!el && (value || value === 0))
            return nextTick(() => this.setHeight(value, prop));
          if (typeof value === "number") {
            el.style[prop] = `${value}px`;
            this.updateElsHeight();
          } else if (typeof value === "string") {
            el.style[prop] = value;
            this.updateElsHeight();
          }
        }
        setMaxHeight(value) {
          this.setHeight(value, "max-height");
        }
        getFlattenColumns() {
          const flattenColumns = [];
          const columns = this.table.store.states.columns.value;
          columns.forEach((column) => {
            if (column.isColumnGroup) {
              flattenColumns.push.apply(flattenColumns, column.columns);
            } else {
              flattenColumns.push(column);
            }
          });
          return flattenColumns;
        }
        updateElsHeight() {
          this.updateScrollY();
          this.notifyObservers("scrollable");
        }
        headerDisplayNone(elm) {
          if (!elm)
            return true;
          let headerChild = elm;
          while (headerChild.tagName !== "DIV") {
            if (getComputedStyle(headerChild).display === "none") {
              return true;
            }
            headerChild = headerChild.parentElement;
          }
          return false;
        }
        updateColumnsWidth() {
          if (!isClient)
            return;
          const fit = this.fit;
          const bodyWidth = this.table.vnode.el.clientWidth;
          let bodyMinWidth = 0;
          const flattenColumns = this.getFlattenColumns();
          const flexColumns = flattenColumns.filter((column) => typeof column.width !== "number");
          flattenColumns.forEach((column) => {
            if (typeof column.width === "number" && column.realWidth)
              column.realWidth = null;
          });
          if (flexColumns.length > 0 && fit) {
            flattenColumns.forEach((column) => {
              bodyMinWidth += Number(column.width || column.minWidth || 80);
            });
            if (bodyMinWidth <= bodyWidth) {
              this.scrollX.value = false;
              const totalFlexWidth = bodyWidth - bodyMinWidth;
              if (flexColumns.length === 1) {
                flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth;
              } else {
                const allColumnsWidth = flexColumns.reduce((prev, column) => prev + Number(column.minWidth || 80), 0);
                const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
                let noneFirstWidth = 0;
                flexColumns.forEach((column, index) => {
                  if (index === 0)
                    return;
                  const flexWidth = Math.floor(Number(column.minWidth || 80) * flexWidthPerPixel);
                  noneFirstWidth += flexWidth;
                  column.realWidth = Number(column.minWidth || 80) + flexWidth;
                });
                flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
              }
            } else {
              this.scrollX.value = true;
              flexColumns.forEach((column) => {
                column.realWidth = Number(column.minWidth);
              });
            }
            this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth);
            this.table.state.resizeState.value.width = this.bodyWidth.value;
          } else {
            flattenColumns.forEach((column) => {
              if (!column.width && !column.minWidth) {
                column.realWidth = 80;
              } else {
                column.realWidth = Number(column.width || column.minWidth);
              }
              bodyMinWidth += column.realWidth;
            });
            this.scrollX.value = bodyMinWidth > bodyWidth;
            this.bodyWidth.value = bodyMinWidth;
          }
          const fixedColumns = this.store.states.fixedColumns.value;
          if (fixedColumns.length > 0) {
            let fixedWidth = 0;
            fixedColumns.forEach((column) => {
              fixedWidth += Number(column.realWidth || column.width);
            });
            this.fixedWidth.value = fixedWidth;
          }
          const rightFixedColumns = this.store.states.rightFixedColumns.value;
          if (rightFixedColumns.length > 0) {
            let rightFixedWidth = 0;
            rightFixedColumns.forEach((column) => {
              rightFixedWidth += Number(column.realWidth || column.width);
            });
            this.rightFixedWidth.value = rightFixedWidth;
          }
          this.notifyObservers("columns");
        }
        addObserver(observer) {
          this.observers.push(observer);
        }
        removeObserver(observer) {
          const index = this.observers.indexOf(observer);
          if (index !== -1) {
            this.observers.splice(index, 1);
          }
        }
        notifyObservers(event) {
          const observers = this.observers;
          observers.forEach((observer) => {
            var _a2, _b;
            switch (event) {
              case "columns":
                (_a2 = observer.state) == null ? void 0 : _a2.onColumnsChange(this);
                break;
              case "scrollable":
                (_b = observer.state) == null ? void 0 : _b.onScrollableChange(this);
                break;
              default:
                throw new Error(`Table Layout don't have event ${event}.`);
            }
          });
        }
      }
      const { CheckboxGroup: ElCheckboxGroup } = ElCheckbox;
      const _sfc_main$8 = defineComponent({
        name: "ElTableFilterPanel",
        components: {
          ElCheckbox,
          ElCheckboxGroup,
          ElScrollbar,
          ElTooltip,
          ElIcon,
          ArrowDown: arrow_down_default,
          ArrowUp: arrow_up_default
        },
        directives: { ClickOutside },
        props: {
          placement: {
            type: String,
            default: "bottom-start"
          },
          store: {
            type: Object
          },
          column: {
            type: Object
          },
          upDataColumn: {
            type: Function
          }
        },
        setup(props) {
          const instance = getCurrentInstance();
          const { t } = useLocale();
          const ns = useNamespace("table-filter");
          const parent = instance == null ? void 0 : instance.parent;
          if (!parent.filterPanels.value[props.column.id]) {
            parent.filterPanels.value[props.column.id] = instance;
          }
          const tooltipVisible = ref(false);
          const tooltip = ref(null);
          const filters = computed$1(() => {
            return props.column && props.column.filters;
          });
          const filterClassName = computed$1(() => {
            if (props.column.filterClassName) {
              return `${ns.b()} ${props.column.filterClassName}`;
            }
            return ns.b();
          });
          const filterValue = computed$1({
            get: () => {
              var _a2;
              return (((_a2 = props.column) == null ? void 0 : _a2.filteredValue) || [])[0];
            },
            set: (value) => {
              if (filteredValue.value) {
                if (typeof value !== "undefined" && value !== null) {
                  filteredValue.value.splice(0, 1, value);
                } else {
                  filteredValue.value.splice(0, 1);
                }
              }
            }
          });
          const filteredValue = computed$1({
            get() {
              if (props.column) {
                return props.column.filteredValue || [];
              }
              return [];
            },
            set(value) {
              if (props.column) {
                props.upDataColumn("filteredValue", value);
              }
            }
          });
          const multiple = computed$1(() => {
            if (props.column) {
              return props.column.filterMultiple;
            }
            return true;
          });
          const isActive = (filter3) => {
            return filter3.value === filterValue.value;
          };
          const hidden = () => {
            tooltipVisible.value = false;
          };
          const showFilterPanel = (e) => {
            e.stopPropagation();
            tooltipVisible.value = !tooltipVisible.value;
          };
          const hideFilterPanel = () => {
            tooltipVisible.value = false;
          };
          const handleConfirm = () => {
            confirmFilter(filteredValue.value);
            hidden();
          };
          const handleReset = () => {
            filteredValue.value = [];
            confirmFilter(filteredValue.value);
            hidden();
          };
          const handleSelect = (_filterValue) => {
            filterValue.value = _filterValue;
            if (typeof _filterValue !== "undefined" && _filterValue !== null) {
              confirmFilter(filteredValue.value);
            } else {
              confirmFilter([]);
            }
            hidden();
          };
          const confirmFilter = (filteredValue2) => {
            props.store.commit("filterChange", {
              column: props.column,
              values: filteredValue2
            });
            props.store.updateAllSelected();
          };
          watch(tooltipVisible, (value) => {
            if (props.column) {
              props.upDataColumn("filterOpened", value);
            }
          }, {
            immediate: true
          });
          const popperPaneRef = computed$1(() => {
            var _a2, _b;
            return (_b = (_a2 = tooltip.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
          });
          return {
            tooltipVisible,
            multiple,
            filterClassName,
            filteredValue,
            filterValue,
            filters,
            handleConfirm,
            handleReset,
            handleSelect,
            isActive,
            t,
            ns,
            showFilterPanel,
            hideFilterPanel,
            popperPaneRef,
            tooltip
          };
        }
      });
      const _hoisted_1$6 = { key: 0 };
      const _hoisted_2$6 = ["disabled"];
      const _hoisted_3$5 = ["label", "onClick"];
      function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_checkbox = resolveComponent("el-checkbox");
        const _component_el_checkbox_group = resolveComponent("el-checkbox-group");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _component_arrow_up = resolveComponent("arrow-up");
        const _component_arrow_down = resolveComponent("arrow-down");
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_tooltip = resolveComponent("el-tooltip");
        const _directive_click_outside = resolveDirective("click-outside");
        return openBlock(), createBlock(_component_el_tooltip, {
          ref: "tooltip",
          visible: _ctx.tooltipVisible,
          offset: 0,
          placement: _ctx.placement,
          "show-arrow": false,
          "stop-popper-mouse-event": false,
          teleported: "",
          effect: "light",
          pure: "",
          "popper-class": _ctx.filterClassName,
          persistent: ""
        }, {
          content: withCtx(() => [
            _ctx.multiple ? (openBlock(), createElementBlock("div", _hoisted_1$6, [
              createElementVNode("div", {
                class: normalizeClass(_ctx.ns.e("content"))
              }, [
                createVNode(_component_el_scrollbar, {
                  "wrap-class": _ctx.ns.e("wrap")
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_checkbox_group, {
                      modelValue: _ctx.filteredValue,
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.filteredValue = $event),
                      class: normalizeClass(_ctx.ns.e("checkbox-group"))
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filters, (filter3) => {
                          return openBlock(), createBlock(_component_el_checkbox, {
                            key: filter3.value,
                            value: filter3.value
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString(filter3.text), 1)
                            ]),
                            _: 2
                          }, 1032, ["value"]);
                        }), 128))
                      ]),
                      _: 1
                    }, 8, ["modelValue", "class"])
                  ]),
                  _: 1
                }, 8, ["wrap-class"])
              ], 2),
              createElementVNode("div", {
                class: normalizeClass(_ctx.ns.e("bottom"))
              }, [
                createElementVNode("button", {
                  class: normalizeClass({ [_ctx.ns.is("disabled")]: _ctx.filteredValue.length === 0 }),
                  disabled: _ctx.filteredValue.length === 0,
                  type: "button",
                  onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleConfirm && _ctx.handleConfirm(...args))
                }, toDisplayString(_ctx.t("el.table.confirmFilter")), 11, _hoisted_2$6),
                createElementVNode("button", {
                  type: "button",
                  onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleReset && _ctx.handleReset(...args))
                }, toDisplayString(_ctx.t("el.table.resetFilter")), 1)
              ], 2)
            ])) : (openBlock(), createElementBlock("ul", {
              key: 1,
              class: normalizeClass(_ctx.ns.e("list"))
            }, [
              createElementVNode("li", {
                class: normalizeClass([
                  _ctx.ns.e("list-item"),
                  {
                    [_ctx.ns.is("active")]: _ctx.filterValue === void 0 || _ctx.filterValue === null
                  }
                ]),
                onClick: _cache[3] || (_cache[3] = ($event) => _ctx.handleSelect(null))
              }, toDisplayString(_ctx.t("el.table.clearFilter")), 3),
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filters, (filter3) => {
                return openBlock(), createElementBlock("li", {
                  key: filter3.value,
                  class: normalizeClass([_ctx.ns.e("list-item"), _ctx.ns.is("active", _ctx.isActive(filter3))]),
                  label: filter3.value,
                  onClick: ($event) => _ctx.handleSelect(filter3.value)
                }, toDisplayString(filter3.text), 11, _hoisted_3$5);
              }), 128))
            ], 2))
          ]),
          default: withCtx(() => [
            withDirectives((openBlock(), createElementBlock("span", {
              class: normalizeClass([
                `${_ctx.ns.namespace.value}-table__column-filter-trigger`,
                `${_ctx.ns.namespace.value}-none-outline`
              ]),
              onClick: _cache[4] || (_cache[4] = (...args) => _ctx.showFilterPanel && _ctx.showFilterPanel(...args))
            }, [
              createVNode(_component_el_icon, null, {
                default: withCtx(() => [
                  _ctx.column.filterOpened ? (openBlock(), createBlock(_component_arrow_up, { key: 0 })) : (openBlock(), createBlock(_component_arrow_down, { key: 1 }))
                ]),
                _: 1
              })
            ], 2)), [
              [_directive_click_outside, _ctx.hideFilterPanel, _ctx.popperPaneRef]
            ])
          ]),
          _: 1
        }, 8, ["visible", "placement", "popper-class"]);
      }
      var FilterPanel = /* @__PURE__ */ _export_sfc$1(_sfc_main$8, [["render", _sfc_render$5], ["__file", "filter-panel.vue"]]);
      function useLayoutObserver(root2) {
        const instance = getCurrentInstance();
        onBeforeMount(() => {
          tableLayout.value.addObserver(instance);
        });
        onMounted(() => {
          onColumnsChange(tableLayout.value);
          onScrollableChange(tableLayout.value);
        });
        onUpdated(() => {
          onColumnsChange(tableLayout.value);
          onScrollableChange(tableLayout.value);
        });
        onUnmounted(() => {
          tableLayout.value.removeObserver(instance);
        });
        const tableLayout = computed$1(() => {
          const layout = root2.layout;
          if (!layout) {
            throw new Error("Can not find table layout.");
          }
          return layout;
        });
        const onColumnsChange = (layout) => {
          var _a2;
          const cols = ((_a2 = root2.vnode.el) == null ? void 0 : _a2.querySelectorAll("colgroup > col")) || [];
          if (!cols.length)
            return;
          const flattenColumns = layout.getFlattenColumns();
          const columnsMap = {};
          flattenColumns.forEach((column) => {
            columnsMap[column.id] = column;
          });
          for (let i = 0, j = cols.length; i < j; i++) {
            const col = cols[i];
            const name = col.getAttribute("name");
            const column = columnsMap[name];
            if (column) {
              col.setAttribute("width", column.realWidth || column.width);
            }
          }
        };
        const onScrollableChange = (layout) => {
          var _a2, _b;
          const cols = ((_a2 = root2.vnode.el) == null ? void 0 : _a2.querySelectorAll("colgroup > col[name=gutter]")) || [];
          for (let i = 0, j = cols.length; i < j; i++) {
            const col = cols[i];
            col.setAttribute("width", layout.scrollY.value ? layout.gutterWidth : "0");
          }
          const ths = ((_b = root2.vnode.el) == null ? void 0 : _b.querySelectorAll("th.gutter")) || [];
          for (let i = 0, j = ths.length; i < j; i++) {
            const th = ths[i];
            th.style.width = layout.scrollY.value ? `${layout.gutterWidth}px` : "0";
            th.style.display = layout.scrollY.value ? "" : "none";
          }
        };
        return {
          tableLayout: tableLayout.value,
          onColumnsChange,
          onScrollableChange
        };
      }
      const TABLE_INJECTION_KEY = Symbol("ElTable");
      function useEvent(props, emit) {
        const instance = getCurrentInstance();
        const parent = inject(TABLE_INJECTION_KEY);
        const handleFilterClick = (event) => {
          event.stopPropagation();
          return;
        };
        const handleHeaderClick = (event, column) => {
          if (!column.filters && column.sortable) {
            handleSortClick(event, column, false);
          } else if (column.filterable && !column.sortable) {
            handleFilterClick(event);
          }
          parent == null ? void 0 : parent.emit("header-click", column, event);
        };
        const handleHeaderContextMenu = (event, column) => {
          parent == null ? void 0 : parent.emit("header-contextmenu", column, event);
        };
        const draggingColumn = ref(null);
        const dragging = ref(false);
        const dragState = ref({});
        const handleMouseDown = (event, column) => {
          if (!isClient)
            return;
          if (column.children && column.children.length > 0)
            return;
          if (draggingColumn.value && props.border) {
            dragging.value = true;
            const table = parent;
            emit("set-drag-visible", true);
            const tableEl = table == null ? void 0 : table.vnode.el;
            const tableLeft = tableEl.getBoundingClientRect().left;
            const columnEl = instance.vnode.el.querySelector(`th.${column.id}`);
            const columnRect = columnEl.getBoundingClientRect();
            const minLeft = columnRect.left - tableLeft + 30;
            addClass(columnEl, "noclick");
            dragState.value = {
              startMouseLeft: event.clientX,
              startLeft: columnRect.right - tableLeft,
              startColumnLeft: columnRect.left - tableLeft,
              tableLeft
            };
            const resizeProxy = table == null ? void 0 : table.refs.resizeProxy;
            resizeProxy.style.left = `${dragState.value.startLeft}px`;
            document.onselectstart = function() {
              return false;
            };
            document.ondragstart = function() {
              return false;
            };
            const handleMouseMove2 = (event2) => {
              const deltaLeft = event2.clientX - dragState.value.startMouseLeft;
              const proxyLeft = dragState.value.startLeft + deltaLeft;
              resizeProxy.style.left = `${Math.max(minLeft, proxyLeft)}px`;
            };
            const handleMouseUp = () => {
              if (dragging.value) {
                const { startColumnLeft, startLeft } = dragState.value;
                const finalLeft = Number.parseInt(resizeProxy.style.left, 10);
                const columnWidth = finalLeft - startColumnLeft;
                column.width = column.realWidth = columnWidth;
                table == null ? void 0 : table.emit("header-dragend", column.width, startLeft - startColumnLeft, column, event);
                requestAnimationFrame(() => {
                  props.store.scheduleLayout(false, true);
                });
                document.body.style.cursor = "";
                dragging.value = false;
                draggingColumn.value = null;
                dragState.value = {};
                emit("set-drag-visible", false);
              }
              document.removeEventListener("mousemove", handleMouseMove2);
              document.removeEventListener("mouseup", handleMouseUp);
              document.onselectstart = null;
              document.ondragstart = null;
              setTimeout(() => {
                removeClass(columnEl, "noclick");
              }, 0);
            };
            document.addEventListener("mousemove", handleMouseMove2);
            document.addEventListener("mouseup", handleMouseUp);
          }
        };
        const handleMouseMove = (event, column) => {
          if (column.children && column.children.length > 0)
            return;
          const el = event.target;
          if (!isElement(el)) {
            return;
          }
          const target = el == null ? void 0 : el.closest("th");
          if (!column || !column.resizable)
            return;
          if (!dragging.value && props.border) {
            const rect = target.getBoundingClientRect();
            const bodyStyle = document.body.style;
            if (rect.width > 12 && rect.right - event.pageX < 8) {
              bodyStyle.cursor = "col-resize";
              if (hasClass(target, "is-sortable")) {
                target.style.cursor = "col-resize";
              }
              draggingColumn.value = column;
            } else if (!dragging.value) {
              bodyStyle.cursor = "";
              if (hasClass(target, "is-sortable")) {
                target.style.cursor = "pointer";
              }
              draggingColumn.value = null;
            }
          }
        };
        const handleMouseOut = () => {
          if (!isClient)
            return;
          document.body.style.cursor = "";
        };
        const toggleOrder = ({ order, sortOrders }) => {
          if (order === "")
            return sortOrders[0];
          const index = sortOrders.indexOf(order || null);
          return sortOrders[index > sortOrders.length - 2 ? 0 : index + 1];
        };
        const handleSortClick = (event, column, givenOrder) => {
          var _a2;
          event.stopPropagation();
          const order = column.order === givenOrder ? null : givenOrder || toggleOrder(column);
          const target = (_a2 = event.target) == null ? void 0 : _a2.closest("th");
          if (target) {
            if (hasClass(target, "noclick")) {
              removeClass(target, "noclick");
              return;
            }
          }
          if (!column.sortable)
            return;
          const states = props.store.states;
          let sortProp = states.sortProp.value;
          let sortOrder;
          const sortingColumn = states.sortingColumn.value;
          if (sortingColumn !== column || sortingColumn === column && sortingColumn.order === null) {
            if (sortingColumn) {
              sortingColumn.order = null;
            }
            states.sortingColumn.value = column;
            sortProp = column.property;
          }
          if (!order) {
            sortOrder = column.order = null;
          } else {
            sortOrder = column.order = order;
          }
          states.sortProp.value = sortProp;
          states.sortOrder.value = sortOrder;
          parent == null ? void 0 : parent.store.commit("changeSortCondition");
        };
        return {
          handleHeaderClick,
          handleHeaderContextMenu,
          handleMouseDown,
          handleMouseMove,
          handleMouseOut,
          handleSortClick,
          handleFilterClick
        };
      }
      function useStyle$2(props) {
        const parent = inject(TABLE_INJECTION_KEY);
        const ns = useNamespace("table");
        const getHeaderRowStyle = (rowIndex) => {
          const headerRowStyle = parent == null ? void 0 : parent.props.headerRowStyle;
          if (typeof headerRowStyle === "function") {
            return headerRowStyle.call(null, { rowIndex });
          }
          return headerRowStyle;
        };
        const getHeaderRowClass = (rowIndex) => {
          const classes = [];
          const headerRowClassName = parent == null ? void 0 : parent.props.headerRowClassName;
          if (typeof headerRowClassName === "string") {
            classes.push(headerRowClassName);
          } else if (typeof headerRowClassName === "function") {
            classes.push(headerRowClassName.call(null, { rowIndex }));
          }
          return classes.join(" ");
        };
        const getHeaderCellStyle = (rowIndex, columnIndex, row, column) => {
          var _a2;
          let headerCellStyles = (_a2 = parent == null ? void 0 : parent.props.headerCellStyle) != null ? _a2 : {};
          if (typeof headerCellStyles === "function") {
            headerCellStyles = headerCellStyles.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            });
          }
          const fixedStyle = getFixedColumnOffset(columnIndex, column.fixed, props.store, row);
          ensurePosition(fixedStyle, "left");
          ensurePosition(fixedStyle, "right");
          return Object.assign({}, headerCellStyles, fixedStyle);
        };
        const getHeaderCellClass = (rowIndex, columnIndex, row, column) => {
          const fixedClasses = getFixedColumnsClass(ns.b(), columnIndex, column.fixed, props.store, row);
          const classes = [
            column.id,
            column.order,
            column.headerAlign,
            column.className,
            column.labelClassName,
            ...fixedClasses
          ];
          if (!column.children) {
            classes.push("is-leaf");
          }
          if (column.sortable) {
            classes.push("is-sortable");
          }
          const headerCellClassName = parent == null ? void 0 : parent.props.headerCellClassName;
          if (typeof headerCellClassName === "string") {
            classes.push(headerCellClassName);
          } else if (typeof headerCellClassName === "function") {
            classes.push(headerCellClassName.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            }));
          }
          classes.push(ns.e("cell"));
          return classes.filter((className) => Boolean(className)).join(" ");
        };
        return {
          getHeaderRowStyle,
          getHeaderRowClass,
          getHeaderCellStyle,
          getHeaderCellClass
        };
      }
      const getAllColumns = (columns) => {
        const result = [];
        columns.forEach((column) => {
          if (column.children) {
            result.push(column);
            result.push.apply(result, getAllColumns(column.children));
          } else {
            result.push(column);
          }
        });
        return result;
      };
      const convertToRows = (originColumns) => {
        let maxLevel = 1;
        const traverse = (column, parent) => {
          if (parent) {
            column.level = parent.level + 1;
            if (maxLevel < column.level) {
              maxLevel = column.level;
            }
          }
          if (column.children) {
            let colSpan = 0;
            column.children.forEach((subColumn) => {
              traverse(subColumn, column);
              colSpan += subColumn.colSpan;
            });
            column.colSpan = colSpan;
          } else {
            column.colSpan = 1;
          }
        };
        originColumns.forEach((column) => {
          column.level = 1;
          traverse(column, void 0);
        });
        const rows = [];
        for (let i = 0; i < maxLevel; i++) {
          rows.push([]);
        }
        const allColumns = getAllColumns(originColumns);
        allColumns.forEach((column) => {
          if (!column.children) {
            column.rowSpan = maxLevel - column.level + 1;
          } else {
            column.rowSpan = 1;
            column.children.forEach((col) => col.isSubColumn = true);
          }
          rows[column.level - 1].push(column);
        });
        return rows;
      };
      function useUtils$1(props) {
        const parent = inject(TABLE_INJECTION_KEY);
        const columnRows = computed$1(() => {
          return convertToRows(props.store.states.originColumns.value);
        });
        const isGroup = computed$1(() => {
          const result = columnRows.value.length > 1;
          if (result && parent) {
            parent.state.isGroup.value = true;
          }
          return result;
        });
        const toggleAllSelection = (event) => {
          event.stopPropagation();
          parent == null ? void 0 : parent.store.commit("toggleAllSelection");
        };
        return {
          isGroup,
          toggleAllSelection,
          columnRows
        };
      }
      var TableHeader = defineComponent({
        name: "ElTableHeader",
        components: {
          ElCheckbox
        },
        props: {
          fixed: {
            type: String,
            default: ""
          },
          store: {
            required: true,
            type: Object
          },
          border: Boolean,
          defaultSort: {
            type: Object,
            default: () => {
              return {
                prop: "",
                order: ""
              };
            }
          }
        },
        setup(props, { emit }) {
          const instance = getCurrentInstance();
          const parent = inject(TABLE_INJECTION_KEY);
          const ns = useNamespace("table");
          const filterPanels = ref({});
          const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent);
          onMounted(async () => {
            await nextTick();
            await nextTick();
            const { prop, order } = props.defaultSort;
            parent == null ? void 0 : parent.store.commit("sort", { prop, order, init: true });
          });
          const {
            handleHeaderClick,
            handleHeaderContextMenu,
            handleMouseDown,
            handleMouseMove,
            handleMouseOut,
            handleSortClick,
            handleFilterClick
          } = useEvent(props, emit);
          const {
            getHeaderRowStyle,
            getHeaderRowClass,
            getHeaderCellStyle,
            getHeaderCellClass
          } = useStyle$2(props);
          const { isGroup, toggleAllSelection, columnRows } = useUtils$1(props);
          instance.state = {
            onColumnsChange,
            onScrollableChange
          };
          instance.filterPanels = filterPanels;
          return {
            ns,
            filterPanels,
            onColumnsChange,
            onScrollableChange,
            columnRows,
            getHeaderRowClass,
            getHeaderRowStyle,
            getHeaderCellClass,
            getHeaderCellStyle,
            handleHeaderClick,
            handleHeaderContextMenu,
            handleMouseDown,
            handleMouseMove,
            handleMouseOut,
            handleSortClick,
            handleFilterClick,
            isGroup,
            toggleAllSelection
          };
        },
        render() {
          const {
            ns,
            isGroup,
            columnRows,
            getHeaderCellStyle,
            getHeaderCellClass,
            getHeaderRowClass,
            getHeaderRowStyle,
            handleHeaderClick,
            handleHeaderContextMenu,
            handleMouseDown,
            handleMouseMove,
            handleSortClick,
            handleMouseOut,
            store,
            $parent
          } = this;
          let rowSpan = 1;
          return h$1("thead", {
            class: { [ns.is("group")]: isGroup }
          }, columnRows.map((subColumns, rowIndex) => h$1("tr", {
            class: getHeaderRowClass(rowIndex),
            key: rowIndex,
            style: getHeaderRowStyle(rowIndex)
          }, subColumns.map((column, cellIndex) => {
            if (column.rowSpan > rowSpan) {
              rowSpan = column.rowSpan;
            }
            return h$1("th", {
              class: getHeaderCellClass(rowIndex, cellIndex, subColumns, column),
              colspan: column.colSpan,
              key: `${column.id}-thead`,
              rowspan: column.rowSpan,
              style: getHeaderCellStyle(rowIndex, cellIndex, subColumns, column),
              onClick: ($event) => handleHeaderClick($event, column),
              onContextmenu: ($event) => handleHeaderContextMenu($event, column),
              onMousedown: ($event) => handleMouseDown($event, column),
              onMousemove: ($event) => handleMouseMove($event, column),
              onMouseout: handleMouseOut
            }, [
              h$1("div", {
                class: [
                  "cell",
                  column.filteredValue && column.filteredValue.length > 0 ? "highlight" : ""
                ]
              }, [
                column.renderHeader ? column.renderHeader({
                  column,
                  $index: cellIndex,
                  store,
                  _self: $parent
                }) : column.label,
                column.sortable && h$1("span", {
                  onClick: ($event) => handleSortClick($event, column),
                  class: "caret-wrapper"
                }, [
                  h$1("i", {
                    onClick: ($event) => handleSortClick($event, column, "ascending"),
                    class: "sort-caret ascending"
                  }),
                  h$1("i", {
                    onClick: ($event) => handleSortClick($event, column, "descending"),
                    class: "sort-caret descending"
                  })
                ]),
                column.filterable && h$1(FilterPanel, {
                  store,
                  placement: column.filterPlacement || "bottom-start",
                  column,
                  upDataColumn: (key, value) => {
                    column[key] = value;
                  }
                })
              ])
            ]);
          }))));
        }
      });
      function useEvents(props) {
        const parent = inject(TABLE_INJECTION_KEY);
        const tooltipContent = ref("");
        const tooltipTrigger = ref(h$1("div"));
        const handleEvent = (event, row, name) => {
          var _a2;
          const table = parent;
          const cell = getCell(event);
          let column;
          const namespace = (_a2 = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a2.dataset.prefix;
          if (cell) {
            column = getColumnByCell({
              columns: props.store.states.columns.value
            }, cell, namespace);
            if (column) {
              table == null ? void 0 : table.emit(`cell-${name}`, row, column, cell, event);
            }
          }
          table == null ? void 0 : table.emit(`row-${name}`, row, column, event);
        };
        const handleDoubleClick = (event, row) => {
          handleEvent(event, row, "dblclick");
        };
        const handleClick = (event, row) => {
          props.store.commit("setCurrentRow", row);
          handleEvent(event, row, "click");
        };
        const handleContextMenu = (event, row) => {
          handleEvent(event, row, "contextmenu");
        };
        const handleMouseEnter = debounce((index) => {
          props.store.commit("setHoverRow", index);
        }, 30);
        const handleMouseLeave = debounce(() => {
          props.store.commit("setHoverRow", null);
        }, 30);
        const getPadding = (el) => {
          const style = window.getComputedStyle(el, null);
          const paddingLeft = Number.parseInt(style.paddingLeft, 10) || 0;
          const paddingRight = Number.parseInt(style.paddingRight, 10) || 0;
          const paddingTop = Number.parseInt(style.paddingTop, 10) || 0;
          const paddingBottom = Number.parseInt(style.paddingBottom, 10) || 0;
          return {
            left: paddingLeft,
            right: paddingRight,
            top: paddingTop,
            bottom: paddingBottom
          };
        };
        const toggleRowClassByCell = (rowSpan, event, toggle) => {
          let node = event.target.parentNode;
          while (rowSpan > 1) {
            node = node == null ? void 0 : node.nextSibling;
            if (!node || node.nodeName !== "TR")
              break;
            toggle(node, "hover-row hover-fixed-row");
            rowSpan--;
          }
        };
        const handleCellMouseEnter = (event, row, tooltipOptions) => {
          var _a2;
          const table = parent;
          const cell = getCell(event);
          const namespace = (_a2 = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a2.dataset.prefix;
          if (cell) {
            const column = getColumnByCell({
              columns: props.store.states.columns.value
            }, cell, namespace);
            if (cell.rowSpan > 1) {
              toggleRowClassByCell(cell.rowSpan, event, addClass);
            }
            const hoverState = table.hoverState = { cell, column, row };
            table == null ? void 0 : table.emit("cell-mouse-enter", hoverState.row, hoverState.column, hoverState.cell, event);
          }
          if (!tooltipOptions) {
            return;
          }
          const cellChild = event.target.querySelector(".cell");
          if (!(hasClass(cellChild, `${namespace}-tooltip`) && cellChild.childNodes.length)) {
            return;
          }
          const range = document.createRange();
          range.setStart(cellChild, 0);
          range.setEnd(cellChild, cellChild.childNodes.length);
          let rangeWidth = range.getBoundingClientRect().width;
          let rangeHeight = range.getBoundingClientRect().height;
          const offsetWidth = rangeWidth - Math.floor(rangeWidth);
          if (offsetWidth < 1e-3) {
            rangeWidth = Math.floor(rangeWidth);
          }
          const offsetHeight = rangeHeight - Math.floor(rangeHeight);
          if (offsetHeight < 1e-3) {
            rangeHeight = Math.floor(rangeHeight);
          }
          const { top, left, right, bottom } = getPadding(cellChild);
          const horizontalPadding = left + right;
          const verticalPadding = top + bottom;
          if (rangeWidth + horizontalPadding > cellChild.offsetWidth || rangeHeight + verticalPadding > cellChild.offsetHeight || cellChild.scrollWidth > cellChild.offsetWidth) {
            createTablePopper(tooltipOptions, cell.innerText || cell.textContent, cell, table);
          }
        };
        const handleCellMouseLeave = (event) => {
          const cell = getCell(event);
          if (!cell)
            return;
          if (cell.rowSpan > 1) {
            toggleRowClassByCell(cell.rowSpan, event, removeClass);
          }
          const oldHoverState = parent == null ? void 0 : parent.hoverState;
          parent == null ? void 0 : parent.emit("cell-mouse-leave", oldHoverState == null ? void 0 : oldHoverState.row, oldHoverState == null ? void 0 : oldHoverState.column, oldHoverState == null ? void 0 : oldHoverState.cell, event);
        };
        return {
          handleDoubleClick,
          handleClick,
          handleContextMenu,
          handleMouseEnter,
          handleMouseLeave,
          handleCellMouseEnter,
          handleCellMouseLeave,
          tooltipContent,
          tooltipTrigger
        };
      }
      function useStyles(props) {
        const parent = inject(TABLE_INJECTION_KEY);
        const ns = useNamespace("table");
        const getRowStyle = (row, rowIndex) => {
          const rowStyle = parent == null ? void 0 : parent.props.rowStyle;
          if (typeof rowStyle === "function") {
            return rowStyle.call(null, {
              row,
              rowIndex
            });
          }
          return rowStyle || null;
        };
        const getRowClass = (row, rowIndex) => {
          const classes = [ns.e("row")];
          if ((parent == null ? void 0 : parent.props.highlightCurrentRow) && row === props.store.states.currentRow.value) {
            classes.push("current-row");
          }
          if (props.stripe && rowIndex % 2 === 1) {
            classes.push(ns.em("row", "striped"));
          }
          const rowClassName = parent == null ? void 0 : parent.props.rowClassName;
          if (typeof rowClassName === "string") {
            classes.push(rowClassName);
          } else if (typeof rowClassName === "function") {
            classes.push(rowClassName.call(null, {
              row,
              rowIndex
            }));
          }
          return classes;
        };
        const getCellStyle = (rowIndex, columnIndex, row, column) => {
          const cellStyle = parent == null ? void 0 : parent.props.cellStyle;
          let cellStyles = cellStyle != null ? cellStyle : {};
          if (typeof cellStyle === "function") {
            cellStyles = cellStyle.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            });
          }
          const fixedStyle = getFixedColumnOffset(columnIndex, props == null ? void 0 : props.fixed, props.store);
          ensurePosition(fixedStyle, "left");
          ensurePosition(fixedStyle, "right");
          return Object.assign({}, cellStyles, fixedStyle);
        };
        const getCellClass = (rowIndex, columnIndex, row, column, offset) => {
          const fixedClasses = getFixedColumnsClass(ns.b(), columnIndex, props == null ? void 0 : props.fixed, props.store, void 0, offset);
          const classes = [column.id, column.align, column.className, ...fixedClasses];
          const cellClassName = parent == null ? void 0 : parent.props.cellClassName;
          if (typeof cellClassName === "string") {
            classes.push(cellClassName);
          } else if (typeof cellClassName === "function") {
            classes.push(cellClassName.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            }));
          }
          classes.push(ns.e("cell"));
          return classes.filter((className) => Boolean(className)).join(" ");
        };
        const getSpan = (row, column, rowIndex, columnIndex) => {
          let rowspan = 1;
          let colspan = 1;
          const fn2 = parent == null ? void 0 : parent.props.spanMethod;
          if (typeof fn2 === "function") {
            const result = fn2({
              row,
              column,
              rowIndex,
              columnIndex
            });
            if (Array.isArray(result)) {
              rowspan = result[0];
              colspan = result[1];
            } else if (typeof result === "object") {
              rowspan = result.rowspan;
              colspan = result.colspan;
            }
          }
          return { rowspan, colspan };
        };
        const getColspanRealWidth = (columns, colspan, index) => {
          if (colspan < 1) {
            return columns[index].realWidth;
          }
          const widthArr = columns.map(({ realWidth, width }) => realWidth || width).slice(index, index + colspan);
          return Number(widthArr.reduce((acc, width) => Number(acc) + Number(width), -1));
        };
        return {
          getRowStyle,
          getRowClass,
          getCellStyle,
          getCellClass,
          getSpan,
          getColspanRealWidth
        };
      }
      function useRender$1(props) {
        const parent = inject(TABLE_INJECTION_KEY);
        const ns = useNamespace("table");
        const {
          handleDoubleClick,
          handleClick,
          handleContextMenu,
          handleMouseEnter,
          handleMouseLeave,
          handleCellMouseEnter,
          handleCellMouseLeave,
          tooltipContent,
          tooltipTrigger
        } = useEvents(props);
        const {
          getRowStyle,
          getRowClass,
          getCellStyle,
          getCellClass,
          getSpan,
          getColspanRealWidth
        } = useStyles(props);
        const firstDefaultColumnIndex = computed$1(() => {
          return props.store.states.columns.value.findIndex(({ type }) => type === "default");
        });
        const getKeyOfRow = (row, index) => {
          const rowKey = parent.props.rowKey;
          if (rowKey) {
            return getRowIdentity(row, rowKey);
          }
          return index;
        };
        const rowRender = (row, $index, treeRowData, expanded = false) => {
          const { tooltipEffect, tooltipOptions, store } = props;
          const { indent, columns } = store.states;
          const rowClasses = getRowClass(row, $index);
          let display = true;
          if (treeRowData) {
            rowClasses.push(ns.em("row", `level-${treeRowData.level}`));
            display = treeRowData.display;
          }
          const displayStyle = display ? null : {
            display: "none"
          };
          return h$1("tr", {
            style: [displayStyle, getRowStyle(row, $index)],
            class: rowClasses,
            key: getKeyOfRow(row, $index),
            onDblclick: ($event) => handleDoubleClick($event, row),
            onClick: ($event) => handleClick($event, row),
            onContextmenu: ($event) => handleContextMenu($event, row),
            onMouseenter: () => handleMouseEnter($index),
            onMouseleave: handleMouseLeave
          }, columns.value.map((column, cellIndex) => {
            const { rowspan, colspan } = getSpan(row, column, $index, cellIndex);
            if (!rowspan || !colspan) {
              return null;
            }
            const columnData = Object.assign({}, column);
            columnData.realWidth = getColspanRealWidth(columns.value, colspan, cellIndex);
            const data = {
              store: props.store,
              _self: props.context || parent,
              column: columnData,
              row,
              $index,
              cellIndex,
              expanded
            };
            if (cellIndex === firstDefaultColumnIndex.value && treeRowData) {
              data.treeNode = {
                indent: treeRowData.level * indent.value,
                level: treeRowData.level
              };
              if (typeof treeRowData.expanded === "boolean") {
                data.treeNode.expanded = treeRowData.expanded;
                if ("loading" in treeRowData) {
                  data.treeNode.loading = treeRowData.loading;
                }
                if ("noLazyChildren" in treeRowData) {
                  data.treeNode.noLazyChildren = treeRowData.noLazyChildren;
                }
              }
            }
            const baseKey = `${$index},${cellIndex}`;
            const patchKey = columnData.columnKey || columnData.rawColumnKey || "";
            const tdChildren = cellChildren(cellIndex, column, data);
            const mergedTooltipOptions = column.showOverflowTooltip && merge$1({
              effect: tooltipEffect
            }, tooltipOptions, column.showOverflowTooltip);
            return h$1("td", {
              style: getCellStyle($index, cellIndex, row, column),
              class: getCellClass($index, cellIndex, row, column, colspan - 1),
              key: `${patchKey}${baseKey}`,
              rowspan,
              colspan,
              onMouseenter: ($event) => handleCellMouseEnter($event, row, mergedTooltipOptions),
              onMouseleave: handleCellMouseLeave
            }, [tdChildren]);
          }));
        };
        const cellChildren = (cellIndex, column, data) => {
          return column.renderCell(data);
        };
        const wrappedRowRender = (row, $index) => {
          const store = props.store;
          const { isRowExpanded, assertRowKey } = store;
          const { treeData, lazyTreeNodeMap, childrenColumnName, rowKey } = store.states;
          const columns = store.states.columns.value;
          const hasExpandColumn = columns.some(({ type }) => type === "expand");
          if (hasExpandColumn) {
            const expanded = isRowExpanded(row);
            const tr = rowRender(row, $index, void 0, expanded);
            const renderExpanded = parent.renderExpanded;
            if (expanded) {
              if (!renderExpanded) {
                console.error("[Element Error]renderExpanded is required.");
                return tr;
              }
              return [
                [
                  tr,
                  h$1("tr", {
                    key: `expanded-row__${tr.key}`
                  }, [
                    h$1("td", {
                      colspan: columns.length,
                      class: `${ns.e("cell")} ${ns.e("expanded-cell")}`
                    }, [renderExpanded({ row, $index, store, expanded })])
                  ])
                ]
              ];
            } else {
              return [[tr]];
            }
          } else if (Object.keys(treeData.value).length) {
            assertRowKey();
            const key = getRowIdentity(row, rowKey.value);
            let cur = treeData.value[key];
            let treeRowData = null;
            if (cur) {
              treeRowData = {
                expanded: cur.expanded,
                level: cur.level,
                display: true
              };
              if (typeof cur.lazy === "boolean") {
                if (typeof cur.loaded === "boolean" && cur.loaded) {
                  treeRowData.noLazyChildren = !(cur.children && cur.children.length);
                }
                treeRowData.loading = cur.loading;
              }
            }
            const tmp = [rowRender(row, $index, treeRowData)];
            if (cur) {
              let i = 0;
              const traverse = (children, parent2) => {
                if (!(children && children.length && parent2))
                  return;
                children.forEach((node) => {
                  const innerTreeRowData = {
                    display: parent2.display && parent2.expanded,
                    level: parent2.level + 1,
                    expanded: false,
                    noLazyChildren: false,
                    loading: false
                  };
                  const childKey = getRowIdentity(node, rowKey.value);
                  if (childKey === void 0 || childKey === null) {
                    throw new Error("For nested data item, row-key is required.");
                  }
                  cur = { ...treeData.value[childKey] };
                  if (cur) {
                    innerTreeRowData.expanded = cur.expanded;
                    cur.level = cur.level || innerTreeRowData.level;
                    cur.display = !!(cur.expanded && innerTreeRowData.display);
                    if (typeof cur.lazy === "boolean") {
                      if (typeof cur.loaded === "boolean" && cur.loaded) {
                        innerTreeRowData.noLazyChildren = !(cur.children && cur.children.length);
                      }
                      innerTreeRowData.loading = cur.loading;
                    }
                  }
                  i++;
                  tmp.push(rowRender(node, $index + i, innerTreeRowData));
                  if (cur) {
                    const nodes2 = lazyTreeNodeMap.value[childKey] || node[childrenColumnName.value];
                    traverse(nodes2, cur);
                  }
                });
              };
              cur.display = true;
              const nodes = lazyTreeNodeMap.value[key] || row[childrenColumnName.value];
              traverse(nodes, cur);
            }
            return tmp;
          } else {
            return rowRender(row, $index, void 0);
          }
        };
        return {
          wrappedRowRender,
          tooltipContent,
          tooltipTrigger
        };
      }
      const defaultProps$2 = {
        store: {
          required: true,
          type: Object
        },
        stripe: Boolean,
        tooltipEffect: String,
        tooltipOptions: {
          type: Object
        },
        context: {
          default: () => ({}),
          type: Object
        },
        rowClassName: [String, Function],
        rowStyle: [Object, Function],
        fixed: {
          type: String,
          default: ""
        },
        highlight: Boolean
      };
      var TableBody = defineComponent({
        name: "ElTableBody",
        props: defaultProps$2,
        setup(props) {
          const instance = getCurrentInstance();
          const parent = inject(TABLE_INJECTION_KEY);
          const ns = useNamespace("table");
          const { wrappedRowRender, tooltipContent, tooltipTrigger } = useRender$1(props);
          const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent);
          const hoveredCellList = [];
          watch(props.store.states.hoverRow, (newVal, oldVal) => {
            var _a2;
            const el = instance == null ? void 0 : instance.vnode.el;
            const rows = Array.from((el == null ? void 0 : el.children) || []).filter((e) => e == null ? void 0 : e.classList.contains(`${ns.e("row")}`));
            let rowNum = newVal;
            const childNodes = (_a2 = rows[rowNum]) == null ? void 0 : _a2.childNodes;
            if (childNodes == null ? void 0 : childNodes.length) {
              let control = 0;
              const indexes = Array.from(childNodes).reduce((acc, item, index) => {
                var _a22, _b;
                if (((_a22 = childNodes[index]) == null ? void 0 : _a22.colSpan) > 1) {
                  control = (_b = childNodes[index]) == null ? void 0 : _b.colSpan;
                }
                if (item.nodeName !== "TD" && control === 0) {
                  acc.push(index);
                }
                control > 0 && control--;
                return acc;
              }, []);
              indexes.forEach((rowIndex) => {
                var _a22;
                while (rowNum > 0) {
                  const preChildNodes = (_a22 = rows[rowNum - 1]) == null ? void 0 : _a22.childNodes;
                  if (preChildNodes[rowIndex] && preChildNodes[rowIndex].nodeName === "TD" && preChildNodes[rowIndex].rowSpan > 1) {
                    addClass(preChildNodes[rowIndex], "hover-cell");
                    hoveredCellList.push(preChildNodes[rowIndex]);
                    break;
                  }
                  rowNum--;
                }
              });
            } else {
              hoveredCellList.forEach((item) => removeClass(item, "hover-cell"));
              hoveredCellList.length = 0;
            }
            if (!props.store.states.isComplex.value || !isClient)
              return;
            rAF(() => {
              const oldRow = rows[oldVal];
              const newRow = rows[newVal];
              if (oldRow && !oldRow.classList.contains("hover-fixed-row")) {
                removeClass(oldRow, "hover-row");
              }
              if (newRow) {
                addClass(newRow, "hover-row");
              }
            });
          });
          onUnmounted(() => {
            var _a2;
            (_a2 = removePopper) == null ? void 0 : _a2();
          });
          return {
            ns,
            onColumnsChange,
            onScrollableChange,
            wrappedRowRender,
            tooltipContent,
            tooltipTrigger
          };
        },
        render() {
          const { wrappedRowRender, store } = this;
          const data = store.states.data.value || [];
          return h$1("tbody", { tabIndex: -1 }, [
            data.reduce((acc, row) => {
              return acc.concat(wrappedRowRender(row, acc.length));
            }, [])
          ]);
        }
      });
      function useMapState() {
        const table = inject(TABLE_INJECTION_KEY);
        const store = table == null ? void 0 : table.store;
        const leftFixedLeafCount = computed$1(() => {
          return store.states.fixedLeafColumnsLength.value;
        });
        const rightFixedLeafCount = computed$1(() => {
          return store.states.rightFixedColumns.value.length;
        });
        const columnsCount = computed$1(() => {
          return store.states.columns.value.length;
        });
        const leftFixedCount = computed$1(() => {
          return store.states.fixedColumns.value.length;
        });
        const rightFixedCount = computed$1(() => {
          return store.states.rightFixedColumns.value.length;
        });
        return {
          leftFixedLeafCount,
          rightFixedLeafCount,
          columnsCount,
          leftFixedCount,
          rightFixedCount,
          columns: store.states.columns
        };
      }
      function useStyle$1(props) {
        const { columns } = useMapState();
        const ns = useNamespace("table");
        const getCellClasses = (columns2, cellIndex) => {
          const column = columns2[cellIndex];
          const classes = [
            ns.e("cell"),
            column.id,
            column.align,
            column.labelClassName,
            ...getFixedColumnsClass(ns.b(), cellIndex, column.fixed, props.store)
          ];
          if (column.className) {
            classes.push(column.className);
          }
          if (!column.children) {
            classes.push(ns.is("leaf"));
          }
          return classes;
        };
        const getCellStyles = (column, cellIndex) => {
          const fixedStyle = getFixedColumnOffset(cellIndex, column.fixed, props.store);
          ensurePosition(fixedStyle, "left");
          ensurePosition(fixedStyle, "right");
          return fixedStyle;
        };
        return {
          getCellClasses,
          getCellStyles,
          columns
        };
      }
      var TableFooter = defineComponent({
        name: "ElTableFooter",
        props: {
          fixed: {
            type: String,
            default: ""
          },
          store: {
            required: true,
            type: Object
          },
          summaryMethod: Function,
          sumText: String,
          border: Boolean,
          defaultSort: {
            type: Object,
            default: () => {
              return {
                prop: "",
                order: ""
              };
            }
          }
        },
        setup(props) {
          const { getCellClasses, getCellStyles, columns } = useStyle$1(props);
          const ns = useNamespace("table");
          return {
            ns,
            getCellClasses,
            getCellStyles,
            columns
          };
        },
        render() {
          const { columns, getCellStyles, getCellClasses, summaryMethod, sumText } = this;
          const data = this.store.states.data.value;
          let sums = [];
          if (summaryMethod) {
            sums = summaryMethod({
              columns,
              data
            });
          } else {
            columns.forEach((column, index) => {
              if (index === 0) {
                sums[index] = sumText;
                return;
              }
              const values = data.map((item) => Number(item[column.property]));
              const precisions = [];
              let notNumber = true;
              values.forEach((value) => {
                if (!Number.isNaN(+value)) {
                  notNumber = false;
                  const decimal = `${value}`.split(".")[1];
                  precisions.push(decimal ? decimal.length : 0);
                }
              });
              const precision = Math.max.apply(null, precisions);
              if (!notNumber) {
                sums[index] = values.reduce((prev, curr) => {
                  const value = Number(curr);
                  if (!Number.isNaN(+value)) {
                    return Number.parseFloat((prev + curr).toFixed(Math.min(precision, 20)));
                  } else {
                    return prev;
                  }
                }, 0);
              } else {
                sums[index] = "";
              }
            });
          }
          return h$1(h$1("tfoot", [
            h$1("tr", {}, [
              ...columns.map((column, cellIndex) => h$1("td", {
                key: cellIndex,
                colspan: column.colSpan,
                rowspan: column.rowSpan,
                class: getCellClasses(columns, cellIndex),
                style: getCellStyles(column, cellIndex)
              }, [
                h$1("div", {
                  class: ["cell", column.labelClassName]
                }, [sums[cellIndex]])
              ]))
            ])
          ]));
        }
      });
      function useUtils(store) {
        const setCurrentRow = (row) => {
          store.commit("setCurrentRow", row);
        };
        const getSelectionRows = () => {
          return store.getSelectionRows();
        };
        const toggleRowSelection = (row, selected) => {
          store.toggleRowSelection(row, selected, false);
          store.updateAllSelected();
        };
        const clearSelection = () => {
          store.clearSelection();
        };
        const clearFilter = (columnKeys) => {
          store.clearFilter(columnKeys);
        };
        const toggleAllSelection = () => {
          store.commit("toggleAllSelection");
        };
        const toggleRowExpansion = (row, expanded) => {
          store.toggleRowExpansionAdapter(row, expanded);
        };
        const clearSort = () => {
          store.clearSort();
        };
        const sort = (prop, order) => {
          store.commit("sort", { prop, order });
        };
        return {
          setCurrentRow,
          getSelectionRows,
          toggleRowSelection,
          clearSelection,
          clearFilter,
          toggleAllSelection,
          toggleRowExpansion,
          clearSort,
          sort
        };
      }
      function useStyle(props, layout, store, table) {
        const isHidden2 = ref(false);
        const renderExpanded = ref(null);
        const resizeProxyVisible = ref(false);
        const setDragVisible = (visible) => {
          resizeProxyVisible.value = visible;
        };
        const resizeState = ref({
          width: null,
          height: null,
          headerHeight: null
        });
        const isGroup = ref(false);
        const scrollbarViewStyle = {
          display: "inline-block",
          verticalAlign: "middle"
        };
        const tableWidth = ref();
        const tableScrollHeight = ref(0);
        const bodyScrollHeight = ref(0);
        const headerScrollHeight = ref(0);
        const footerScrollHeight = ref(0);
        const appendScrollHeight = ref(0);
        watchEffect(() => {
          layout.setHeight(props.height);
        });
        watchEffect(() => {
          layout.setMaxHeight(props.maxHeight);
        });
        watch(() => [props.currentRowKey, store.states.rowKey], ([currentRowKey, rowKey]) => {
          if (!unref(rowKey) || !unref(currentRowKey))
            return;
          store.setCurrentRowKey(`${currentRowKey}`);
        }, {
          immediate: true
        });
        watch(() => props.data, (data) => {
          table.store.commit("setData", data);
        }, {
          immediate: true,
          deep: true
        });
        watchEffect(() => {
          if (props.expandRowKeys) {
            store.setExpandRowKeysAdapter(props.expandRowKeys);
          }
        });
        const handleMouseLeave = () => {
          table.store.commit("setHoverRow", null);
          if (table.hoverState)
            table.hoverState = null;
        };
        const handleHeaderFooterMousewheel = (event, data) => {
          const { pixelX, pixelY } = data;
          if (Math.abs(pixelX) >= Math.abs(pixelY)) {
            table.refs.bodyWrapper.scrollLeft += data.pixelX / 5;
          }
        };
        const shouldUpdateHeight = computed$1(() => {
          return props.height || props.maxHeight || store.states.fixedColumns.value.length > 0 || store.states.rightFixedColumns.value.length > 0;
        });
        const tableBodyStyles = computed$1(() => {
          return {
            width: layout.bodyWidth.value ? `${layout.bodyWidth.value}px` : ""
          };
        });
        const doLayout = () => {
          if (shouldUpdateHeight.value) {
            layout.updateElsHeight();
          }
          layout.updateColumnsWidth();
          requestAnimationFrame(syncPosition);
        };
        onMounted(async () => {
          await nextTick();
          store.updateColumns();
          bindEvents();
          requestAnimationFrame(doLayout);
          const el = table.vnode.el;
          const tableHeader = table.refs.headerWrapper;
          if (props.flexible && el && el.parentElement) {
            el.parentElement.style.minWidth = "0";
          }
          resizeState.value = {
            width: tableWidth.value = el.offsetWidth,
            height: el.offsetHeight,
            headerHeight: props.showHeader && tableHeader ? tableHeader.offsetHeight : null
          };
          store.states.columns.value.forEach((column) => {
            if (column.filteredValue && column.filteredValue.length) {
              table.store.commit("filterChange", {
                column,
                values: column.filteredValue,
                silent: true
              });
            }
          });
          table.$ready = true;
        });
        const setScrollClassByEl = (el, className) => {
          if (!el)
            return;
          const classList = Array.from(el.classList).filter((item) => !item.startsWith("is-scrolling-"));
          classList.push(layout.scrollX.value ? className : "is-scrolling-none");
          el.className = classList.join(" ");
        };
        const setScrollClass = (className) => {
          const { tableWrapper } = table.refs;
          setScrollClassByEl(tableWrapper, className);
        };
        const hasScrollClass = (className) => {
          const { tableWrapper } = table.refs;
          return !!(tableWrapper && tableWrapper.classList.contains(className));
        };
        const syncPosition = function() {
          if (!table.refs.scrollBarRef)
            return;
          if (!layout.scrollX.value) {
            const scrollingNoneClass = "is-scrolling-none";
            if (!hasScrollClass(scrollingNoneClass)) {
              setScrollClass(scrollingNoneClass);
            }
            return;
          }
          const scrollContainer = table.refs.scrollBarRef.wrapRef;
          if (!scrollContainer)
            return;
          const { scrollLeft, offsetWidth, scrollWidth } = scrollContainer;
          const { headerWrapper, footerWrapper } = table.refs;
          if (headerWrapper)
            headerWrapper.scrollLeft = scrollLeft;
          if (footerWrapper)
            footerWrapper.scrollLeft = scrollLeft;
          const maxScrollLeftPosition = scrollWidth - offsetWidth - 1;
          if (scrollLeft >= maxScrollLeftPosition) {
            setScrollClass("is-scrolling-right");
          } else if (scrollLeft === 0) {
            setScrollClass("is-scrolling-left");
          } else {
            setScrollClass("is-scrolling-middle");
          }
        };
        const bindEvents = () => {
          if (!table.refs.scrollBarRef)
            return;
          if (table.refs.scrollBarRef.wrapRef) {
            useEventListener(table.refs.scrollBarRef.wrapRef, "scroll", syncPosition, {
              passive: true
            });
          }
          if (props.fit) {
            useResizeObserver(table.vnode.el, resizeListener);
          } else {
            useEventListener(window, "resize", resizeListener);
          }
          useResizeObserver(table.refs.bodyWrapper, () => {
            var _a2, _b;
            resizeListener();
            (_b = (_a2 = table.refs) == null ? void 0 : _a2.scrollBarRef) == null ? void 0 : _b.update();
          });
        };
        const resizeListener = () => {
          var _a2, _b, _c, _d;
          const el = table.vnode.el;
          if (!table.$ready || !el)
            return;
          let shouldUpdateLayout = false;
          const {
            width: oldWidth,
            height: oldHeight,
            headerHeight: oldHeaderHeight
          } = resizeState.value;
          const width = tableWidth.value = el.offsetWidth;
          if (oldWidth !== width) {
            shouldUpdateLayout = true;
          }
          const height = el.offsetHeight;
          if ((props.height || shouldUpdateHeight.value) && oldHeight !== height) {
            shouldUpdateLayout = true;
          }
          const tableHeader = props.tableLayout === "fixed" ? table.refs.headerWrapper : (_a2 = table.refs.tableHeaderRef) == null ? void 0 : _a2.$el;
          if (props.showHeader && (tableHeader == null ? void 0 : tableHeader.offsetHeight) !== oldHeaderHeight) {
            shouldUpdateLayout = true;
          }
          tableScrollHeight.value = ((_b = table.refs.tableWrapper) == null ? void 0 : _b.scrollHeight) || 0;
          headerScrollHeight.value = (tableHeader == null ? void 0 : tableHeader.scrollHeight) || 0;
          footerScrollHeight.value = ((_c = table.refs.footerWrapper) == null ? void 0 : _c.offsetHeight) || 0;
          appendScrollHeight.value = ((_d = table.refs.appendWrapper) == null ? void 0 : _d.offsetHeight) || 0;
          bodyScrollHeight.value = tableScrollHeight.value - headerScrollHeight.value - footerScrollHeight.value - appendScrollHeight.value;
          if (shouldUpdateLayout) {
            resizeState.value = {
              width,
              height,
              headerHeight: props.showHeader && (tableHeader == null ? void 0 : tableHeader.offsetHeight) || 0
            };
            doLayout();
          }
        };
        const tableSize = useFormSize();
        const bodyWidth = computed$1(() => {
          const { bodyWidth: bodyWidth_, scrollY, gutterWidth } = layout;
          return bodyWidth_.value ? `${bodyWidth_.value - (scrollY.value ? gutterWidth : 0)}px` : "";
        });
        const tableLayout = computed$1(() => {
          if (props.maxHeight)
            return "fixed";
          return props.tableLayout;
        });
        const emptyBlockStyle = computed$1(() => {
          if (props.data && props.data.length)
            return null;
          let height = "100%";
          if (props.height && bodyScrollHeight.value) {
            height = `${bodyScrollHeight.value}px`;
          }
          const width = tableWidth.value;
          return {
            width: width ? `${width}px` : "",
            height
          };
        });
        const tableInnerStyle = computed$1(() => {
          if (props.height) {
            return {
              height: !Number.isNaN(Number(props.height)) ? `${props.height}px` : props.height
            };
          }
          if (props.maxHeight) {
            return {
              maxHeight: !Number.isNaN(Number(props.maxHeight)) ? `${props.maxHeight}px` : props.maxHeight
            };
          }
          return {};
        });
        const scrollbarStyle = computed$1(() => {
          if (props.height) {
            return {
              height: "100%"
            };
          }
          if (props.maxHeight) {
            if (!Number.isNaN(Number(props.maxHeight))) {
              return {
                maxHeight: `${props.maxHeight - headerScrollHeight.value - footerScrollHeight.value}px`
              };
            } else {
              return {
                maxHeight: `calc(${props.maxHeight} - ${headerScrollHeight.value + footerScrollHeight.value}px)`
              };
            }
          }
          return {};
        });
        const handleFixedMousewheel = (event, data) => {
          const bodyWrapper = table.refs.bodyWrapper;
          if (Math.abs(data.spinY) > 0) {
            const currentScrollTop = bodyWrapper.scrollTop;
            if (data.pixelY < 0 && currentScrollTop !== 0) {
              event.preventDefault();
            }
            if (data.pixelY > 0 && bodyWrapper.scrollHeight - bodyWrapper.clientHeight > currentScrollTop) {
              event.preventDefault();
            }
            bodyWrapper.scrollTop += Math.ceil(data.pixelY / 5);
          } else {
            bodyWrapper.scrollLeft += Math.ceil(data.pixelX / 5);
          }
        };
        return {
          isHidden: isHidden2,
          renderExpanded,
          setDragVisible,
          isGroup,
          handleMouseLeave,
          handleHeaderFooterMousewheel,
          tableSize,
          emptyBlockStyle,
          handleFixedMousewheel,
          resizeProxyVisible,
          bodyWidth,
          resizeState,
          doLayout,
          tableBodyStyles,
          tableLayout,
          scrollbarViewStyle,
          tableInnerStyle,
          scrollbarStyle
        };
      }
      function useKeyRender(table) {
        const observer = ref();
        const initWatchDom = () => {
          const el = table.vnode.el;
          const columnsWrapper = el.querySelector(".hidden-columns");
          const config = { childList: true, subtree: true };
          const updateOrderFns = table.store.states.updateOrderFns;
          observer.value = new MutationObserver(() => {
            updateOrderFns.forEach((fn2) => fn2());
          });
          observer.value.observe(columnsWrapper, config);
        };
        onMounted(() => {
          initWatchDom();
        });
        onUnmounted(() => {
          var _a2;
          (_a2 = observer.value) == null ? void 0 : _a2.disconnect();
        });
      }
      var defaultProps$1 = {
        data: {
          type: Array,
          default: () => []
        },
        size: useSizeProp,
        width: [String, Number],
        height: [String, Number],
        maxHeight: [String, Number],
        fit: {
          type: Boolean,
          default: true
        },
        stripe: Boolean,
        border: Boolean,
        rowKey: [String, Function],
        showHeader: {
          type: Boolean,
          default: true
        },
        showSummary: Boolean,
        sumText: String,
        summaryMethod: Function,
        rowClassName: [String, Function],
        rowStyle: [Object, Function],
        cellClassName: [String, Function],
        cellStyle: [Object, Function],
        headerRowClassName: [String, Function],
        headerRowStyle: [Object, Function],
        headerCellClassName: [String, Function],
        headerCellStyle: [Object, Function],
        highlightCurrentRow: Boolean,
        currentRowKey: [String, Number],
        emptyText: String,
        expandRowKeys: Array,
        defaultExpandAll: Boolean,
        defaultSort: Object,
        tooltipEffect: String,
        tooltipOptions: Object,
        spanMethod: Function,
        selectOnIndeterminate: {
          type: Boolean,
          default: true
        },
        indent: {
          type: Number,
          default: 16
        },
        treeProps: {
          type: Object,
          default: () => {
            return {
              hasChildren: "hasChildren",
              children: "children"
            };
          }
        },
        lazy: Boolean,
        load: Function,
        style: {
          type: Object,
          default: () => ({})
        },
        className: {
          type: String,
          default: ""
        },
        tableLayout: {
          type: String,
          default: "fixed"
        },
        scrollbarAlwaysOn: Boolean,
        flexible: Boolean,
        showOverflowTooltip: [Boolean, Object]
      };
      function hColgroup(props) {
        const isAuto = props.tableLayout === "auto";
        let columns = props.columns || [];
        if (isAuto) {
          if (columns.every((column) => column.width === void 0)) {
            columns = [];
          }
        }
        const getPropsData = (column) => {
          const propsData = {
            key: `${props.tableLayout}_${column.id}`,
            style: {},
            name: void 0
          };
          if (isAuto) {
            propsData.style = {
              width: `${column.width}px`
            };
          } else {
            propsData.name = column.id;
          }
          return propsData;
        };
        return h$1("colgroup", {}, columns.map((column) => h$1("col", getPropsData(column))));
      }
      hColgroup.props = ["columns", "tableLayout"];
      const useScrollbar = () => {
        const scrollBarRef = ref();
        const scrollTo = (options, yCoord) => {
          const scrollbar = scrollBarRef.value;
          if (scrollbar) {
            scrollbar.scrollTo(options, yCoord);
          }
        };
        const setScrollPosition = (position, offset) => {
          const scrollbar = scrollBarRef.value;
          if (scrollbar && isNumber(offset) && ["Top", "Left"].includes(position)) {
            scrollbar[`setScroll${position}`](offset);
          }
        };
        const setScrollTop = (top) => setScrollPosition("Top", top);
        const setScrollLeft = (left) => setScrollPosition("Left", left);
        return {
          scrollBarRef,
          scrollTo,
          setScrollTop,
          setScrollLeft
        };
      };
      let tableIdSeed = 1;
      const _sfc_main$7 = defineComponent({
        name: "ElTable",
        directives: {
          Mousewheel
        },
        components: {
          TableHeader,
          TableBody,
          TableFooter,
          ElScrollbar,
          hColgroup
        },
        props: defaultProps$1,
        emits: [
          "select",
          "select-all",
          "selection-change",
          "cell-mouse-enter",
          "cell-mouse-leave",
          "cell-contextmenu",
          "cell-click",
          "cell-dblclick",
          "row-click",
          "row-contextmenu",
          "row-dblclick",
          "header-click",
          "header-contextmenu",
          "sort-change",
          "filter-change",
          "current-change",
          "header-dragend",
          "expand-change"
        ],
        setup(props) {
          const { t } = useLocale();
          const ns = useNamespace("table");
          const table = getCurrentInstance();
          provide(TABLE_INJECTION_KEY, table);
          const store = createStore(table, props);
          table.store = store;
          const layout = new TableLayout({
            store: table.store,
            table,
            fit: props.fit,
            showHeader: props.showHeader
          });
          table.layout = layout;
          const isEmpty2 = computed$1(() => (store.states.data.value || []).length === 0);
          const {
            setCurrentRow,
            getSelectionRows,
            toggleRowSelection,
            clearSelection,
            clearFilter,
            toggleAllSelection,
            toggleRowExpansion,
            clearSort,
            sort
          } = useUtils(store);
          const {
            isHidden: isHidden2,
            renderExpanded,
            setDragVisible,
            isGroup,
            handleMouseLeave,
            handleHeaderFooterMousewheel,
            tableSize,
            emptyBlockStyle,
            handleFixedMousewheel,
            resizeProxyVisible,
            bodyWidth,
            resizeState,
            doLayout,
            tableBodyStyles,
            tableLayout,
            scrollbarViewStyle,
            tableInnerStyle,
            scrollbarStyle
          } = useStyle(props, layout, store, table);
          const { scrollBarRef, scrollTo, setScrollLeft, setScrollTop } = useScrollbar();
          const debouncedUpdateLayout = debounce(doLayout, 50);
          const tableId = `${ns.namespace.value}-table_${tableIdSeed++}`;
          table.tableId = tableId;
          table.state = {
            isGroup,
            resizeState,
            doLayout,
            debouncedUpdateLayout
          };
          const computedSumText = computed$1(() => props.sumText || t("el.table.sumText"));
          const computedEmptyText = computed$1(() => {
            return props.emptyText || t("el.table.emptyText");
          });
          useKeyRender(table);
          return {
            ns,
            layout,
            store,
            handleHeaderFooterMousewheel,
            handleMouseLeave,
            tableId,
            tableSize,
            isHidden: isHidden2,
            isEmpty: isEmpty2,
            renderExpanded,
            resizeProxyVisible,
            resizeState,
            isGroup,
            bodyWidth,
            tableBodyStyles,
            emptyBlockStyle,
            debouncedUpdateLayout,
            handleFixedMousewheel,
            setCurrentRow,
            getSelectionRows,
            toggleRowSelection,
            clearSelection,
            clearFilter,
            toggleAllSelection,
            toggleRowExpansion,
            clearSort,
            doLayout,
            sort,
            t,
            setDragVisible,
            context: table,
            computedSumText,
            computedEmptyText,
            tableLayout,
            scrollbarViewStyle,
            tableInnerStyle,
            scrollbarStyle,
            scrollBarRef,
            scrollTo,
            setScrollLeft,
            setScrollTop
          };
        }
      });
      const _hoisted_1$5 = ["data-prefix"];
      const _hoisted_2$5 = {
        ref: "hiddenColumns",
        class: "hidden-columns"
      };
      function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_hColgroup = resolveComponent("hColgroup");
        const _component_table_header = resolveComponent("table-header");
        const _component_table_body = resolveComponent("table-body");
        const _component_table_footer = resolveComponent("table-footer");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _directive_mousewheel = resolveDirective("mousewheel");
        return openBlock(), createElementBlock("div", {
          ref: "tableWrapper",
          class: normalizeClass([
            {
              [_ctx.ns.m("fit")]: _ctx.fit,
              [_ctx.ns.m("striped")]: _ctx.stripe,
              [_ctx.ns.m("border")]: _ctx.border || _ctx.isGroup,
              [_ctx.ns.m("hidden")]: _ctx.isHidden,
              [_ctx.ns.m("group")]: _ctx.isGroup,
              [_ctx.ns.m("fluid-height")]: _ctx.maxHeight,
              [_ctx.ns.m("scrollable-x")]: _ctx.layout.scrollX.value,
              [_ctx.ns.m("scrollable-y")]: _ctx.layout.scrollY.value,
              [_ctx.ns.m("enable-row-hover")]: !_ctx.store.states.isComplex.value,
              [_ctx.ns.m("enable-row-transition")]: (_ctx.store.states.data.value || []).length !== 0 && (_ctx.store.states.data.value || []).length < 100,
              "has-footer": _ctx.showSummary
            },
            _ctx.ns.m(_ctx.tableSize),
            _ctx.className,
            _ctx.ns.b(),
            _ctx.ns.m(`layout-${_ctx.tableLayout}`)
          ]),
          style: normalizeStyle(_ctx.style),
          "data-prefix": _ctx.ns.namespace.value,
          onMouseleave: _cache[0] || (_cache[0] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args))
        }, [
          createElementVNode("div", {
            class: normalizeClass(_ctx.ns.e("inner-wrapper")),
            style: normalizeStyle(_ctx.tableInnerStyle)
          }, [
            createElementVNode("div", _hoisted_2$5, [
              renderSlot(_ctx.$slots, "default")
            ], 512),
            _ctx.showHeader && _ctx.tableLayout === "fixed" ? withDirectives((openBlock(), createElementBlock("div", {
              key: 0,
              ref: "headerWrapper",
              class: normalizeClass(_ctx.ns.e("header-wrapper"))
            }, [
              createElementVNode("table", {
                ref: "tableHeader",
                class: normalizeClass(_ctx.ns.e("header")),
                style: normalizeStyle(_ctx.tableBodyStyles),
                border: "0",
                cellpadding: "0",
                cellspacing: "0"
              }, [
                createVNode(_component_hColgroup, {
                  columns: _ctx.store.states.columns.value,
                  "table-layout": _ctx.tableLayout
                }, null, 8, ["columns", "table-layout"]),
                createVNode(_component_table_header, {
                  ref: "tableHeaderRef",
                  border: _ctx.border,
                  "default-sort": _ctx.defaultSort,
                  store: _ctx.store,
                  onSetDragVisible: _ctx.setDragVisible
                }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])
              ], 6)
            ], 2)), [
              [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
            ]) : createCommentVNode("v-if", true),
            createElementVNode("div", {
              ref: "bodyWrapper",
              class: normalizeClass(_ctx.ns.e("body-wrapper"))
            }, [
              createVNode(_component_el_scrollbar, {
                ref: "scrollBarRef",
                "view-style": _ctx.scrollbarViewStyle,
                "wrap-style": _ctx.scrollbarStyle,
                always: _ctx.scrollbarAlwaysOn
              }, {
                default: withCtx(() => [
                  createElementVNode("table", {
                    ref: "tableBody",
                    class: normalizeClass(_ctx.ns.e("body")),
                    cellspacing: "0",
                    cellpadding: "0",
                    border: "0",
                    style: normalizeStyle({
                      width: _ctx.bodyWidth,
                      tableLayout: _ctx.tableLayout
                    })
                  }, [
                    createVNode(_component_hColgroup, {
                      columns: _ctx.store.states.columns.value,
                      "table-layout": _ctx.tableLayout
                    }, null, 8, ["columns", "table-layout"]),
                    _ctx.showHeader && _ctx.tableLayout === "auto" ? (openBlock(), createBlock(_component_table_header, {
                      key: 0,
                      ref: "tableHeaderRef",
                      class: normalizeClass(_ctx.ns.e("body-header")),
                      border: _ctx.border,
                      "default-sort": _ctx.defaultSort,
                      store: _ctx.store,
                      onSetDragVisible: _ctx.setDragVisible
                    }, null, 8, ["class", "border", "default-sort", "store", "onSetDragVisible"])) : createCommentVNode("v-if", true),
                    createVNode(_component_table_body, {
                      context: _ctx.context,
                      highlight: _ctx.highlightCurrentRow,
                      "row-class-name": _ctx.rowClassName,
                      "tooltip-effect": _ctx.tooltipEffect,
                      "tooltip-options": _ctx.tooltipOptions,
                      "row-style": _ctx.rowStyle,
                      store: _ctx.store,
                      stripe: _ctx.stripe
                    }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "tooltip-options", "row-style", "store", "stripe"]),
                    _ctx.showSummary && _ctx.tableLayout === "auto" ? (openBlock(), createBlock(_component_table_footer, {
                      key: 1,
                      class: normalizeClass(_ctx.ns.e("body-footer")),
                      border: _ctx.border,
                      "default-sort": _ctx.defaultSort,
                      store: _ctx.store,
                      "sum-text": _ctx.computedSumText,
                      "summary-method": _ctx.summaryMethod
                    }, null, 8, ["class", "border", "default-sort", "store", "sum-text", "summary-method"])) : createCommentVNode("v-if", true)
                  ], 6),
                  _ctx.isEmpty ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    ref: "emptyBlock",
                    style: normalizeStyle(_ctx.emptyBlockStyle),
                    class: normalizeClass(_ctx.ns.e("empty-block"))
                  }, [
                    createElementVNode("span", {
                      class: normalizeClass(_ctx.ns.e("empty-text"))
                    }, [
                      renderSlot(_ctx.$slots, "empty", {}, () => [
                        createTextVNode(toDisplayString(_ctx.computedEmptyText), 1)
                      ])
                    ], 2)
                  ], 6)) : createCommentVNode("v-if", true),
                  _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    ref: "appendWrapper",
                    class: normalizeClass(_ctx.ns.e("append-wrapper"))
                  }, [
                    renderSlot(_ctx.$slots, "append")
                  ], 2)) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["view-style", "wrap-style", "always"])
            ], 2),
            _ctx.showSummary && _ctx.tableLayout === "fixed" ? withDirectives((openBlock(), createElementBlock("div", {
              key: 1,
              ref: "footerWrapper",
              class: normalizeClass(_ctx.ns.e("footer-wrapper"))
            }, [
              createElementVNode("table", {
                class: normalizeClass(_ctx.ns.e("footer")),
                cellspacing: "0",
                cellpadding: "0",
                border: "0",
                style: normalizeStyle(_ctx.tableBodyStyles)
              }, [
                createVNode(_component_hColgroup, {
                  columns: _ctx.store.states.columns.value,
                  "table-layout": _ctx.tableLayout
                }, null, 8, ["columns", "table-layout"]),
                createVNode(_component_table_footer, {
                  border: _ctx.border,
                  "default-sort": _ctx.defaultSort,
                  store: _ctx.store,
                  "sum-text": _ctx.computedSumText,
                  "summary-method": _ctx.summaryMethod
                }, null, 8, ["border", "default-sort", "store", "sum-text", "summary-method"])
              ], 6)
            ], 2)), [
              [vShow, !_ctx.isEmpty],
              [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
            ]) : createCommentVNode("v-if", true),
            _ctx.border || _ctx.isGroup ? (openBlock(), createElementBlock("div", {
              key: 2,
              class: normalizeClass(_ctx.ns.e("border-left-patch"))
            }, null, 2)) : createCommentVNode("v-if", true)
          ], 6),
          withDirectives(createElementVNode("div", {
            ref: "resizeProxy",
            class: normalizeClass(_ctx.ns.e("column-resize-proxy"))
          }, null, 2), [
            [vShow, _ctx.resizeProxyVisible]
          ])
        ], 46, _hoisted_1$5);
      }
      var Table = /* @__PURE__ */ _export_sfc$1(_sfc_main$7, [["render", _sfc_render$4], ["__file", "table.vue"]]);
      const defaultClassNames = {
        selection: "table-column--selection",
        expand: "table__expand-column"
      };
      const cellStarts = {
        default: {
          order: ""
        },
        selection: {
          width: 48,
          minWidth: 48,
          realWidth: 48,
          order: ""
        },
        expand: {
          width: 48,
          minWidth: 48,
          realWidth: 48,
          order: ""
        },
        index: {
          width: 48,
          minWidth: 48,
          realWidth: 48,
          order: ""
        }
      };
      const getDefaultClassName = (type) => {
        return defaultClassNames[type] || "";
      };
      const cellForced = {
        selection: {
          renderHeader({ store, column }) {
            function isDisabled() {
              return store.states.data.value && store.states.data.value.length === 0;
            }
            return h$1(ElCheckbox, {
              disabled: isDisabled(),
              size: store.states.tableSize.value,
              indeterminate: store.states.selection.value.length > 0 && !store.states.isAllSelected.value,
              "onUpdate:modelValue": store.toggleAllSelection,
              modelValue: store.states.isAllSelected.value,
              ariaLabel: column.label
            });
          },
          renderCell({
            row,
            column,
            store,
            $index
          }) {
            return h$1(ElCheckbox, {
              disabled: column.selectable ? !column.selectable.call(null, row, $index) : false,
              size: store.states.tableSize.value,
              onChange: () => {
                store.commit("rowSelectedChanged", row);
              },
              onClick: (event) => event.stopPropagation(),
              modelValue: store.isSelected(row),
              ariaLabel: column.label
            });
          },
          sortable: false,
          resizable: false
        },
        index: {
          renderHeader({ column }) {
            return column.label || "#";
          },
          renderCell({
            column,
            $index
          }) {
            let i = $index + 1;
            const index = column.index;
            if (typeof index === "number") {
              i = $index + index;
            } else if (typeof index === "function") {
              i = index($index);
            }
            return h$1("div", {}, [i]);
          },
          sortable: false
        },
        expand: {
          renderHeader({ column }) {
            return column.label || "";
          },
          renderCell({
            row,
            store,
            expanded
          }) {
            const { ns } = store;
            const classes = [ns.e("expand-icon")];
            if (expanded) {
              classes.push(ns.em("expand-icon", "expanded"));
            }
            const callback = function(e) {
              e.stopPropagation();
              store.toggleRowExpansion(row);
            };
            return h$1("div", {
              class: classes,
              onClick: callback
            }, {
              default: () => {
                return [
                  h$1(ElIcon, null, {
                    default: () => {
                      return [h$1(arrow_right_default)];
                    }
                  })
                ];
              }
            });
          },
          sortable: false,
          resizable: false
        }
      };
      function defaultRenderCell({
        row,
        column,
        $index
      }) {
        var _a2;
        const property2 = column.property;
        const value = property2 && getProp(row, property2).value;
        if (column && column.formatter) {
          return column.formatter(row, column, value, $index);
        }
        return ((_a2 = value == null ? void 0 : value.toString) == null ? void 0 : _a2.call(value)) || "";
      }
      function treeCellPrefix({
        row,
        treeNode,
        store
      }, createPlaceholder = false) {
        const { ns } = store;
        if (!treeNode) {
          if (createPlaceholder) {
            return [
              h$1("span", {
                class: ns.e("placeholder")
              })
            ];
          }
          return null;
        }
        const ele = [];
        const callback = function(e) {
          e.stopPropagation();
          if (treeNode.loading) {
            return;
          }
          store.loadOrToggle(row);
        };
        if (treeNode.indent) {
          ele.push(h$1("span", {
            class: ns.e("indent"),
            style: { "padding-left": `${treeNode.indent}px` }
          }));
        }
        if (typeof treeNode.expanded === "boolean" && !treeNode.noLazyChildren) {
          const expandClasses = [
            ns.e("expand-icon"),
            treeNode.expanded ? ns.em("expand-icon", "expanded") : ""
          ];
          let icon = arrow_right_default;
          if (treeNode.loading) {
            icon = loading_default;
          }
          ele.push(h$1("div", {
            class: expandClasses,
            onClick: callback
          }, {
            default: () => {
              return [
                h$1(ElIcon, { class: { [ns.is("loading")]: treeNode.loading } }, {
                  default: () => [h$1(icon)]
                })
              ];
            }
          }));
        } else {
          ele.push(h$1("span", {
            class: ns.e("placeholder")
          }));
        }
        return ele;
      }
      function getAllAliases(props, aliases) {
        return props.reduce((prev, cur) => {
          prev[cur] = cur;
          return prev;
        }, aliases);
      }
      function useWatcher(owner, props_) {
        const instance = getCurrentInstance();
        const registerComplexWatchers = () => {
          const props = ["fixed"];
          const aliases = {
            realWidth: "width",
            realMinWidth: "minWidth"
          };
          const allAliases = getAllAliases(props, aliases);
          Object.keys(allAliases).forEach((key) => {
            const columnKey = aliases[key];
            if (hasOwn(props_, columnKey)) {
              watch(() => props_[columnKey], (newVal) => {
                let value = newVal;
                if (columnKey === "width" && key === "realWidth") {
                  value = parseWidth(newVal);
                }
                if (columnKey === "minWidth" && key === "realMinWidth") {
                  value = parseMinWidth(newVal);
                }
                instance.columnConfig.value[columnKey] = value;
                instance.columnConfig.value[key] = value;
                const updateColumns = columnKey === "fixed";
                owner.value.store.scheduleLayout(updateColumns);
              });
            }
          });
        };
        const registerNormalWatchers = () => {
          const props = [
            "label",
            "filters",
            "filterMultiple",
            "filteredValue",
            "sortable",
            "index",
            "formatter",
            "className",
            "labelClassName",
            "filterClassName",
            "showOverflowTooltip"
          ];
          const aliases = {
            property: "prop",
            align: "realAlign",
            headerAlign: "realHeaderAlign"
          };
          const allAliases = getAllAliases(props, aliases);
          Object.keys(allAliases).forEach((key) => {
            const columnKey = aliases[key];
            if (hasOwn(props_, columnKey)) {
              watch(() => props_[columnKey], (newVal) => {
                instance.columnConfig.value[key] = newVal;
              });
            }
          });
        };
        return {
          registerComplexWatchers,
          registerNormalWatchers
        };
      }
      function useRender(props, slots, owner) {
        const instance = getCurrentInstance();
        const columnId = ref("");
        const isSubColumn = ref(false);
        const realAlign = ref();
        const realHeaderAlign = ref();
        const ns = useNamespace("table");
        watchEffect(() => {
          realAlign.value = props.align ? `is-${props.align}` : null;
          realAlign.value;
        });
        watchEffect(() => {
          realHeaderAlign.value = props.headerAlign ? `is-${props.headerAlign}` : realAlign.value;
          realHeaderAlign.value;
        });
        const columnOrTableParent = computed$1(() => {
          let parent = instance.vnode.vParent || instance.parent;
          while (parent && !parent.tableId && !parent.columnId) {
            parent = parent.vnode.vParent || parent.parent;
          }
          return parent;
        });
        const hasTreeColumn = computed$1(() => {
          const { store } = instance.parent;
          if (!store)
            return false;
          const { treeData } = store.states;
          const treeDataValue = treeData.value;
          return treeDataValue && Object.keys(treeDataValue).length > 0;
        });
        const realWidth = ref(parseWidth(props.width));
        const realMinWidth = ref(parseMinWidth(props.minWidth));
        const setColumnWidth = (column) => {
          if (realWidth.value)
            column.width = realWidth.value;
          if (realMinWidth.value) {
            column.minWidth = realMinWidth.value;
          }
          if (!realWidth.value && realMinWidth.value) {
            column.width = void 0;
          }
          if (!column.minWidth) {
            column.minWidth = 80;
          }
          column.realWidth = Number(column.width === void 0 ? column.minWidth : column.width);
          return column;
        };
        const setColumnForcedProps = (column) => {
          const type = column.type;
          const source = cellForced[type] || {};
          Object.keys(source).forEach((prop) => {
            const value = source[prop];
            if (prop !== "className" && value !== void 0) {
              column[prop] = value;
            }
          });
          const className = getDefaultClassName(type);
          if (className) {
            const forceClass = `${unref(ns.namespace)}-${className}`;
            column.className = column.className ? `${column.className} ${forceClass}` : forceClass;
          }
          return column;
        };
        const checkSubColumn = (children) => {
          if (Array.isArray(children)) {
            children.forEach((child) => check(child));
          } else {
            check(children);
          }
          function check(item) {
            var _a2;
            if (((_a2 = item == null ? void 0 : item.type) == null ? void 0 : _a2.name) === "ElTableColumn") {
              item.vParent = instance;
            }
          }
        };
        const setColumnRenders = (column) => {
          if (props.renderHeader)
            ;
          else if (column.type !== "selection") {
            column.renderHeader = (scope) => {
              instance.columnConfig.value["label"];
              return renderSlot(slots, "header", scope, () => [column.label]);
            };
          }
          let originRenderCell = column.renderCell;
          if (column.type === "expand") {
            column.renderCell = (data) => h$1("div", {
              class: "cell"
            }, [originRenderCell(data)]);
            owner.value.renderExpanded = (data) => {
              return slots.default ? slots.default(data) : slots.default;
            };
          } else {
            originRenderCell = originRenderCell || defaultRenderCell;
            column.renderCell = (data) => {
              let children = null;
              if (slots.default) {
                const vnodes = slots.default(data);
                children = vnodes.some((v2) => v2.type !== Comment) ? vnodes : originRenderCell(data);
              } else {
                children = originRenderCell(data);
              }
              const { columns } = owner.value.store.states;
              const firstUserColumnIndex = columns.value.findIndex((item) => item.type === "default");
              const shouldCreatePlaceholder = hasTreeColumn.value && data.cellIndex === firstUserColumnIndex;
              const prefix = treeCellPrefix(data, shouldCreatePlaceholder);
              const props2 = {
                class: "cell",
                style: {}
              };
              if (column.showOverflowTooltip) {
                props2.class = `${props2.class} ${unref(ns.namespace)}-tooltip`;
                props2.style = {
                  width: `${(data.column.realWidth || Number(data.column.width)) - 1}px`
                };
              }
              checkSubColumn(children);
              return h$1("div", props2, [prefix, children]);
            };
          }
          return column;
        };
        const getPropsData = (...propsKey) => {
          return propsKey.reduce((prev, cur) => {
            if (Array.isArray(cur)) {
              cur.forEach((key) => {
                prev[key] = props[key];
              });
            }
            return prev;
          }, {});
        };
        const getColumnElIndex = (children, child) => {
          return Array.prototype.indexOf.call(children, child);
        };
        const updateColumnOrder = () => {
          owner.value.store.commit("updateColumnOrder", instance.columnConfig.value);
        };
        return {
          columnId,
          realAlign,
          isSubColumn,
          realHeaderAlign,
          columnOrTableParent,
          setColumnWidth,
          setColumnForcedProps,
          setColumnRenders,
          getPropsData,
          getColumnElIndex,
          updateColumnOrder
        };
      }
      var defaultProps = {
        type: {
          type: String,
          default: "default"
        },
        label: String,
        className: String,
        labelClassName: String,
        property: String,
        prop: String,
        width: {
          type: [String, Number],
          default: ""
        },
        minWidth: {
          type: [String, Number],
          default: ""
        },
        renderHeader: Function,
        sortable: {
          type: [Boolean, String],
          default: false
        },
        sortMethod: Function,
        sortBy: [String, Function, Array],
        resizable: {
          type: Boolean,
          default: true
        },
        columnKey: String,
        align: String,
        headerAlign: String,
        showOverflowTooltip: {
          type: [Boolean, Object],
          default: void 0
        },
        fixed: [Boolean, String],
        formatter: Function,
        selectable: Function,
        reserveSelection: Boolean,
        filterMethod: Function,
        filteredValue: Array,
        filters: Array,
        filterPlacement: String,
        filterMultiple: {
          type: Boolean,
          default: true
        },
        filterClassName: String,
        index: [Number, Function],
        sortOrders: {
          type: Array,
          default: () => {
            return ["ascending", "descending", null];
          },
          validator: (val) => {
            return val.every((order) => ["ascending", "descending", null].includes(order));
          }
        }
      };
      let columnIdSeed = 1;
      var ElTableColumn$1 = defineComponent({
        name: "ElTableColumn",
        components: {
          ElCheckbox
        },
        props: defaultProps,
        setup(props, { slots }) {
          const instance = getCurrentInstance();
          const columnConfig = ref({});
          const owner = computed$1(() => {
            let parent2 = instance.parent;
            while (parent2 && !parent2.tableId) {
              parent2 = parent2.parent;
            }
            return parent2;
          });
          const { registerNormalWatchers, registerComplexWatchers } = useWatcher(owner, props);
          const {
            columnId,
            isSubColumn,
            realHeaderAlign,
            columnOrTableParent,
            setColumnWidth,
            setColumnForcedProps,
            setColumnRenders,
            getPropsData,
            getColumnElIndex,
            realAlign,
            updateColumnOrder
          } = useRender(props, slots, owner);
          const parent = columnOrTableParent.value;
          columnId.value = `${parent.tableId || parent.columnId}_column_${columnIdSeed++}`;
          onBeforeMount(() => {
            isSubColumn.value = owner.value !== parent;
            const type = props.type || "default";
            const sortable = props.sortable === "" ? true : props.sortable;
            const showOverflowTooltip = isUndefined(props.showOverflowTooltip) ? parent.props.showOverflowTooltip : props.showOverflowTooltip;
            const defaults2 = {
              ...cellStarts[type],
              id: columnId.value,
              type,
              property: props.prop || props.property,
              align: realAlign,
              headerAlign: realHeaderAlign,
              showOverflowTooltip,
              filterable: props.filters || props.filterMethod,
              filteredValue: [],
              filterPlacement: "",
              filterClassName: "",
              isColumnGroup: false,
              isSubColumn: false,
              filterOpened: false,
              sortable,
              index: props.index,
              rawColumnKey: instance.vnode.key
            };
            const basicProps = [
              "columnKey",
              "label",
              "className",
              "labelClassName",
              "type",
              "renderHeader",
              "formatter",
              "fixed",
              "resizable"
            ];
            const sortProps = ["sortMethod", "sortBy", "sortOrders"];
            const selectProps = ["selectable", "reserveSelection"];
            const filterProps = [
              "filterMethod",
              "filters",
              "filterMultiple",
              "filterOpened",
              "filteredValue",
              "filterPlacement",
              "filterClassName"
            ];
            let column = getPropsData(basicProps, sortProps, selectProps, filterProps);
            column = mergeOptions(defaults2, column);
            const chains = compose(setColumnRenders, setColumnWidth, setColumnForcedProps);
            column = chains(column);
            columnConfig.value = column;
            registerNormalWatchers();
            registerComplexWatchers();
          });
          onMounted(() => {
            var _a2;
            const parent2 = columnOrTableParent.value;
            const children = isSubColumn.value ? parent2.vnode.el.children : (_a2 = parent2.refs.hiddenColumns) == null ? void 0 : _a2.children;
            const getColumnIndex = () => getColumnElIndex(children || [], instance.vnode.el);
            columnConfig.value.getColumnIndex = getColumnIndex;
            const columnIndex = getColumnIndex();
            columnIndex > -1 && owner.value.store.commit("insertColumn", columnConfig.value, isSubColumn.value ? parent2.columnConfig.value : null, updateColumnOrder);
          });
          onBeforeUnmount(() => {
            owner.value.store.commit("removeColumn", columnConfig.value, isSubColumn.value ? parent.columnConfig.value : null, updateColumnOrder);
          });
          instance.columnId = columnId.value;
          instance.columnConfig = columnConfig;
          return;
        },
        render() {
          var _a2, _b, _c;
          try {
            const renderDefault = (_b = (_a2 = this.$slots).default) == null ? void 0 : _b.call(_a2, {
              row: {},
              column: {},
              $index: -1
            });
            const children = [];
            if (Array.isArray(renderDefault)) {
              for (const childNode of renderDefault) {
                if (((_c = childNode.type) == null ? void 0 : _c.name) === "ElTableColumn" || childNode.shapeFlag & 2) {
                  children.push(childNode);
                } else if (childNode.type === Fragment && Array.isArray(childNode.children)) {
                  childNode.children.forEach((vnode2) => {
                    if ((vnode2 == null ? void 0 : vnode2.patchFlag) !== 1024 && !isString(vnode2 == null ? void 0 : vnode2.children)) {
                      children.push(vnode2);
                    }
                  });
                }
              }
            }
            const vnode = h$1("div", children);
            return vnode;
          } catch (e) {
            return h$1("div", []);
          }
        }
      });
      const ElTable = exports("bz", withInstall(Table, {
        TableColumn: ElTableColumn$1
      }));
      const ElTableColumn = exports("by", withNoopInstall(ElTableColumn$1));
      const textProps = buildProps({
        type: {
          type: String,
          values: ["primary", "success", "info", "warning", "danger", ""],
          default: ""
        },
        size: {
          type: String,
          values: componentSizes,
          default: ""
        },
        truncated: {
          type: Boolean
        },
        lineClamp: {
          type: [String, Number]
        },
        tag: {
          type: String,
          default: "span"
        }
      });
      const __default__ = defineComponent({
        name: "ElText"
      });
      const _sfc_main$6 = /* @__PURE__ */ defineComponent({
        ...__default__,
        props: textProps,
        setup(__props) {
          const props = __props;
          const textSize = useFormSize();
          const ns = useNamespace("text");
          const textKls = computed$1(() => [
            ns.b(),
            ns.m(props.type),
            ns.m(textSize.value),
            ns.is("truncated", props.truncated),
            ns.is("line-clamp", !isUndefined(props.lineClamp))
          ]);
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
              class: normalizeClass(unref(textKls)),
              style: normalizeStyle({ "-webkit-line-clamp": _ctx.lineClamp })
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["class", "style"]);
          };
        }
      });
      var Text = /* @__PURE__ */ _export_sfc$1(_sfc_main$6, [["__file", "text.vue"]]);
      const ElText = exports("bw", withInstall(Text));
      const _export_sfc = exports("_", (sfc, props) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props) {
          target[key] = val;
        }
        return target;
      });
      const _sfc_main$5 = {};
      const _hoisted_1$4 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      };
      const _hoisted_2$4 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M704 704h64v192H256V704h64v64h384zm188.544-152.192C894.528 559.616 896 567.616 896 576a96 96 0 1 1-192 0 96 96 0 1 1-192 0 96 96 0 1 1-192 0 96 96 0 1 1-192 0c0-8.384 1.408-16.384 3.392-24.192L192 128h640z"
      }, null, -1);
      const _hoisted_3$4 = [
        _hoisted_2$4
      ];
      function _sfc_render$3(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$4, _hoisted_3$4);
      }
      const Shop = exports("bp", /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$3]]));
      const _sfc_main$4 = {};
      const _hoisted_1$3 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      };
      const _hoisted_2$3 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M640 288h-64V128H128v704h384v32a32 32 0 0 0 32 32H96a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32h512a32 32 0 0 1 32 32z"
      }, null, -1);
      const _hoisted_3$3 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M128 320v512h768V320zm-32-64h832a32 32 0 0 1 32 32v576a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V288a32 32 0 0 1 32-32"
      }, null, -1);
      const _hoisted_4$2 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M704 640a64 64 0 1 1 0-128 64 64 0 0 1 0 128"
      }, null, -1);
      const _hoisted_5$1 = [
        _hoisted_2$3,
        _hoisted_3$3,
        _hoisted_4$2
      ];
      function _sfc_render$2(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$3, _hoisted_5$1);
      }
      const Wallet = exports("bq", /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$2]]));
      const _sfc_main$3 = {};
      const _hoisted_1$2 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      };
      const _hoisted_2$2 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M224 318.336V896h576V318.336L552.512 115.84a64 64 0 0 0-81.024 0zM593.024 66.304l259.2 212.096A32 32 0 0 1 864 303.168V928a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V303.168a32 32 0 0 1 11.712-24.768l259.2-212.096a128 128 0 0 1 162.112 0z"
      }, null, -1);
      const _hoisted_3$2 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M512 448a64 64 0 1 0 0-128 64 64 0 0 0 0 128m0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256"
      }, null, -1);
      const _hoisted_4$1 = [
        _hoisted_2$2,
        _hoisted_3$2
      ];
      function _sfc_render$1(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$2, _hoisted_4$1);
      }
      const PriceTag = exports("br", /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$1]]));
      const _sfc_main$2 = {};
      const _hoisted_1$1 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      };
      const _hoisted_2$1 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
      }, null, -1);
      const _hoisted_3$1 = [
        _hoisted_2$1
      ];
      function _sfc_render(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$1, _hoisted_3$1);
      }
      const CircleCloseFilled = exports("bo", /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render]]));
      const EventSourcePolyfill = EventSourcePolyfillDefault;
      class SSEClient {
        constructor(url) {
          __publicField(this, "eventSource");
          __publicField(this, "callbackList");
          this.url = url;
          this.eventSource = null;
          this.callbackList = [];
        }
        start() {
          let authorization = localStorage.getItem("Authorization");
          this.eventSource = new EventSourcePolyfill(this.url, {
            withCredentials: true,
            // 5分钟超时(略小于nginx sse超时时间)
            heartbeatTimeout: 5 * 59 * 1e3,
            headers: {
              "Authorization": authorization
            }
          });
          this.eventSource.onmessage = (event) => {
            this.callbackList.forEach((callBackFunc) => callBackFunc(event));
          };
          this.eventSource.onerror = (error) => {
            this.close();
          };
        }
        addEventListener(eventType, listener) {
          if (this.eventSource) {
            this.eventSource.addEventListener(eventType, listener);
          }
        }
        addOnMsgCallback(func) {
          this.callbackList.push(func);
        }
        close() {
          if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
          }
        }
      } exports("bv", SSEClient);
      const _withScopeId = (n) => (pushScopeId("data-v-5cadd0bd"), n = n(), popScopeId(), n);
      const _hoisted_1 = { class: "my-header" };
      const _hoisted_2 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
      const _hoisted_3 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("h3", null, "我的功能列表", -1));
      const _hoisted_4 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
      const _hoisted_5 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
      const _hoisted_6 = {
        type: "info",
        style: { "margin-top": "10px" }
      };
      const _hoisted_7 = { key: 0 };
      const _hoisted_8 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
      const _hoisted_9 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
      const _hoisted_10 = { style: { "padding-top": "10px", "min-width": "8%" } };
      const _hoisted_11 = { class: "demonstration" };
      const _hoisted_12 = { class: "demonstration" };
      const _hoisted_13 = { class: "demonstration" };
      const _hoisted_14 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("div", { class: "image-slot" }, "加载订单二维码失败；请稍后刷新重试", -1));
      const _hoisted_15 = { style: { "width": "80%" } };
      const _hoisted_16 = { class: "demonstration" };
      const _sfc_main$1 = /* @__PURE__ */ defineComponent({
        __name: "Product",
        setup(__props) {
          const productStore = ProductStore();
          const axios2 = inject("$axios");
          const productGroupLoading = ref(false);
          const buyProductList = ref([]);
          const showOtherProduct = ref(true);
          const orderGroup = ref([]);
          const payStatus = ref(false);
          const promotionCode = ref("");
          const lastPromotionCode = ref("");
          let pairList = [];
          const isExpired = (row) => {
            const currentTime = /* @__PURE__ */ new Date();
            const endTime = new Date(row.periodOfValidityEndTime);
            return currentTime > endTime;
          };
          const randomStyle = () => {
            const tagStyleArr = ["primary", "warning", "success", "danger"];
            let number = Math.floor(Math.random() * 4);
            return tagStyleArr[number];
          };
          const queryBuyProductList = async () => {
            let productResp = await axios2.post("/api/product/user/product/list");
            buyProductList.value = productResp.data.data;
          };
          const openProductDialog = async () => {
            await queryBuyProductList();
            if (buyProductList.value.length > 0) {
              return;
            }
            showOtherProduct.value = false;
            await showOrderGroup();
          };
          const showOrderGroup = async () => {
            if (!loginInterceptor()) {
              return;
            }
            productGroupLoading.value = true;
            let promotionCodeVar = promotionCode.value.trim();
            promotionCode.value = "";
            setTimeout(() => {
              showOtherProduct.value = true;
            }, 100);
            if (orderGroup.value.length < 1 || promotionCodeVar !== lastPromotionCode.value) {
              let orderGroupResp;
              try {
                orderGroupResp = await axios2.post("/api/pay/generate/order/group", { promotionCode: promotionCodeVar });
              } catch (e) {
                productGroupLoading.value = false;
                return;
              }
              if (orderGroupResp.data.code != 200) {
                ElMessage({
                  message: orderGroupResp.data.message,
                  type: "warning",
                  duration: 3e3
                });
                setTimeout(() => {
                  showOtherProduct.value = false;
                }, 100);
                productGroupLoading.value = false;
                return;
              }
              orderGroup.value = orderGroupResp.data.data;
              lastPromotionCode.value = promotionCodeVar;
              productGroupLoading.value = false;
              waitUsePay();
            }
            productGroupLoading.value = false;
          };
          const waitUsePay = () => {
            const sseClient = new SSEClient(axios2.defaults.baseURL + "api/sse/connect");
            sseClient.addOnMsgCallback((event) => {
              let data = event.data;
              if (data === "支付成功") {
                payStatus.value = true;
                orderGroup.value = [];
                queryBuyProductList();
                showOtherProduct.value = false;
                productStore.setShowProduct(false);
              }
            });
            sseClient.start();
            let count = 0;
            let interval = setInterval(() => {
              if (payStatus.value) {
                clearInterval(interval);
              }
              orderGroup.value.forEach((orderItem) => {
                axios2.get("/api/pay/searchOrder?outTradeNo=" + orderItem.orderId).then((resp) => {
                  if (resp.data.data === "TRADE_SUCCESS") {
                    payStatus.value = true;
                    orderGroup.value = [];
                    clearInterval(interval);
                  }
                  if (resp.data.data === "WAIT_BUYER_PAY") {
                    logger$1.debug("等待支付");
                  }
                  count++;
                  if (count >= 10) {
                    logger$1.warn("订单超时未支付");
                    clearInterval(interval);
                  }
                });
              });
            }, 3e4);
            let pair = {
              key: sseClient,
              value: interval
            };
            pairList.push(pair);
          };
          watch(
            () => productStore.showProduct,
            (newVal) => {
              if (newVal) {
                openProductDialog();
              } else {
                pairList.forEach((pair) => {
                  if (pair && pair.key instanceof SSEClient) {
                    pair.key.close();
                    clearInterval(pair.value);
                  }
                });
              }
            }
          );
          return (_ctx, _cache) => {
            const _component_el_text = ElText;
            const _component_el_icon = ElIcon;
            const _component_el_button = ElButton;
            const _component_el_table_column = ElTableColumn;
            const _component_el_tag = ElTag;
            const _component_el_table = ElTable;
            const _component_el_input = ElInput;
            const _component_el_link = ElLink;
            const _component_el_image = ElImage;
            const _component_el_dialog = ElDialog;
            return openBlock(), createBlock(_component_el_dialog, {
              modelValue: unref(productStore).showProduct,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(productStore).showProduct = $event),
              "show-close": false,
              width: "800"
            }, {
              header: withCtx(({ close }) => [
                createElementVNode("div", _hoisted_1, [
                  createVNode(_component_el_text, {
                    size: "large",
                    style: { "font-size": "20px" },
                    type: "info"
                  }, {
                    default: withCtx(() => [
                      // createTextVNode("产品列表")
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_button, {
                    type: "warning",
                    onClick: close
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_el_icon, { class: "el-icon--left" }, {
                        default: withCtx(() => [
                          createVNode(unref(CircleCloseFilled))
                        ]),
                        _: 1
                      }),
                      createTextVNode(" 关闭 ")
                    ]),
                    _: 2
                  }, 1032, ["onClick"])
                ]),
                withDirectives(createElementVNode("div", null, [
                  _hoisted_2,
                  _hoisted_3,
                  _hoisted_4,
                  withDirectives(createVNode(_component_el_table, {
                    data: buyProductList.value,
                    stripe: "",
                    style: { "width": "100%" }
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_el_table_column, {
                        prop: "productName",
                        label: "产品",
                        width: "180"
                      }, {
                        default: withCtx(({ row }) => [
                          createElementVNode("span", {
                            style: normalizeStyle({ textDecoration: isExpired(row) ? "line-through" : "none" })
                          }, toDisplayString(row.productName), 5)
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_table_column, {
                        label: "状态",
                        width: "100"
                      }, {
                        default: withCtx(({ row }) => [
                          createElementVNode("span", {
                            style: normalizeStyle({ color: isExpired(row) ? "red" : "green" })
                          }, toDisplayString(isExpired(row) ? "过期" : "正常"), 5)
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_table_column, {
                        prop: "powerList",
                        label: "能力",
                        width: "180"
                      }, {
                        default: withCtx(({ row }) => [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(row.powerList, (power) => {
                            return openBlock(), createElementBlock("div", { key: power }, [
                              createVNode(_component_el_tag, {
                                effect: "dark",
                                type: randomStyle(),
                                size: "small"
                              }, {
                                default: withCtx(() => [
                                  createTextVNode(toDisplayString(power), 1)
                                ]),
                                _: 2
                              }, 1032, ["type"])
                            ]);
                          }), 128))
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_table_column, {
                        prop: "periodOfValidityStartTime",
                        label: "有效期开始时间"
                      }),
                      createVNode(_component_el_table_column, {
                        prop: "periodOfValidityEndTime",
                        label: "有效期结束时间"
                      })
                    ]),
                    _: 1
                  }, 8, ["data"]), [
                    [vShow, buyProductList.value.length > 0]
                  ]),
                  _hoisted_5
                ], 512), [
                  [vShow, buyProductList.value.length > 0]
                ]),
                createElementVNode("div", _hoisted_6, [
                  createVNode(_component_el_button, {
                    type: "danger",
                    icon: unref(Shop),
                    onClick: showOrderGroup,
                    loading: productGroupLoading.value
                  }, {
                    default: withCtx(() => [
                      // createTextVNode(" 更多产品 ")
                    ]),
                    _: 1
                  }, 8, ["icon", "loading"]),
                  createVNode(_component_el_input, {
                    "suffix-icon": unref(Wallet),
                    modelValue: promotionCode.value,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => promotionCode.value = $event),
                    style: { "margin-left": "10px", "width": "240px" },
                    placeholder: "请输入您的优惠码"
                  }, null, 8, ["suffix-icon", "modelValue"]),
                  createVNode(_component_el_link, {
                    icon: unref(PriceTag),
                    type: "primary",
                    style: { "margin-left": "30px" },
                    target: "_blank",
                    href: "https://www.bilibili.com/video/BV1HKAyebESp"
                  }, {
                    default: withCtx(() => [
                      createTextVNode("点击获取优惠码(评论区) ")
                    ]),
                    _: 1
                  }, 8, ["icon"])
                ]),
                showOtherProduct.value ? (openBlock(), createElementBlock("div", _hoisted_7, [
                  _hoisted_8,
                  createElementVNode("p", null, [
                    createVNode(_component_el_text, {
                      class: "mx-1",
                      type: "danger"
                    }, {
                      default: withCtx(() => [
                        createTextVNode("定价说明：")
                      ]),
                      _: 1
                    }),
                    createTextVNode(" 使用R1深度思考大模型时：首先，R1的价格更贵，深度思考的内容也会被记录token消耗。token消耗量巨大。同时由于boss的会话聊天机制，需要携带消息上下文调用。这也就意味着对话轮数越多，token消耗越多。按乘方的趋势增长。 ")
                  ]),
                  _hoisted_9,
                  (openBlock(true), createElementBlock(Fragment, null, renderList(orderGroup.value, (order) => {
                    return openBlock(), createElementBlock("div", {
                      key: order,
                      style: normalizeStyle([{ "display": "flex" }, "width: " + 1 / orderGroup.value.length]),
                      class: "block"
                    }, [
                      createElementVNode("div", _hoisted_10, [
                        createElementVNode("p", _hoisted_11, [
                          createVNode(_component_el_text, {
                            size: "large",
                            type: "primary"
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString(order.title), 1)
                            ]),
                            _: 2
                          }, 1024)
                        ]),
                        createElementVNode("p", _hoisted_12, [
                          createVNode(_component_el_text, {
                            size: "large",
                            type: "success"
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString(order.validDays) + "天", 1)
                            ]),
                            _: 2
                          }, 1024)
                        ]),
                        createElementVNode("p", _hoisted_13, [
                          createVNode(_component_el_text, {
                            size: "large",
                            type: "danger"
                          }, {
                            default: withCtx(() => [
                              createTextVNode("￥ " + toDisplayString(order.totalAmount), 1)
                            ]),
                            _: 2
                          }, 1024)
                        ])
                      ]),
                      createVNode(_component_el_image, {
                        style: { "width": "100px", "height": "100px" },
                        src: "data:image/png;base64," + order.qrCodeBase64,
                        fit: "fill"
                      }, {
                        error: withCtx(() => [
                          _hoisted_14
                        ]),
                        _: 2
                      }, 1032, ["src"]),
                      createElementVNode("div", _hoisted_15, [
                        createElementVNode("div", null, [
                          createTextVNode(" 提供能力: "),
                          (openBlock(true), createElementBlock(Fragment, null, renderList(order.tags, (tag) => {
                            return openBlock(), createBlock(_component_el_tag, {
                              style: { "margin": "10px" },
                              key: tag,
                              type: randomStyle(),
                              size: "large",
                              effect: "light"
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(tag), 1)
                              ]),
                              _: 2
                            }, 1032, ["type"]);
                          }), 128))
                        ]),
                        createElementVNode("div", null, [
                          createElementVNode("span", _hoisted_16, toDisplayString(order.desc), 1)
                        ])
                      ])
                    ], 4);
                  }), 128))
                ])) : createCommentVNode("", true)
              ]),
              _: 1
            }, 8, ["modelValue"]);
          };
        }
      });
      const Product = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-5cadd0bd"]]);
      const _sfc_main = /* @__PURE__ */ defineComponent({
        __name: "App",
        setup(__props) {
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock(Fragment, null, [
              createVNode(_sfc_main$x),
              createVNode(Product)
            ], 64);
          };
        }
      });
      const logger = new Logger();
      logger.setLogLevel(LogLevel.Debug);
      function encodeLength(len) {
        const output = [];
        let x2 = len;
        do {
          let encodedByte = x2 % 128;
          x2 = Math.floor(x2 / 128);
          if (x2 > 0) {
            encodedByte |= 128;
          }
          output.push(encodedByte);
        } while (x2 > 0);
        return output;
      }
      function encodeUTF8String(str2, encoder) {
        const bytes = encoder.encode(str2);
        return [bytes.length >> 8, bytes.length & 255, ...bytes];
      }
      function decodeUTF8String(buffer, startIndex, utf8Decoder) {
        const bytes = decodeUint8Array(buffer, startIndex);
        if (bytes === void 0) {
          return void 0;
        }
        const value = utf8Decoder.decode(bytes);
        return {
          length: bytes.length + 2,
          value
        };
      }
      const mqtt = {
        encode(packet) {
          const utf8 = new TextEncoder();
          const variableHeader = [...encodeUTF8String("chat", utf8)];
          if (packet.messageId) {
            variableHeader.push(packet.messageId >> 8, packet.messageId & 255);
          }
          let { payload } = packet;
          if (typeof payload === "string") {
            payload = utf8.encode(payload);
          }
          const fixedHeader = [
            3 << 4 | 3,
            // 0x00110011 qos1消息，非重传、保留消息
            ...encodeLength(variableHeader.length + payload.length)
          ];
          return Uint8Array.from([...fixedHeader, ...variableHeader, ...payload]);
        },
        decode(buffer, flags = 3) {
          const dup = !!(flags & 8);
          const qos = (flags & 6) >> 1;
          const { length: remainingLength, bytesUsedToEncodeLength } = decodeLength(
            buffer,
            1
          );
          const retain = !!(flags & 1);
          const utf = new TextDecoder("utf-8");
          const topicStart = bytesUsedToEncodeLength + 1;
          let decodedTopic = decodeUTF8String(buffer, topicStart, utf);
          if (decodedTopic === void 0) {
            logger.trace("空主题");
            decodedTopic = { length: 0, value: "" };
          }
          const topic = decodedTopic.value;
          let id = 0;
          let payloadStart = topicStart + decodedTopic.length;
          if (qos > 0) {
            const idStart = payloadStart;
            try {
              id = parseMessageId(buffer, idStart);
            } catch {
              logger.trace(`错的id?: `, {
                payloadStart,
                topicStart,
                topic,
                dup,
                qos,
                remainingLength,
                retain
              });
            }
            payloadStart += 2;
          }
          const payload = buffer.subarray(payloadStart);
          return {
            topic,
            payload,
            dup,
            retain,
            qos,
            messageId: id
          };
        }
      };
      function decodeLength(buffer, startIndex) {
        let i = startIndex;
        let encodedByte = 0;
        let value = 0;
        let multiplier = 1;
        do {
          encodedByte = buffer[i];
          i += 1;
          value += (encodedByte & 127) * multiplier;
          if (multiplier > 128 * 128 * 128) {
            throw Error("malformed length");
          }
          multiplier *= 128;
        } while ((encodedByte & 128) !== 0);
        return { length: value, bytesUsedToEncodeLength: i - startIndex };
      }
      function parseMessageId(buffer, startIndex) {
        if (startIndex + 2 > buffer.length) {
          throw new Error("Cannot parse messageId");
        }
        return buffer[startIndex] << 8 | buffer[startIndex + 1];
      }
      function decodeUint8Array(buffer, startIndex) {
        if (startIndex >= buffer.length || startIndex + 2 > buffer.length) {
          return void 0;
        }
        const length = (buffer[startIndex] << 8) + buffer[startIndex + 1];
        const bytes = buffer.subarray(startIndex + 2, startIndex + 2 + length);
        return bytes;
      }
      function decodeMqttAndProtobuf(data, caller) {
        let uint8Array = new Uint8Array(data);
        let mqttDecodeResult;
        try {
          mqttDecodeResult = mqtt.decode(uint8Array);
          if (mqttDecodeResult.topic !== "chat") {
            logger$1.trace("过滤【非chat】主题", mqttDecodeResult);
            return;
          }
          let chatProtocolObj = protobufType.decode(mqttDecodeResult.payload);
          if ((chatProtocolObj == null ? void 0 : chatProtocolObj.messages.length) !== 0) {
            logger$1.debug(caller + "【消息mqtt】：", mqttDecodeResult);
            logger$1.debug(caller + "【消息对象】：", chatProtocolObj);
            if (chatProtocolObj.messages[0].body.type === 7) {
              chatProtocolObj.messages[0].body.text = new TextDecoder().decode(mqttDecodeResult.payload);
            }
            if (!chatProtocolObj.messages[0].body.text && caller !== "发送") {
              chatProtocolObj.messages[0].body.text = new TextDecoder().decode(mqttDecodeResult.payload);
            }
          } else {
            logger$1.debug(caller + "【非消息协议对象】", chatProtocolObj);
          }
          return chatProtocolObj;
        } catch (e) {
          logger$1.debug(caller + " 解码失败", mqttDecodeResult, e);
        }
      }
      function getMsgBody(data) {
        var _a2, _b;
        let messages = data == null ? void 0 : data.messages;
        if (!messages) {
          return "";
        }
        return (_b = (_a2 = messages == null ? void 0 : messages[0]) == null ? void 0 : _a2.body) == null ? void 0 : _b.text;
      }
      function normalizeNumber(number) {
        if (typeof number === "string" || typeof number === "number") {
          return number;
        } else if ("low" in number) {
          return number.toNumber();
        }
        return 0;
      }
      var JobSeekerClonedAnswerTypeEnum = /* @__PURE__ */ ((JobSeekerClonedAnswerTypeEnum2) => {
        JobSeekerClonedAnswerTypeEnum2[JobSeekerClonedAnswerTypeEnum2["MSG_TEXT"] = 1] = "MSG_TEXT";
        JobSeekerClonedAnswerTypeEnum2[JobSeekerClonedAnswerTypeEnum2["BOSS_OPERATION"] = 2] = "BOSS_OPERATION";
        JobSeekerClonedAnswerTypeEnum2[JobSeekerClonedAnswerTypeEnum2["STOP"] = 3] = "STOP";
        JobSeekerClonedAnswerTypeEnum2[JobSeekerClonedAnswerTypeEnum2["AI_SERVICE_EXCEPTION"] = 4] = "AI_SERVICE_EXCEPTION";
        return JobSeekerClonedAnswerTypeEnum2;
      })(JobSeekerClonedAnswerTypeEnum || {});
      var BossOperationTypeEnum = /* @__PURE__ */ ((BossOperationTypeEnum2) => {
        BossOperationTypeEnum2[BossOperationTypeEnum2["SEND_RESUME"] = 1] = "SEND_RESUME";
        return BossOperationTypeEnum2;
      })(BossOperationTypeEnum || {});
      let userStore$1 = null;
      const _BossOption = class _BossOption {
        constructor() {
          if (!userStore$1) {
            userStore$1 = UserStore();
          }
        }
        /**
         * 前置回复boss消息
         * 针对boss发起的简历，联系方式，微信等需求，用于回复简历，联系方式，微信等
         */
        async preReplyMsg(msgObj, bossUserInfo, text) {
          let type;
          if (text.includes("交换微信")) {
            type = 2;
          } else if (text.includes("交换联系方式") || text.includes("我想要一个您的电话号码，您是否同意")) {
            type = 1;
          } else if (text.includes("我想要一份您的附件简历，您是否同意")) {
            type = 4;
          } else if (text.includes("是否接受此工作地点")) {
            return;
          } else if (text.includes("您对本职位的求职过程满意吗")) {
            return;
          } else {
            logger$1.info("【处理Boss消息-失败】未知类型消息", text);
          }
          let mid = msgObj.messages[0].mid;
          axios.post("https://www.zhipin.com/wapi/zpchat/exchange/accept", {
            securityId: bossUserInfo.securityId,
            type,
            mid: mid.toString(),
            ...type === 4 ? { encryptResumeId: userStore$1.user.resumeId } : {}
          }, {
            headers: {
              "Zp_token": Tools.getCookieValue("bst"),
              "content-type": "application/x-www-form-urlencoded;charset=UTF-8"
            }
          }).then((_2) => {
          }).catch((_2) => {
          });
        }
        preHandlerMsgByBodyType(msgObj, bossUserInfo, text) {
          const bodyType = msgObj.messages[0].body.type;
          switch (bodyType) {
            case 7:
              logger$1.debug("【处理Boss消息】boss索要简历，联系方式，微信", text, msgObj);
              this.preReplyMsg(msgObj, bossUserInfo, text).then();
              return false;
            case 12:
            case 4:
            case 8:
            case 14:
              logger$1.debug("【处理Boss消息】系统消息", text, msgObj);
              return false;
            case 1:
              if (text.includes("&lt;/phone&gt;") || text.includes("&lt;/copy&gt;")) {
                logger$1.debug("【处理Boss消息】过滤处理过的索要联系方式消息", text, msgObj);
                return false;
              }
              if (text.includes("对方拒绝了您的发送请求")) {
                logger$1.debug("【处理Boss消息】hr拒绝简历的普通消息", text, msgObj);
                return false;
              }
              if (text === "方便发一份简历过来吗？") {
                return false;
              }
          }
          return !!text;
        }
        preHandlerMsgByMsgType(msgObj, text) {
          const msgType = msgObj.messages[0].type;
          switch (msgType) {
            case 1:
              return true;
            case 3:
              return true;
            case 4:
              logger$1.debug("【处理Boss消息-忽略】boss系统提示消息", text);
              return false;
            default:
              return true;
          }
        }
        buildNoticeHtml(fromName, fromAvatar, question, answer) {
          return _BossOption.template.replace(/{{user_name}}/g, fromName).replace(/{{user_avatar}}/g, fromAvatar).replace(/{{user_question}}/g, question).replace(/{{assistant_name}}/g, "AI助手").replace(/{{assistant_answer}}/g, answer).replace(/{{assistant_avatar}}/g, _BossOption.aiIconWebpBase64);
        }
        async handlerBossMessage(msgObj, bossId, text) {
          if (userStore$1.user.preference.drE && userStore$1.user.preference.dr > 0) {
            await Tools.sleep(userStore$1.user.preference.dr * 1e3 + Tools.getRandomNumber(0, 300));
          }
          if (_BossOption.messageCache.isMessageProcessed(bossId, text)) {
            logger$1.trace("【跳过重复消息】:", bossId, text);
            return;
          }
          _BossOption.messageCache.markMessageAsProcessed(bossId, text);
          if (!userStore$1.user.aiSeatStatus) {
            logger$1.info("AI坐席未开启，不处理消息");
            return;
          }
          if (!this.preHandlerMsgByMsgType(msgObj, text)) {
            return;
          }
          const bossUserInfo = await this.getBossUserInfoByBossId(bossId);
          if (!bossUserInfo) {
            const bodyType = msgObj.messages[0].body.type;
            if (bodyType === 15) {
              return;
            }
            _BossOption.logRecorder.error("【处理Boss消息-失败】无法获取联系人信息", text);
            return;
          }
          if (!this.preHandlerMsgByBodyType(msgObj, bossUserInfo, text)) {
            return;
          }
          logger$1.debug("接收消息解码内容：", text);
          const jobKey = _BossOption.buildJobKey(bossUserInfo);
          return AiPower.ask(text, jobKey, bossUserInfo).then((resp) => {
            var _a2, _b, _c, _d, _e;
            let data = resp.data.data;
            let answerTypeList = data == null ? void 0 : data.answerTypeList;
            if (answerTypeList.includes(JobSeekerClonedAnswerTypeEnum.STOP)) {
              logger$1.info("【处理Boss消息-忽略】停止交互");
              return Promise.resolve();
            }
            if (answerTypeList.includes(JobSeekerClonedAnswerTypeEnum.AI_SERVICE_EXCEPTION)) {
              logger$1.info("AI服务异常，暂时无法处理消息");
              ElMessage({
                type: "error",
                message: "AI服务异常，暂时无法处理消息（请联系管理员处理）"
              });
              return Promise.resolve();
            }
            if (answerTypeList.includes(JobSeekerClonedAnswerTypeEnum.MSG_TEXT)) {
              const html = this.buildNoticeHtml((_b = (_a2 = msgObj.messages[0]) == null ? void 0 : _a2.from) == null ? void 0 : _b.name, (_d = (_c = msgObj.messages[0]) == null ? void 0 : _c.from) == null ? void 0 : _d.avatar, text, data.answerContent);
              this.sendMsg(bossId, data.answerContent + Tools.getEndChar(), void 0, html);
            }
            if (answerTypeList.includes(JobSeekerClonedAnswerTypeEnum.BOSS_OPERATION)) {
              (_e = data == null ? void 0 : data.operationTypeList) == null ? void 0 : _e.includes(BossOperationTypeEnum.SEND_RESUME);
              {
                this.sendResumeFile(bossId).then((_2) => {
                });
              }
            }
            new MessageRead({
              userId: bossUserInfo.bossId,
              messageId: msgObj.messages[0].mid
            }).send();
            setTimeout(() => {
              const bossEleList = Array.from(document.querySelectorAll(".friend-content"));
              bossEleList.filter((bossEle) => {
                var _a3, _b2, _c2;
                return bossUserInfo.bossId === ((_c2 = (_b2 = (_a3 = bossEle == null ? void 0 : bossEle.__vue__) == null ? void 0 : _a3._props) == null ? void 0 : _b2.source) == null ? void 0 : _c2.uid);
              }).forEach((bossEle) => {
                bossEle.querySelectorAll(".notice-badge").forEach((badgeEle) => {
                  badgeEle.remove();
                  return;
                });
              });
            }, 500);
          });
        }
        sendMsg(bossId, msg, image, html) {
          this.getBossUserInfoByBossId(bossId).then((bossUserInfo) => {
            if (!bossUserInfo) {
              _BossOption.logRecorder.error("发送消息失败，联系人信息获取失败");
              return;
            }
            let message = new Message({
              form_uid: Tools.window._PAGE.uid.toString(),
              to_uid: bossId.toString(),
              to_name: bossUserInfo.encryptBossId,
              content: msg,
              image: void 0
            });
            message.send();
            if (html) {
              ElNotification({
                type: "success",
                title: "AI坐席回复",
                showClose: false,
                duration: 2e3,
                dangerouslyUseHTMLString: true,
                message: html
              });
            }
          });
        }
        async sendResumeFile(bossId) {
          let resumeId = userStore$1.user.resumeId;
          if (!resumeId) {
            return;
          }
          return this.getBossUserInfoByBossId(bossId).then((bossUserInfo) => {
            if (!bossUserInfo) {
              _BossOption.logRecorder.error("发送简历失败，联系人信息获取失败");
              return;
            }
            axios.post("https://www.zhipin.com/wapi/zpchat/exchange/request", {
              securityId: bossUserInfo.securityId,
              type: 3,
              encryptResumeId: resumeId
            }, {
              headers: {
                "Zp_token": Tools.getCookieValue("bst"),
                "content-type": "application/x-www-form-urlencoded;charset=UTF-8"
              }
            }).then((_2) => {
            }).catch((_2) => {
            });
          });
        }
        static getJobKeyByCache(bossId) {
          let bossUserInfo = _BossOption.getBossUserInfoByCache(bossId);
          if (!bossUserInfo) {
            return "";
          }
          return this.buildJobKey(bossUserInfo);
        }
        static getBossUserInfoByCache(bossId) {
          return _BossOption.bossUserInfoMap.get(bossId);
        }
        static buildJobKey(bossUserInfo) {
          if (!bossUserInfo) {
            return "";
          }
          return bossUserInfo.encryptJobId + ":" + Tools.window._PAGE.uid;
        }
        static async loadRecentContact() {
          this.obtainRecentContactBossId().then((bossIdList) => this.obtainBossUserInfo(bossIdList)).then((bossUserInfoList) => {
            bossUserInfoList.forEach((bossUserInfo) => {
              this.bossUserInfoMap.set(bossUserInfo.bossId, bossUserInfo);
            });
          }).catch((e) => {
            logger$1.error("加载最近联系人失败", e);
          });
        }
        async getBossUserInfoByBossId(bossId) {
          let bossUserInfo = _BossOption.bossUserInfoMap.get(bossId);
          if (bossUserInfo) {
            return bossUserInfo;
          }
          let bossUserInfoList = await _BossOption.obtainBossUserInfo([bossId]);
          if (bossUserInfoList.length === 0) {
            return void 0;
          }
          _BossOption.bossUserInfoMap.set(bossId, bossUserInfoList[0]);
          return bossUserInfoList[0];
        }
        static async obtainRecentContactBossId() {
          var _a2;
          let resp = await axios.get("https://www.zhipin.com/wapi/zprelation/friend/geekFilterByLabel?labelId=0");
          if (resp.data.message === "当前登录状态已失效") {
            throw new Error("未登录Boss");
          }
          let friendList = (_a2 = resp.data.zpData) == null ? void 0 : _a2.friendList;
          if (!friendList || !(friendList == null ? void 0 : friendList.length) || (friendList == null ? void 0 : friendList.length) === 0) {
            return [];
          }
          return friendList.map((friend) => friend.friendId);
        }
        static async obtainBossUserInfo(bossIdList) {
          var _a2;
          if (bossIdList && bossIdList.length && bossIdList.length >= 200) {
            bossIdList = bossIdList.slice(0, 199);
          }
          let bossIdListStr = bossIdList.map((bossId) => bossId.toString()).join(",");
          let resp = await axios.get("https://www.zhipin.com/wapi/zprelation/friend/getGeekFriendList.json?friendIds=" + bossIdListStr);
          let friendList = (_a2 = resp.data.zpData) == null ? void 0 : _a2.result;
          if (!friendList || friendList.length === 0) {
            return [];
          }
          return friendList.map((friend) => {
            return {
              bossId: friend.uid,
              encryptBossId: friend.encryptBossId,
              securityId: friend.securityId,
              encryptJobId: friend.encryptJobId,
              jobTitle: friend.brandName + "-" + friend.title + "-" + friend.name
            };
          });
        }
      };
      __publicField(_BossOption, "bossUserInfoMap", /* @__PURE__ */ new Map());
      __publicField(_BossOption, "logRecorder", new LogRecorder("recorder"));
      __publicField(_BossOption, "messageCache", new MessageCache());
      __publicField(_BossOption, "aiIconWebpBase64", "data:image/webp;base64,UklGRnwpAABXRUJQVlA4WAoAAAAQAAAAgwMAgwMAQUxQSHMAAAABFyAQSELffI2ICAdFkaRGFB7xEz1IzfWkI/o/AcH//M//Q+/Vv58b1O/zH//xH//xH//xH//xH//xH//xH//xH//xH//xH//xH//xH//xH//xH//xH//xH//xH//xH//xH//xH//xn3L172/A//zP/1NtAFZQOCDiKAAA0GQBnQEqhAOEAz6RSJ5LpaSioaVUSCCwEgllbvxab+mdXpH0Sl8p6xoqh/m/8b+2f7/7in2/++f3n/Of3v9k/QT0rdb/sf5r/H/tGrS88Hx/9f/4f90/t37LfM3/h+o39Tf+T3Av4r/K/8j/bf8t+w3cb8w39R/wf7D/8v4ef83/2P9R74f8d/j/1m+AD+3/4T/1+336of7newd/Pv81/3fXR/c74Rv6x/vf2v+Bj9eP//7AHrifwD/w9Y/5n/j/+D/g/bR5iaaLF23vQc0B9ju8N8259P7JoA73mat90MfJ6P/786v8QIuWBJTBASUwQElMEBJTBASUwQElMEBJTBASUwQElMEBJTBASUwQElMEBJTBASUwQElMEBJTBASUwQElMEBJTBASUwQElMEBJTBASUwQElMEBJTBASUwQElMEBJTBASUwQElMEBJTBASUwQElJfxiMhmc7pNZtByvqFyGZzuk1m0HK+oXIZnO6TWbQcr6hchmc7pNZtByvqFyGZzuk1m0HK+oXFms6UNoisbGHTWDXcgawa7kDWDXcgawa7kDWDXcgawazIjAkpfAwZKx9oisfaIrH2iKx9oisfaIrH2iKuaBRFY+KqasfaIrH2iKx9oisfaIrH2iKx9oisbGG7GPsROjH2iKx9oisfaIrH2iKx9oisfaIrHxVTVj7QHygKCAkpggJKYICSmCAkpggJKYICSl8C9JTA/KyHF7RFY+0RWPtD/9K8KK43HWMfaIrH2iKxsYbsY+xE6MfaIrH2iKx9n8fosAdhAa0DiBDFD2P8h0wSUwQElL4F6SmB+VilBASUwQElMEAwX5VHXCaELyUFstJ7So5BASUwQElMDG70RWPiqmrH2iKx9oisfYidGPi4c/keGtVl5zP0WCSmCAkpgY3eiKx8VVylBASUwQElMD8rIcXtAkQF+cY3Kt1XTsf5DpgkpgY3eiKx8VU1Y+0RWPs/7AgNgnyZKfyB9HcxiTmJ7H/96MbBxk4WOsCdKveX+vHX601KsPdjH2gPlAUEAzjJWPtEVj4yALm0skfLw3p1Y4KVzlHGC58+WO+4cVYoFjGY1H5iWswpa1FjIr+hGrjrGNjDdjH2InRj7RFY+Ec6ZUOF9xhsWfMpw9+yHnqBLlO08Vze1fiwGACpNTZu1N9OqTQRNMEBJLB/PtEUH6fCSmCAYKMXdG54p6aSOHOtMWZWJDD/qDzLQFKJMpiRDb2rKI3wh4e+3RAMY+0B8oCggGcZKx9oifQj2IZ2pFzf33UWuuzu3Y11JJGF3mDZb2AgWjRI/mnckz/ZsJyQvjZvwBV0tyPdjH2InRj7RArFKCAklyU64foxJ4IYHyR8Q2quoLuetgCFgZhHVJqrEq09uyMKP0tRTQ4rcqQk2QnpUHcEkqSfaIrGxhuxj7ETox9oieYjcZ2PYv/02Ko4WodNKrqph8lGLMGO7x/x5MyNlOFsUghIqg1+11U3hI9DjrGPtECsUoICPU8hrdi3d/JMAQGZzuMNvQ5ggSUu8JTmf1InedLMlHendYTKyGbRf0+iv7+xhAlNKuOsY2MN2MfYidGPtD+lzzC9zQpxQ4UqqB4Hf+p/ZOfE+uyY8K0ms0CjEhVBXhyZybOcCxtbe3yxRrV+YDW0+GCSmBjd6IrHxVTVj7P6aMFBS3TZNyz4AfNXs3SeA5TXJX0mVNWNQV4cm8+rle6Pz8maOT39ZqJxK71UASercAKCAZxkrH2gPlAUD8IzYmqrxm3OJ0mWlQHpYmm0PprRbgKOgdbbfl8eW9fXzYaY+z/2l622TCq3FV4v7RFB+XHWMbGKBUwLnaSYu+sghBuLuu0RYFcoum0NG5/VPonAHw4NDRmBYVoLaH6xVNVe3vb5MMP6pVfYf5CIURxLPRx6IFUqT2HqSmlGRGBJS+BekpgYFcUmmhze5LgnGROmdW3K2g9TrvmcZB8nFm2hUp7gT+MI3cKclyhB2xJYgRF+RtgS77Vxt625QQDOMlY+w0oMePnu/PL8YiE2WEltxkuEds0TpqaApcW3l9jLPA6zWEI8WQVYL1E7BAM4yVj7QHygKB+KFZkaVutT5l781yUUxqBEUmELM5hFr3RinFUsvgwqYksthYqw92A/LjrGNjFAqYGBeuro3cuuwLPVTcohHNIBYrJ7MEbc9VjBq+bYtPzj6AVbozC/b5pbuOT/tEUH5cdYxsYbsY+GnQPOjnL+FnoLZDl/aNickBmPCLPJBtY/bU3EnUdvJwPFyOeHHbxd+tJNl/ufbC+JgkpgY3eiKx8VU1Y+wSNp9AtIQXo7zP/kauo6grep/WmjOk0XaDBd/AvhF7fcr0HkhVXaWlBneMwM7ufaIFYpQQEep0Y+z+bZEgduEbq5p30RVhpdVV6cP305/VLndjHwFGujHZPjZlJu3tX2PNDJAUhyiOsiauDW7FzQKIrHxVXKUD8KogqZ8pwiBeK1q/BEEMLL6mhFkoLX+SQIWdD3NITyMU21Ji2dLtAnkx7+D7Ta4RZEnpSU0quqmrH2gPlAUEAuRjMy+5oZGFGe3cNI32VcGvbOlNrF3srPrKoLcqZW9xj2WotbueJsoFe2eBR+hkBbp7DikFQFK++7JIIdMDOMlY+0B8oCggF1XFykuDH53ZyBaNbilrwtwrNnE4Z0lrSm7Q/khkar64zRQOd1+O3VM60NLUbAkpfAvSUwPysUoICS5UtMMHTBPFdxVZ6WhheySuuBgE4cLynmCSl8UAkr+/2vjHe0xvpddYbIB4lLrJJbWVcdYD8uOsY2MUCpggF0UvTMUcrU+K8Y5teeJCp30PpbYOTdFZsyk34/Elzg3U9GP3sj/KccoHJZsiyBAPlPiw1XKCAklg/n2iKD8uOsY+wTc0naxm4tBcSvC0VwGliogP5ASKKdDaT7mPECAZamG7OiZleQFU0rzhjqO3iwY0D41uKCggJKXwL0lMD8rFKCAkpiTHNNJ66qK4+hXxEZU394g0c/oisfYUP6dWv+9+XQUKo9h6J/HWpSDW7GPsROjH2iBWKUEBJTBR6E7x4bILB4JaLr/7aMkofPzlY+duoHg/Zy8YUHYv/rtouSfgVm5iA64wmUpggJKTOf9oirmg99q46xj+anqbDy+AqGtn2YNjH/0StCDJnA0XjtklSgWUG+M9yvC9oisfaIoPy46xjYw3Yx9oisfz+rEgJjBk9bUsm46xmVogcAIarYVeMT27xwsY+0RWNjDdjH2InRj7RFY+0R8x1EbEfrtZSnk5Fl6XYxp6vjMr2dyiCsXHa06xj7RFY+xE6MfaIFYpQQElMEBJTF3CM7wabmGlDKxtVv00Pf9iFLpDmC/eb1Nsx7QqchYJKYICSmCAZxkrH2gPmYkBJTBASUwQFCqCAkpggJKYICSmB+VilBAR6nRj7RFY+0RWPtEVj7RFY+0RWPtEVj4qpqx9oD5QFBASUwQElMEBJTBASUwQElMEBJS+BekpgflYpQQElMEBJTBASUwQElMEBJTBASUwMbvRFY+Kq5SggJKYICSmCAkpggJKYICSmCAkpfAvSUwPysUoICSmCAkpggJKYICSmCAkpggJKYGN3oisfC/IOmh9C5DM53SazaDlfULkMzndJrNoOV9QuQzOd0ms2g5X1C5DM53SazaDlfULkMzndJrNoOV9QuJNqQjRpVx1jH2iKx9oisfaIrH2iKx9oisfaIrH2lOASUwQElMEBJTBASUwQElMEBJTBASUwQElMEBJTBASUwQElMEBJTBASUwQElMEBJTBASUwQElMEBJTBASUwQElMEBJTBASUwQElMEBJTBASUkAAD+/d5wAAAAAAAAAAAAAAAAAAADE/iXX5fHO9IMfMAUUVzlnHtwSpcD+fdQZChDUQEQ/VZmWBWBxdkHxh44p6B7ytlMIh+qzMsCsDi7IPjDxxT0D3lbKYRD9VmZYFYHF2QfGHjinoHvK2UwiH6rMywKwOLsg+MPHFPQPeVsphEP1WZlgVgcXZB8YeOKege8rZTCIfqszLArA4uyD4w8cRXBVYcN/hDdAOjqRSeoHYRwEAAAAAAAAIdfgRctIAAA+nJs3QAAAjA7H9eQAAAxMcuDAAACcQyB+ivAEvQcCfto0zl6o1JS9dpFV7jhjr8oTdjpXtYSjtj17aMkl1QEER3KB64Iqll8zYAjmjHjQAO+ztVUmhqs2MVhE45gtaHlsoeXq+HWD+aEQMd18fglaDjaTEy6WurpKSmIs5Sb2g8xvCdefOmO6vsQPQ02M05nIU6pqkN1MRBAok4S2v4+q7hxkhD0Yzat061LBlk4gnfdGAlZV62IRAGznnzmASWudZ3vEFLXGw2T7LGdv9uHKeDB4R2Qq7FfRa9jiuyynM1tv4fgvlMUwjv07clh/H+5hS7UYdieQ724MCzjo/TjZNztAV4T77oJHV+DJeB9H8ArAHcvHjsAXzEG87ADYVgVf3+fvh00MefoZjTa3lwIGU1Ry7FaJCHoxm35l+8W+9+zEaLNSW/xojEt1lEEFFSg/RXgL4ySXk2jaQpeB8Omhjz9DMabW8CFEj5v6UrA820Apx2uo2KoEZLs3yid0EVafUOIOk6CIcpdoBnwDgJ83LwfT5f1t37cAYQJMOtnvhBoDTkG9Bo9CiwQzz9aIMdMPZpc7hXqLLd1778KsHy2T09/kikwcWaXuDLnFqNq8LVp3QHeim22rSK72ulVwzmePp6/zwz3kb8prPO6gN2rWrFy4XCCP/qj0L6og9s740yfKTwbLEcV/WXtHfD44GJLVpZhrZyeJ264KgVFjNaJxzTvQgs4pPQzGm1vLgQMpqjl2K0SEPRjNvzL94t979mI0Wakt/jRGJbrKIqkMf15BSSRYuckuWtwWuZxJPPo+W4tbW01v60oekNM55mwr47jWrnTz4zyciKLEUgH/nkRAF3gWKHzPSL/gQOOt5dqqIUjt2IdwRGtvWqSbfWFQNC9w+DXelyZ47A4GiPi1WxuFLvZIR1/R+vH7iSJsN2DrCWwBSiy2vZf9O18ZoRNca3R++TwbLEWJA6uIE0u0lJ23O3yuERu00TXURCxk6e4BtnrHw6aGPP0Mxptby4D+HpfNyU2ox1E6e+bc7QFeE++6CR1fgyXgfR/AKwjmjHWcEYEiNMyzc9Ri/T0tvl7bHST4TNsoGKDc4npkaRWKiiFfBdbdp+lxE4+UPDDsn/6+nmH90MBe98HNfSNKEwSoOyeTgQPJUrfWYC6OOlI9/OaVd3HEa6sN+3Z0a1PdD4sP9Up06+AkFDMTmXfu4757xNmExjBNjw/PYhc65OmTVqe4KgVFjNbv0yJ/Qy3ZSrb0ITBYeA3vhnO9ybUpXfyk3ASfT3NmoIN24RngT5v7KDCjKtAJHwsgforxoS/Lx7B4zPDfdm3938PQai6ipggHDMI8TOG3/vm+DGzcO9TsDab/RblWhqyLj6SdRy/PXm+n3Askir9bK+mslMz4448DcG1+l2rH0xRZlPjj7NIWuAjoKALzYpzvq2G5mkEphV/Ku5/uzb6b0haANm5J/BVDuyFhJ03kJQTaZRwba8i1QnCkk+tpLmDWDI+9+A+M9Ab73VA2lVIpfIJ2OyrrlGQQv0//CozpR04jUJfDxx6cRGWDdWXWz23q0EdYjjuXj2FDU1q4hu8Z08Np2qoOn+KmjrDUN490KxRHvLvolH3BdwHT/6dt1cMjlrLdysAA/rItgOnr9lOxYrKW2o2Kl//O9OGRWcC9SWnc1YT342jRcmA0o1MgDRrhaxdc1dAPQPFTjEuc/Qk515B6PAdw9Li6lxM0dkZXH2j+aXbVjRY4B96GyL6lAJ6N97qgsVZ5M+Is686eMTGJ+lkkBZCf03PG+91QNNYgVzCOoF7mBaRmcQ4B6D2vMzjuq1QboOdHZF9jea5UF7ZqdG4N82LpZlf8bX0pxHFhGai6nxUcATVmhL+MtN//25GGN23pK1srwBIBgOS5jPRjPnMJYbnE8cAq5OwRenYUnMdk91Du+sMPoHLJb5CX/FfbmoTPANTfzZaYeMIJ04U13FBrIdVQKY8IVczK9QndHgOvEiifBm37B/VMHt3ZNwLW92OWjsuIo78os9P+viVf6RpQKVEzqFL/qxIt+VY0NqXfGlXmmwvJHJ0x/16Ug7z+A3bxYD/I7Fsf4ZtpSmMLRlMZeiF97qgsVZ5M+Is68w6YqE1Bn8O+XzwfzVJKlpqC5x7DpioO2dUzjsDW8HG2Yqp7MyCZz7aRvUHkiiDv/SBrf6baJEcmphaUo/K+ogPDsHA7yrp/odwzlCosenxopjjrGDFqegxFlYSvqUZzEwx25S2E7qKduPr1k86N90OMW6vwq+Lr4tZyCPlQpywrfMJg+UYM+yJZZ0SKYb0J+jB5nx28VUSdY0JTnmuX0lKreRO47p/IgusQX4mDwIi1U7inZfxRzhotV2Rpt7E4MIU6EBoGbDNeT45Wd+cogflxBSTUGSrKk39SWXF6ywjBDvfYa5TVLC5nYKaOC1w7O1g5CnqzRMFLDMtVtHU1mh+4IUeLCcuiKu+XCvHQ0dP3Qy9QU+dH0MoyaPAvleKhoF2LuHxzFbiwzsqLDmxTHd8Mfr2Ra6K8Jck37lu5gFol+Y66iVrpnRBbGq/Nd9TS3SOrfBa5nxJUBnfeDx/9QDNfzpGulXB4LqvU5cKB9cmsJJ3uyn3NeV5p5PM8LUcd0bAbPnW1c38RVqNvm6lOAJqr5zqoCf8wszcSAzk0agr8wbA/0V3W7+ZE8BL2WG/A9FSpdBXCSS3KgnLFiF1rI6GqFfS8VDQLsXdNhwkZrhtSgBfsf64MWp6FXpdOOsU9BM59tI3qDyROGrx0R0Ym6Tehl6gp86Pnw7NkwsihqkRwKOzSooAguSTjQ48ECpaHIR3OTgp0QHnaTRtnrLdlTjoQ6cRmJcXHM/KGjkpbqxmll7mhgKZim6X5aFey7SE8g5QEhNDJMKWogf9oCsdM55PPPdV4PGYJQRYudqB26P/pg2KpCA1yJw5Kfal9x/xnvy3qB6zBO5Sg1gFFmbcH8c/POcxlbXBbC7+IaNrJPUBnylF2utI1L6Q2En1x1p6M1tooetr8wCHETK4CJvnlo2Jw4S5+jjaKSmOQWII4JbqIELiHP5h5IhskxHGL6KEdvdskGFvmN08taeLYLLfdGPMV09bCM395YtERhMoOR/lv+Ob4nIbMhtknXF49tkXwTHAvJ4qvHFClN6UIEZnnKwDJMzfIvnOvKodT+/cxIGfGWf7GLHAvnM7w32U9vLVNoMkh2a0ZFo51V2N08LknJJxhjysseDHDJYINWH1uCcC8U+Raam886kq0buX0j/j9HX9G51ryZs4/lltvc05H+pinBFek04+QIQ7qrsb4jPEURRHQRQf30iYm8QmsUwthg8NZ/s6GL6XOjau3RLYe1pVokh6BZMfRp2sguJkEUV9IbCyM2NLC1BW3Wm4wPBofsOy7yUxvpfSGwsjNjSwPwONaHkl9tz0VPY9Uv8r3fpJiDlw+E6VgtNTVea9WdukZ+2mpH6f5xPEcKPNpNBw0taZzPYmsGQBCiSqqokeyNORSe65Uo1IThXbx7e0XfaPlO4KTNjm+FSUQtcqP4JGLrCbBH/Bo4masAg5lNGA7LJpjgaZt6yRFgisBvUzk7rW4zMQbiyU0/izUv1OgIQojpOhRjehfEQrcKnXI9EPd2GllgzzoAAmrNJ9LceNL8r5xzD57NKu7i32IRKWWMKKDZbHqmmWc6+P0Tco15JB0sOJZanfs40RL6C/Aq57VEgW1066GZBx2s6XyW/l0QsWacPERgig+I1cVccV2FPuXIAU9DR49UEnqDjwDmt+6WKvfXCHU3Ys5b9HWwV9iyYV9DMhvpDYPpBUZK5BOySx9JZ4SLXjlc8NiTbIBeEy8SmF7wbTKcuefrhRu5gNadEOM4oxQm2RaGrI9sg+L2xrxDdqHQRIn+aUQ0gLL8bxyXsiCD1jf8tYRctX32B206SlcRNnZmTqeIVRyi1N1orWT/gSjf+fybOKX4zKi8U1QSDlMa03LwSRekdMmFvC4rO3PoAZLX+FMbaW2fiM0fk7ETMLF8rIfpgADRJPxgJBz8rRN71Jni8NpWJQN7duTt2Pt8OOWRDtsSD182BLk+2xSRjJu21WDjNSGyO8usN78TJR7G5RRDt1FvVQWnTsAPqM+iyq54qIebmyh+MSWD3hfQ4yf1xyIJuZbe3foWk4wlUbzebBt8zGg4FxRFuPII9ArrbhasxZBth8DYxetCC6ksqjfUo+gG23oVUtFu2/6IqClfbJ/Pv4X/i5O9w8XabnNL25q3ZjdC0/oyn7rH4XxkhtWMVzlXmbJ9kVsE7eYiUFKdOwr5P3ej+dBUB4r6bMhjaL/38wLcxTbFred3mtwuYD9YcMuD0w1Rf+AU7G89xoqYfez/IN/J6I0D4kb4zZ0wLcxONA9UGmfV4Au2bo3bLMkF0qJWhKdoTHc0CU6AjaPVCTp6JQ3RAVav8MPPYQJIRK6BJOBZQRRa+My+jlgX/1KR4uw68aKIySGk8OQu8eYvQqd66qLi6vdtvaXKtZdflO10XMwf4PCZ1PqphFseIyXHsRDJwtTOHTMeC9JtP6cTt4+Xo5woIYJp7DVy/lpHHpFF5+bfF7y178aV/MH7GFEx+O5Izwj/vfoR+dGC6+HFbeJ4dJnv6LsK640kznwOTXfTBtIHZ4k0Mw2bdxHugmUcMIc1lYexMC80AjDAgPtGXe6zNYLn7/oMoBgpEEuUKV/L5aV4oSFq8T3XX+iTW5HNV4QFxjiVDVeBSjtybxKaOI1vUpZDOtIay3rYxnh6lXCkSBg7bK56hmwosiTo7Z68Hu5N7SfXIybJbgBKRxY+AAe4tIkSiigKf3JZSctRPA9VfBdvT7HF/g4FgiqNKNTwD9va0iDwsMNxO7Lg+7jYvsHSBCGPe5EHlv+kM6IzL8qvfaZENQw+sIrOgDX3Mq/Yg9G3TDjPSszokq0mf0hGqKK7j7AA1CAfNvUpnj1zVvpqjw01St7DH5mSc7dRdcqYFv0oO2nNF9b7K42pEhTf6ekYfC4PAD+XIP0WDoKSC6Gf4G7n0J7LVlIRyNjK/AvHL6Qbrfz2/zDYyMT4fm6NaSytDX0L2kvjGEN3iyEO5fTUHGtc1hm754SlDevRAMXZISu9LgxbL4yX1RAhJLTnb4E4+CswvYTxck2eWIGcuTg8F3TkAFZzRt7MpPTFBceHNI00HRpaZCP4YnknSu5cUX9+RBbXooukMeNFvntjBQIj0mc3L5ULkCLizNaqnGY92eW2RfENFvXDx2Mm9RQEv/H1JRd15LB6QTuymYHox5YucSUzRn4McTKDc5ypB1iaklft5dmkTqiWAfGsLuA4wnmadeDrWUZllwMRUmVjwVjooyfVe3EcJyCpArBQ2XpWJ6kbbEvVukCLsC6CNWoSHcPq24tZs9KVxVkItLqSqP9mhynuXqxaGWn6Gz+An6kQFc4eT+zXW7MEamUyhbQUN2ViTCMIj/gCygadX+YWhXne//Tm+3tT8LaHCtOgK+B4Aig7H9ear/NallvQNUq18BPb0Nl4r8knWAumOZC4vyM+zFUXa0Rs01izxhxSUJWj8J1ZoqiLVfsW37aQwMuYqrA/YUh1TsScTRgSGGArcl7HfhrILZrIg8cbIWabChnzVxfJvAkxhBLIjUiOlghqbS667ccgS3IPW+wj6SdVKmuDsMkWVKvobIlDSSOpZddk9Gl/yDhKN57FG8kzMcBelfFV9mjK3BMRHW+7FwA1l7GVrEwgQr7fFbwF2yML+6Y3Vt072gpfUOnyG/nlwb9SrV1RV+mK0Fva6CSkqMCevVyE/ZjiSo+1ReVLdm9+9yTd790vghdvI7IZREoWEIAgNDVgNx/DVoOz/2GJ+kn1AfZ0QMl7TtbwKG7ifskokSUw2n0j25Utp5DdxYqHk0hF+JWCNAdeNqYne6kmu4luyKCejAKeTiN2sTqtu5z4dQbyXiO9jB7EgVG/3zJSxKCMq1cMVkGOg3a5hbWdRcvkLcMrCUTL3OQbNTMrBNJBA647hGINxCFbWXbAP930UONOFf1d8NZPh+pKDVrTl+ltU2oIGJDVeMj7B9pN9zWasDLdorGch3cWaGQP0WAfcIcpDKtIdeJ37n1OgOsqlR8SxPwXxiL/G8/Kq6Yv+sKKOHIeYwHuWpp1IQNDfzAYoAIEBxbhZfKFsFTRXpzp0Es0ojU6uzbj3IzMkPqDqRAm5oA4sZr1XyG7DPleeaEdY1u0mDH1H0rp2t3yXAvwjBTE/W2vI5UXkXL7O/mSxWSLFJPUwrSeAH+gW1ZzVojMicU7cJP1YnGoGZrkLEdsjt7DMJDiuIlXNu1TVC0l/ZiLZxoPamwv8ukQQxPP+noH3daYgEVulsHwdXnkOXsJF2zk/77tnZlAB2+0/76OK6ZAzEqkSvGy6wep4EjXk8lEbn30dWWXU4bXo08yzRTKXTOXaN/SujTLWS8n7jUGx0O0AFaGLAdQalVWyix2j0sZ6dxHuP7edbIWJMZwWWFhsNJAMheZW4OHb2ae1NCpMESuGRBafKSJfUOPVCjp/sOeKzOqeyE2sX/Fbn/Gy7I7IWwDalAJx58qufN5MrjzkeJjhGvulen3HuBxqXachpKPpGKacpGDvGeER/rhp1XH1e4wg9fe+Y9RFGHnjxbmtO4ligotSqbHa+LJnlGTvqHixGd+2Qdgna2PLaWqDlMQOyNKsPSxx7Gq6qFi6CadQEKzXa/2KFxSnnuYifkaRrkkwDsi0Mg80666KNIfDGI+u8zICjGFLfd+8xrYqz5Xio2g4v+HoZl3k2vRGn1jd0IueKm/PqGgol5CRahNjZsasfaGK7AMD9EQqScE6Uclin3o1FVzAKXMGKxDUXF3ShrfyWXFZU8h1GznnzmXTVNG/7m6bcIfYx++4YwxW31S5mREuz7r/XeY5jxjnHb/9tVdYMxz01nRvMLMDg3/XvjyWXTvD7MBOdn4JeI1H+Muc2KNMEKZB78OUusQayA05gQvfutClu7e+V7s+VxNd8gAA7p3dd+n9peuyNTH1uYv1fWTn+MxzT6wwzTEzX/hixCVSgCvqlGCVASuxMrqUcVHIRo9OsWPU5A5j22OelnA6P4OK45/V9q7FK8OpyVgGQI+8J+Cg4uyS7QDhW/i1xrbVTMJL8omDKsEfRN3aX2exjR69Wg9l48dhk+6J4Gi+9vXIQ82Ffyuv/nKKtwhAx2K/PT+MNfGygyj679vcrpQSusw1zjxx4Y+Xhqrp+cV7PSpG8LPUf0/dsil8OR7ws0Zj6k4Q01PFYmes/z8TJhObfx+rFQQSbF5YEMHH8sW00VG8hmXDvdZiq/NxIOPXvnE04f27A8l9uheOkFArwRWJAirjqOCuqezPv5IDqLLJPgJjM4tKctFMEgtmFkkwwf5cf0eGiGoSZZMHD/WI0Sgov3xKyqGgryF1CRGtJ6G3eOB1EUn/8ii6VICgMAOWBH14Hr1J19euF2zzy1fzytilj8We9VbAOJyrCiC2NbGYEPekkS+xg8U/FejqBMIRYDHS4592d3Vji2q2wZO52Z4UPlbYrHsE3Gzzm9MsFLkdVzcUZYKXExC1TD7tLl6iVbTNvhHvk/UVx8v22IL4ENG8YiaN2VVv03qa+RqbDUjGbDp4dfT9AhIz4tsdnF7SiYL2MxTeakH5Z1JbIb6E76LYK1/jXa/syMQaxQjrux2sfw+SXoG3amLvGQFX1V8j4cluWH4t6wPqhcIMux5V0po29f2ZK9Sc+h4xHJkT8naKgguj14opk0fmDh/rEaJODQ+UEiZ+OtwpWg11KNrxGuIsTMFKN5nQmCS/dD3QJIljUSJAe9zbcElUzvL+AWQ/g3G//6QJ9pHPB6uSFs22a8q/aQCQs5doXzSgN0jbuY2KBN57RCY9iatfqBl0DYCNXGUQcKv/7+1PZ0YfwSevMQrpJNI5MDK5IVnzpRiZcQ6m2iPzH933/PFhFZw0nkEuz01p/ikWBgRtlOepJ+pij0kx+bff7epkn+kEY9Fds2sv6wylATbglow66e3U7xvvJhYehDF3dbFWsOOiN4XAvmHAkPWwYze3igfXND8dAHRgHDNt64t79oqm5Tedu/R25x8a1SRLVAgpLdcO5cPEF7HN1UISuQ7lJYSIudBnxH0nKxf+V0npJcVgRFcdc+M7FkZGm0KhO+bGFUOsqK9QZXjVhu1QEA9bbImzk3zmF1u8y9dhLKPCC8IDwsvbg6kkc720pmsrc1PHYZrRvdTEubGYUIve+6UvPNVuECWGJUYMCxmvAAt/QFH9ssRiG3aZXHTONJiv3lZvJY81Lk1iKwq1rnlhf+iXm7JjLF+UffnHg1Zofs9JLODBI+2TzOBre+/cvYfczYQvk5555fz4zFOVAhSVscS+YbLe3NABgkyVEeAytIJBZC3tCfTriQvy6OSiB7mduC96UWsngiOAHZlsJFOFwDygWTpFSHTcbbQ5cGFUOaLwI7CwDuH4+iTyehZe20i+51U4aEm6QdzZjDMdp2ugQAG5seGBBO+99QYg6q2S7YMdLR1zbOaPvcIaZ5CxoCzh/WhNmzA5jbBsOoMnAaz95DJsrAIyn0CRWcdBrNxo8K2Zy0r488kjatCn7dLFdzhCQCkwI0QocTr1Mjp8vdRJVyZBVbbqbhaR46Ui8KjNwQzbc/NUjNGb0wgrLvV4tfYdT2tEGmFJPeJicnBwPRydpt2+MhGhqVA5NhiEtm/rKWT5jxr5qa0f4aV+1OEFNzHTNgfydgB1gEA1gYuw8rXfK67rU3dkN0ji06eQ9L9eQek+Vtj/WpPSJSr8mCFFZawxdVUu14qFtoyo1CKI6gi5aRJLYiUo9HZqoDdRsF2UWvh5qk3zHWXuALm0M9Q6hDOyXLbk1R3SNW1kmIytMPQjoZq1ZVAh1Fx+pViMylwlnBKx/y6Uhx/vl4ve5P+AqwnUhZeRYf5KQ6CgiRTfMh56aWsmxVWeNq0eHaA8rDgUwCwyF9QWrvzk3fM7nNBbjB2Fz0AsNDtHYxWXzzlfjCcxH2IXkBtLx7CgUsEYV/YkxGUMAIl3/UlLMJ93+M7h9mRgfeq0oY8T44VePDaYm7PM799ImRIevZk/cmaT6rxcE4M4KmVzvL7VXEJLqp48mgEhSmpc3V3xdY35aDDf94pmrMd29mGlm9GKxlmL/iiZqfL0eEQbmqsGB9J54+uSAPvTvCh0DvcRfMSFyJgBS6Zz4GgJR7Haar1KCp+JtRKjnpgC/9gVUy+cJJtEqteIjlfCFihp4yVZojii9nGhjM+l06ZBn8ao2itcFy3B+IjsMQ7B/vBOx/dqAa7tRcIl8QMlnkPGRWjSdtdiMgYbOFCwuGQcbWviFK3rTRK8XQeCDBFQGBLsXB3eUmJYDKx4BYA2Kwq7xTH7RyEoyHPq7jWFWQLly5y6rBi/8yB/CrsZw0GWBs9yKsZnZwMD26E+pHURPqsKSWFingDAkrYTugAvDlbVtfkqWRvasTZsU1Sen0w+CqIMYNhwJuk5aZPV63/46yGkD88gkEXj/+yRO9kljJhQnqtMqqaYlS+Oojx5ruzkmzFcI/hyBwlvCl5wC5JZloZTxHM5P9hLJQqAtfwFtFLROmXvP+bqtCROpGUMdhzoPOk3HOlY6KPUqtwlSZvreBMC6ozOu0RtR3Pk8DTPTRG/TeIB0vgcbn5hZq3ghh4LaKPoPDfukycBH4nT9jdv8UNxgAKpDIH6K8AAAEFyScaAAAAinKfA0AAAS5ya4MAAAIwOyB+ivAAAEU5S7QAAANBB5BMm22DP89YldIr99AhKx880s7zA1lneYGss7zA1lneYGss7zA1lneYGss7zA1lneYGss7zA1lneYGss7zAIfmacFGvZG57wO4AAAAAAAAAAAAAAAAAAAAAAAAAA=");
      __publicField(_BossOption, "template", `
<style>
.chat-container {
    max-width: 1000px;
    margin: 20px auto;
    font-family: Arial, sans-serif;
}

.message {
    display: flex;
    margin: 10px 0;
    align-items: start;
}

.message-user {
    justify-content: flex-start;
    margin-left: -70px;
}

.message-assistant {
    justify-content: flex-end;
    margin-right: -46px;
}

.avatar-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0 15px;
    width: 65px;
}

.avatar {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    object-fit: cover;
    margin-bottom: 5px;
}

.user-info {
    font-size: 10px;
    font-weight: bold;
    color: #666;
    text-align: center;
    line-height: 1.3;
    max-width: 65px;
    word-break: break-word;
}

.content {
    max-width: 80%;
    padding: 10px 8px;
    border-radius: 12px;
    line-height: 1.5;
    font-size: 10px;
}

.user-content {
    background: #f1f0f0;
    color: #333;
    margin-left: -20px;
}

.assistant-content {
    background: #96d1d1;
    color: #333;
    margin-right: -20px;
}
</style>

<div class="chat-container">
    <!-- 用户提问 -->
    <div class="message message-user">
        <div class="avatar-container">
            <img class="avatar" src="{{user_avatar}}" alt="提问者头像">
            <span class="user-info">{{user_name}}</span>
        </div>
        <div class="content user-content">
            {{user_question}}
        </div>
    </div>

    <!-- 助理回答 -->
    <div class="message message-assistant">
        <div class="content assistant-content">
            {{assistant_answer}}
        </div>
        <div class="avatar-container">
            <img class="avatar" src="{{assistant_avatar}}" alt="回答者头像">
            <span class="user-info">{{assistant_name}}</span>
        </div>
    </div>
</div>

<!-- 变量替换示例：
{{user_avatar}} → "https://example.com/user.jpg"
{{user_name}} → "张三"
{{user_question}} → "如何快速掌握响应式布局设计？需要具体的学习路线建议"
{{assistant_avatar}} → "https://example.com/bot.png"
{{assistant_name}} → "AI助手"
{{assistant_answer}} → "建议分三步学习：1. 掌握媒体查询... 2. 学习弹性盒子布局... 3. 实践栅格系统..."
-->
`);
      _BossOption.loadRecentContact().then((_2) => {
      });
      let BossOption = exports("B", _BossOption);
      const originalWebSocket = Tools.window.WebSocket;
      const TARGET_URL = "chat";
      const logRecorder = new LogRecorder("hook");
      logRecorder.info("---------------------------------------------------------------");
      logRecorder.info("WS Hook Start");
      let sendInterceptor = null;
      let receiveInterceptor = null;
      let hookMap = /* @__PURE__ */ new Map();
      let hookPrototype = false;
      class WebSocketProxy extends originalWebSocket {
        constructor(url, protocols) {
          super(url, protocols);
          url = url.replace(":443", "");
          const shouldHook = url.includes(TARGET_URL);
          if (!shouldHook || hookMap.has(url)) {
            return this;
          }
          hookPrototype = true;
          hookMap.set(url, this);
          logRecorder.info("WS Hook success ", url);
          const originalOnMessage = this.onmessage;
          Object.defineProperty(this, "onmessage", {
            set: (fn2) => {
              this.addEventListener("message", (event) => {
                if (receiveInterceptor) {
                  const modifiedData = receiveInterceptor(event.data);
                  const clonedEvent = new MessageEvent("message", {
                    data: modifiedData
                  });
                  fn2.call(this, clonedEvent);
                } else {
                  fn2.call(this, event);
                }
              });
            },
            get: () => originalOnMessage
          });
          const originalSend = this.send;
          this.send = (data) => {
            if (sendInterceptor) {
              data = sendInterceptor(data);
            }
            return originalSend.call(this, data);
          };
        }
      }
      Tools.window.WebSocket = WebSocketProxy;
      if (!Tools.window.ChatWebsocket) {
        setChatWebsocket().then(() => {
          setTimeout(() => {
            Tools.window.ChatWebsocketImage.init();
          }, 2e3);
        });
      }
      let hookReceived = false;
      function hookExistingWebSockets() {
        const wsInstance = hookPrototype ? Tools.window.WebSocket : originalWebSocket;
        const originalSend = hookPrototype ? Tools.window.WebSocket.prototype.send : originalWebSocket.prototype.send;
        wsInstance.prototype.send = function(data) {
          if (hookPrototype) {
            return originalSend.call(this, data);
          }
          if (!hookReceived) {
            logRecorder.info("WS Send Hook Start");
          }
          if (!hookPrototype && sendInterceptor) {
            data = sendInterceptor(data);
          }
          if (!hookMap.has(this.url) && !hookReceived) {
            hookReceived = true;
            hookMap.set(this.url, this);
            hookReceiveForInstance(this);
            logRecorder.info("WS Send Hook Success");
          }
          return originalSend.call(this, data);
        };
        setTimeout(() => {
          if (!hookPrototype) {
            logRecorder.info("WS Send Hook install；wait ws send");
          }
        }, 500);
      }
      function hookReceiveForInstance(wsInstance) {
        if (wsInstance.onmessage) {
          const originalOnMessage = wsInstance.onmessage;
          wsInstance.onmessage = function(event) {
            if (receiveInterceptor) {
              const modifiedData = receiveInterceptor(event.data);
              const clonedEvent = new MessageEvent("message", {
                data: modifiedData
              });
              return originalOnMessage.call(this, clonedEvent);
            }
            return originalOnMessage.call(this, event);
          };
        }
      }
      function setupCompleteWebSocketHook() {
        hookExistingWebSockets();
      }
      setupCompleteWebSocketHook();
      function setSendInterceptor(interceptor) {
        sendInterceptor = interceptor;
      }
      function setReceiveInterceptor(interceptor) {
        receiveInterceptor = interceptor;
      }
      setSendInterceptor((data) => {
        logger$1.trace("发送消息原始数据：", data);
        let wsData = decodeMqttAndProtobuf(data, "发送");
        if (!(wsData && (wsData == null ? void 0 : wsData.messages.length) >= 1)) {
          return data;
        }
        let msgText = getMsgBody(wsData);
        let toUid = normalizeNumber(wsData.messages[0].to.uid);
        if (!toUid) {
          return data;
        }
        logger$1.debug("发送消息解码内容：", msgText);
        if (msgText.endsWith(Tools.getEndChar()) || filter(msgText, wsData)) {
          return data;
        }
        let bossUserCache = BossOption.getBossUserInfoByCache(toUid);
        if (!bossUserCache) {
          return data;
        }
        if (msgText === "start") {
          let bossUserCache2 = BossOption.getBossUserInfoByCache(toUid);
          if (!bossUserCache2) {
            return;
          }
          AiPower.updateAskStatus(BossOption.buildJobKey(bossUserCache2), false).then((resp) => logRecorder.info(`[${bossUserCache2 == null ? void 0 : bossUserCache2.jobTitle}] 命令启动AI交流：${resp.data.data}`));
          return;
        }
        AiPower.updateAskStatus(BossOption.buildJobKey(bossUserCache), true).then((resp) => logRecorder.info(`[${bossUserCache == null ? void 0 : bossUserCache.jobTitle}] 手动介入关闭AI交流：${resp.data.data}`));
        return data;
      });
      setReceiveInterceptor((data) => {
        logger$1.trace("接收消息原始数据：", data);
        let wsData = decodeMqttAndProtobuf(data, "接收");
        if (!(wsData && (wsData == null ? void 0 : wsData.messages.length) >= 1)) {
          return data;
        }
        let msgBody = getMsgBody(wsData);
        let fromUid = normalizeNumber(wsData.messages[0].from.uid);
        if (!fromUid) {
          return data;
        }
        if (Tools.window._PAGE.uid === fromUid) {
          logger$1.debug("接收到自己的消息='" + msgBody + "'");
          return data;
        }
        if (!userStore) {
          userStore = UserStore();
        }
        if (!userStore.user.aiSeatStatus) {
          logger$1.info("AI坐席未开启结束-前置");
          return data;
        }
        let bossOption = new BossOption();
        bossOption.handlerBossMessage(wsData, fromUid, msgBody).then();
        return data;
      });
      let userStore;
      function filter(msg, wsData) {
        var _a2, _b, _c, _d;
        if (!userStore) {
          userStore = UserStore();
        }
        if (msg === ((_b = (_a2 = userStore == null ? void 0 : userStore.user) == null ? void 0 : _a2.preference) == null ? void 0 : _b.cg)) {
          return true;
        }
        return (_d = (_c = wsData.messages[0]) == null ? void 0 : _c.body) == null ? void 0 : _d.image;
      }
      async function setChatWebsocket() {
        logger$1.info("build ChatWebsocket");
        return fetch("https://static.zhipin.com/assets/zhipin/geek/socket.js?v=20250313").then((res) => res.text()).then((code) => {
          let str = '\nTools.window.ChatWebsocketImage = ChatWebsocket;\nconsole.log("set ChatWebsocket 成功", ChatWebsocket)\n';
          code.lastIndexOf("\n})();\n");
          let modifiedCode = code.replaceAll(/if \(\"EventBus\" in window\) \{\s+EventBus.subscribe\("CHAT_SEND_TEXT".*fail\);\s+}\);\s+}/gs, str).replace("ChatWebsocket.init()", "");
          eval(modifiedCode);
          logger$1.info("window 挂载 ChatWebsocket", Tools.window.ChatWebsocketImage);
          return Promise.resolve();
        }).catch((err) => {
          logger$1.info("window 挂载 ChatWebsocket 失败", err);
        });
      }
      var zhCn = {
        name: "zh-cn",
        el: {
          breadcrumb: {
            label: "面包屑"
          },
          colorpicker: {
            confirm: "确定",
            clear: "清空"
          },
          datepicker: {
            now: "此刻",
            today: "今天",
            cancel: "取消",
            clear: "清空",
            confirm: "确定",
            selectDate: "选择日期",
            selectTime: "选择时间",
            startDate: "开始日期",
            startTime: "开始时间",
            endDate: "结束日期",
            endTime: "结束时间",
            prevYear: "前一年",
            nextYear: "后一年",
            prevMonth: "上个月",
            nextMonth: "下个月",
            year: "年",
            month1: "1 月",
            month2: "2 月",
            month3: "3 月",
            month4: "4 月",
            month5: "5 月",
            month6: "6 月",
            month7: "7 月",
            month8: "8 月",
            month9: "9 月",
            month10: "10 月",
            month11: "11 月",
            month12: "12 月",
            weeks: {
              sun: "日",
              mon: "一",
              tue: "二",
              wed: "三",
              thu: "四",
              fri: "五",
              sat: "六"
            },
            months: {
              jan: "一月",
              feb: "二月",
              mar: "三月",
              apr: "四月",
              may: "五月",
              jun: "六月",
              jul: "七月",
              aug: "八月",
              sep: "九月",
              oct: "十月",
              nov: "十一月",
              dec: "十二月"
            }
          },
          select: {
            loading: "加载中",
            noMatch: "无匹配数据",
            noData: "无数据",
            placeholder: "请选择"
          },
          cascader: {
            noMatch: "无匹配数据",
            loading: "加载中",
            placeholder: "请选择",
            noData: "暂无数据"
          },
          pagination: {
            goto: "前往",
            pagesize: "条/页",
            total: "共 {total} 条",
            pageClassifier: "页",
            page: "页",
            prev: "上一页",
            next: "下一页",
            currentPage: "第 {pager} 页",
            prevPages: "向前 {pager} 页",
            nextPages: "向后 {pager} 页",
            deprecationWarning: "你使用了一些已被废弃的用法，请参考 el-pagination 的官方文档"
          },
          messagebox: {
            title: "提示",
            confirm: "确定",
            cancel: "取消",
            error: "输入的数据不合法!"
          },
          upload: {
            deleteTip: "按 delete 键可删除",
            delete: "删除",
            preview: "查看图片",
            continue: "继续上传"
          },
          table: {
            emptyText: "暂无数据",
            confirmFilter: "筛选",
            resetFilter: "重置",
            clearFilter: "全部",
            sumText: "合计"
          },
          tour: {
            next: "下一步",
            previous: "上一步",
            finish: "结束导览"
          },
          tree: {
            emptyText: "暂无数据"
          },
          transfer: {
            noMatch: "无匹配数据",
            noData: "无数据",
            titles: ["列表 1", "列表 2"],
            filterPlaceholder: "请输入搜索内容",
            noCheckedFormat: "共 {total} 项",
            hasCheckedFormat: "已选 {checked}/{total} 项"
          },
          image: {
            error: "加载失败"
          },
          pageHeader: {
            title: "返回"
          },
          popconfirm: {
            confirmButtonText: "确定",
            cancelButtonText: "取消"
          },
          carousel: {
            leftArrow: "上一张幻灯片",
            rightArrow: "下一张幻灯片",
            indicator: "幻灯片切换至索引 {index}"
          }
        }
      };
      const app = createApp(_sfc_main);
      app.use(createPinia());
      app.use(ElementPlus, {
        locale: zhCn
      });
      const platform = PlatformFactory.getInstance(location.href);
      app.provide("$platform", platform);
      app.provide("$axios", request);
      const rootApp = document.createElement("div");
      rootApp.id = "ai-job";
      rootApp.classList.add("page-job-content");
      window.onload = () => {
        app.mount(
          (() => {
            platform.getMountEle().then((elP) => {
              let containerEle = elP.el;
              let p2 = elP.p;
              if (p2 === "end") {
                containerEle.appendChild(rootApp);
              } else {
                containerEle.insertBefore(
                  rootApp,
                  containerEle.firstElementChild
                );
              }
            });
            return rootApp;
          })()
        );
      };

    })
  };
}));

System.register("./BossMessage-DBY0bJNw-D01KK3Xs.js", ['./__monkey.entry-C6x6oyrg.js', 'vue', 'protobufjs', 'pinia', 'element-plus', 'event-source-polyfill'], (function (exports, module) {
  'use strict';
  var _export_sfc, ElMessage, Message, Tools, BossOption, AiPower, ElButton, ElInput, defineComponent, ref, openBlock, createElementBlock, Fragment, createVNode, withCtx, createTextVNode, createElementVNode, createCommentVNode, pushScopeId, popScopeId;
  return {
    setters: [module => {
      _export_sfc = module._;
      ElMessage = module.E;
      Message = module.M;
      Tools = module.T;
      BossOption = module.B;
      AiPower = module.A;
      ElButton = module.a;
      ElInput = module.b;
    }, module => {
      defineComponent = module.defineComponent;
      ref = module.ref;
      openBlock = module.openBlock;
      createElementBlock = module.createElementBlock;
      Fragment = module.Fragment;
      createVNode = module.createVNode;
      withCtx = module.withCtx;
      createTextVNode = module.createTextVNode;
      createElementVNode = module.createElementVNode;
      createCommentVNode = module.createCommentVNode;
      pushScopeId = module.pushScopeId;
      popScopeId = module.popScopeId;
    }, null, null, null, null],
    execute: (function () {

      const _withScopeId = (n) => (pushScopeId("data-v-251fd5d8"), n = n(), popScopeId(), n);
      const _hoisted_1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
      const _hoisted_2 = {
        key: 0,
        class: "batch-send-float"
      };
      const _hoisted_3 = {
        class: "dialog-footer",
        style: { "margin-top": "10px", "text-align": "right" }
      };
      const _sfc_main = /* @__PURE__ */ defineComponent({
        __name: "BossMessage",
        setup(__props) {
          const batchSendDialogVisible = ref(false);
          const batchMessageText = ref("");
          const cleanupBatchUI = () => {
            const checkboxes = document.querySelectorAll(".batch-checkbox");
            checkboxes.forEach((checkbox) => checkbox.remove());
            const selectedElements = document.querySelectorAll(".batch-send-item");
            selectedElements.forEach((element) => element.classList.remove("batch-send-item"));
          };
          const onCancel = () => {
            batchSendDialogVisible.value = false;
            cleanupBatchUI();
            batchMessageText.value = "";
          };
          const checkAndCreateBatchSendButton = () => {
            const labelList = document.querySelector(".label-list");
            if (!labelList)
              return;
            const existingButton = labelList.querySelector(".batch-send-btn");
            if (existingButton)
              return;
            const batchSendButton = document.createElement("button");
            batchSendButton.className = "batch-send-btn";
            batchSendButton.innerHTML = "批量发送消息";
            batchSendButton.style.cssText = `
        margin: 10px 0px;
        padding: 8px 8px;
        background-color: #6ead34;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    `;
            batchSendButton.addEventListener("click", () => {
              addCheckboxesToItems();
              batchSendDialogVisible.value = true;
            });
            labelList.appendChild(batchSendButton);
          };
          const addCheckboxesToItems = () => {
            const items = document.querySelectorAll(".friend-content-warp");
            items.forEach((item) => {
              if (item.querySelector(".batch-checkbox"))
                return;
              const checkbox = document.createElement("input");
              checkbox.type = "checkbox";
              checkbox.className = "batch-checkbox";
              checkbox.style.cssText = `
            margin-right: 8px;
            transform: scale(1.2);
        `;
              checkbox.addEventListener("click", (e) => {
                e.stopPropagation();
              });
              checkbox.addEventListener("change", (e) => {
                const target = e.target;
                e.stopPropagation();
                if (target.checked) {
                  item.classList.add("batch-send-item");
                } else {
                  item.classList.remove("batch-send-item");
                }
              });
              let firstElementChild = item.firstElementChild;
              firstElementChild.insertBefore(checkbox, firstElementChild.firstChild);
            });
          };
          const sendBatchMessage = () => {
            if (!batchMessageText.value.trim()) {
              ElMessage({
                type: "warning",
                message: "请输入消息内容"
              });
              return;
            }
            const selectedItems = document.querySelectorAll(".friend-content-warp.batch-send-item");
            if (selectedItems.length === 0) {
              ElMessage({
                type: "warning",
                message: "请至少选择一个联系人"
              });
              return;
            }
            selectedItems.forEach((item) => {
              const vueInstance = item.__vue__;
              if (vueInstance && vueInstance.source) {
                const to_uid = vueInstance.source.uid;
                const to_name = vueInstance.source.encryptBossId;
                if (to_uid && to_name) {
                  const message = new Message({
                    form_uid: Tools.window._PAGE.uid.toString(),
                    to_uid: to_uid.toString(),
                    to_name,
                    content: batchMessageText.value,
                    image: void 0
                  });
                  message.send();
                }
              }
            });
            ElMessage({
              duration: 3e3,
              type: "success",
              message: `已发送消息给 ${selectedItems.length} 个联系人; 刷新页面查看结果`
            });
            batchMessageText.value = "";
            batchSendDialogVisible.value = false;
            cleanupBatchUI();
          };
          setInterval(() => {
            checkAndCreateBatchSendButton();
          }, 1e3);
          const handlerClick = () => {
            var _a, _b, _c;
            const element = document.querySelector(".friend-content.selected");
            const encryptJobId = (_c = (_b = (_a = element == null ? void 0 : element.parentElement) == null ? void 0 : _a.__vue__) == null ? void 0 : _b.source) == null ? void 0 : _c.encryptJobId;
            if (!encryptJobId) {
              ElMessage({
                type: "info",
                message: "请先进入聊天窗口"
              });
              return;
            }
            const jobKey = BossOption.buildJobKey({ encryptJobId });
            AiPower.updateAskStatus(jobKey, false).then((_) => {
              ElMessage({
                type: "success",
                message: "已重新触发AI坐席"
              });
            });
          };
          return (_ctx, _cache) => {
            const _component_el_button = ElButton;
            const _component_el_input = ElInput;
            return openBlock(), createElementBlock(Fragment, null, [
              _hoisted_1,
              createVNode(_component_el_button, {
                style: { "margin-left": "10px" },
                type: "success",
                onClick: handlerClick
              }, {
                default: withCtx(() => [
                  createTextVNode("重启当前会话AI坐席")
                ]),
                _: 1
              }),
              batchSendDialogVisible.value ? (openBlock(), createElementBlock("div", _hoisted_2, [
                createVNode(_component_el_input, {
                  modelValue: batchMessageText.value,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => batchMessageText.value = $event),
                  type: "textarea",
                  rows: 4,
                  placeholder: "请输入要发送的消息内容"
                }, null, 8, ["modelValue"]),
                createElementVNode("div", _hoisted_3, [
                  createVNode(_component_el_button, { onClick: onCancel }, {
                    default: withCtx(() => [
                      createTextVNode("取消")
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_button, {
                    type: "primary",
                    onClick: sendBatchMessage
                  }, {
                    default: withCtx(() => [
                      createTextVNode("发送")
                    ]),
                    _: 1
                  })
                ])
              ])) : createCommentVNode("", true)
            ], 64);
          };
        }
      });
      const BossMessage = exports("default", /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-251fd5d8"]]));

    })
  };
}));

System.register("./BossJobList-BZPvSyMi-DM5PALTb.js", ['vue', './__monkey.entry-C6x6oyrg.js', 'element-plus', 'protobufjs', 'pinia', 'event-source-polyfill'], (function (exports, module) {
  'use strict';
  var defineComponent, computed, watch, provide, reactive, toRefs, openBlock, createElementBlock, normalizeClass, unref, renderSlot, inject, ref, onMounted, onBeforeUnmount, onUpdated, createVNode, Fragment, useSlots, withCtx, createBlock, resolveDynamicComponent, normalizeStyle, createTextVNode, toDisplayString, createCommentVNode, createElementVNode, TransitionGroup, useAttrs, nextTick, mergeProps, withModifiers, Transition, toHandlers, withKeys, withDirectives, vShow, getCurrentInstance, h, watchEffect, toRef, renderList, shallowRef, createSlots, toRaw, resolveComponent, resolveDirective, vModelText, onUnmounted, isRef, pushScopeId, popScopeId, createStaticVNode, createApp, Symbol$1, nodeUtil, Set$1, setToArray, baseRest, baseFlatten, isArrayLikeObject, buildProps, isFunction$1, componentSizes, definePropType, useFormSize, useNamespace, debugWarn, formContextKey, formItemContextKey, throwError, useResizeObserver, useId, refDebounced, addUnit, isBoolean, isString, getProp, withInstall, withNoopInstall, circle_close_default, useSizeProp, useLocale, useFormItem, isArray$1, isEqual, clock_default, calendar_default, onClickOutside, ElTooltip, ElInput, ElIcon, mutable, isNumber, isObject$1, arrow_right_default, isUndefined, useFormDisabled, isNil, UPDATE_MODEL_EVENT, arrow_down_default, minus_default, arrow_up_default, plus_default, iconPropType, more_default, flattedChildren, ClickOutside, useTooltipContentProps, tagProps, Ee, ElTag, ElScrollbar, CHANGE_EVENT, useMutationObserver, d_arrow_left_default, more_filled_default, d_arrow_right_default, arrow_left_default, buttonTypes, question_filled_default, ElButton, warning_filled_default, circle_check_default, check_default, close_default, useFormItemInputId, INPUT_EVENT, loading_default, NOOP, document_default, zoom_in_default, delete_default, isArray, SetCache, useGlobalConfig, _export_sfc$1, isEmpty, EVENT_CODE, useIdInjection, addClass, removeClass, hasClass, useTimeoutFn, get, useFocusController, ValidateComponentsMap, isClient, toRawType, debounce, isPromise, isPlainObject$1, entriesOf, useVModel, _export_sfc, isObject, copyArray, getTag$1, isBuffer, cloneBuffer, initCloneObject, Stack, cacheHas, isDate, TinyColor, scrollIntoView, copyObject, keys, keysIn, getSymbols, cloneTypedArray, cloneArrayBuffer, baseUnary, getAllKeys, assignValue, isKorean, stubArray, arrayPush, getPrototype$1, baseGetAllKeys, isObjectLike, baseIteratee, getStyle, PushStatus, LogRecorder, LoginStore, pushResultCount, UserStore, logger$1, silentlyLogin, isProdEnv, CircleCloseFilled, Shop, Wallet, PriceTag, Tools, loginInterceptor, ElMessage, axios, fetchWithGM_request, SSEClient, ElText, ElLink, ElTableColumn, ElTable, ElImage, ElDialog, ElCheckbox, ElButtonGroup, request, toNumber, hyphenate, useGlobalComponentSettings, ElNotification, ElMessageBox;
  return {
    setters: [module => {
      defineComponent = module.defineComponent;
      computed = module.computed;
      watch = module.watch;
      provide = module.provide;
      reactive = module.reactive;
      toRefs = module.toRefs;
      openBlock = module.openBlock;
      createElementBlock = module.createElementBlock;
      normalizeClass = module.normalizeClass;
      unref = module.unref;
      renderSlot = module.renderSlot;
      inject = module.inject;
      ref = module.ref;
      onMounted = module.onMounted;
      onBeforeUnmount = module.onBeforeUnmount;
      onUpdated = module.onUpdated;
      createVNode = module.createVNode;
      Fragment = module.Fragment;
      useSlots = module.useSlots;
      withCtx = module.withCtx;
      createBlock = module.createBlock;
      resolveDynamicComponent = module.resolveDynamicComponent;
      normalizeStyle = module.normalizeStyle;
      createTextVNode = module.createTextVNode;
      toDisplayString = module.toDisplayString;
      createCommentVNode = module.createCommentVNode;
      createElementVNode = module.createElementVNode;
      TransitionGroup = module.TransitionGroup;
      useAttrs = module.useAttrs;
      nextTick = module.nextTick;
      mergeProps = module.mergeProps;
      withModifiers = module.withModifiers;
      Transition = module.Transition;
      toHandlers = module.toHandlers;
      withKeys = module.withKeys;
      withDirectives = module.withDirectives;
      vShow = module.vShow;
      getCurrentInstance = module.getCurrentInstance;
      h = module.h;
      watchEffect = module.watchEffect;
      toRef = module.toRef;
      renderList = module.renderList;
      shallowRef = module.shallowRef;
      createSlots = module.createSlots;
      toRaw = module.toRaw;
      resolveComponent = module.resolveComponent;
      resolveDirective = module.resolveDirective;
      vModelText = module.vModelText;
      onUnmounted = module.onUnmounted;
      isRef = module.isRef;
      pushScopeId = module.pushScopeId;
      popScopeId = module.popScopeId;
      createStaticVNode = module.createStaticVNode;
      createApp = module.createApp;
    }, module => {
      Symbol$1 = module.S;
      nodeUtil = module.n;
      Set$1 = module.c;
      setToArray = module.s;
      baseRest = module.d;
      baseFlatten = module.e;
      isArrayLikeObject = module.i;
      buildProps = module.f;
      isFunction$1 = module.g;
      componentSizes = module.h;
      definePropType = module.j;
      useFormSize = module.u;
      useNamespace = module.k;
      debugWarn = module.l;
      formContextKey = module.m;
      formItemContextKey = module.o;
      throwError = module.t;
      useResizeObserver = module.p;
      useId = module.q;
      refDebounced = module.r;
      addUnit = module.v;
      isBoolean = module.w;
      isString = module.x;
      getProp = module.y;
      withInstall = module.z;
      withNoopInstall = module.C;
      circle_close_default = module.D;
      useSizeProp = module.F;
      useLocale = module.G;
      useFormItem = module.H;
      isArray$1 = module.I;
      isEqual = module.J;
      clock_default = module.K;
      calendar_default = module.L;
      onClickOutside = module.N;
      ElTooltip = module.O;
      ElInput = module.b;
      ElIcon = module.P;
      mutable = module.Q;
      isNumber = module.R;
      isObject$1 = module.U;
      arrow_right_default = module.V;
      isUndefined = module.W;
      useFormDisabled = module.X;
      isNil = module.Y;
      UPDATE_MODEL_EVENT = module.Z;
      arrow_down_default = module.$;
      minus_default = module.a0;
      arrow_up_default = module.a1;
      plus_default = module.a2;
      iconPropType = module.a3;
      more_default = module.a4;
      flattedChildren = module.a5;
      ClickOutside = module.a6;
      useTooltipContentProps = module.a7;
      tagProps = module.a8;
      Ee = module.a9;
      ElTag = module.aa;
      ElScrollbar = module.ab;
      CHANGE_EVENT = module.ac;
      useMutationObserver = module.ad;
      d_arrow_left_default = module.ae;
      more_filled_default = module.af;
      d_arrow_right_default = module.ag;
      arrow_left_default = module.ah;
      buttonTypes = module.ai;
      question_filled_default = module.aj;
      ElButton = module.a;
      warning_filled_default = module.ak;
      circle_check_default = module.al;
      check_default = module.am;
      close_default = module.an;
      useFormItemInputId = module.ao;
      INPUT_EVENT = module.ap;
      loading_default = module.aq;
      NOOP = module.ar;
      document_default = module.as;
      zoom_in_default = module.at;
      delete_default = module.au;
      isArray = module.av;
      SetCache = module.aw;
      useGlobalConfig = module.ax;
      _export_sfc$1 = module.ay;
      isEmpty = module.az;
      EVENT_CODE = module.aA;
      useIdInjection = module.aB;
      addClass = module.aC;
      removeClass = module.aD;
      hasClass = module.aE;
      useTimeoutFn = module.aF;
      get = module.aG;
      useFocusController = module.aH;
      ValidateComponentsMap = module.aI;
      isClient = module.aJ;
      toRawType = module.aK;
      debounce = module.aL;
      isPromise = module.aM;
      isPlainObject$1 = module.aN;
      entriesOf = module.aO;
      useVModel = module.aP;
      _export_sfc = module._;
      isObject = module.aQ;
      copyArray = module.aR;
      getTag$1 = module.aS;
      isBuffer = module.aT;
      cloneBuffer = module.aU;
      initCloneObject = module.aV;
      Stack = module.aW;
      cacheHas = module.aX;
      isDate = module.aY;
      TinyColor = module.aZ;
      scrollIntoView = module.a_;
      copyObject = module.a$;
      keys = module.b0;
      keysIn = module.b1;
      getSymbols = module.b2;
      cloneTypedArray = module.b3;
      cloneArrayBuffer = module.b4;
      baseUnary = module.b5;
      getAllKeys = module.b6;
      assignValue = module.b7;
      isKorean = module.b8;
      stubArray = module.b9;
      arrayPush = module.ba;
      getPrototype$1 = module.bb;
      baseGetAllKeys = module.bc;
      isObjectLike = module.bd;
      baseIteratee = module.be;
      getStyle = module.bf;
      PushStatus = module.bg;
      LogRecorder = module.bh;
      LoginStore = module.bi;
      pushResultCount = module.bj;
      UserStore = module.bk;
      logger$1 = module.bl;
      silentlyLogin = module.bm;
      isProdEnv = module.bn;
      CircleCloseFilled = module.bo;
      Shop = module.bp;
      Wallet = module.bq;
      PriceTag = module.br;
      Tools = module.T;
      loginInterceptor = module.bs;
      ElMessage = module.E;
      axios = module.bt;
      fetchWithGM_request = module.bu;
      SSEClient = module.bv;
      ElText = module.bw;
      ElLink = module.bx;
      ElTableColumn = module.by;
      ElTable = module.bz;
      ElImage = module.bA;
      ElDialog = module.bB;
      ElCheckbox = module.bC;
      ElButtonGroup = module.bD;
      request = module.bE;
      toNumber = module.bF;
      hyphenate = module.bG;
      useGlobalComponentSettings = module.bH;
    }, module => {
      ElNotification = module.ElNotification;
      ElMessageBox = module.ElMessageBox;
    }, null, null, null],
    execute: (function () {

      const triggerEvent = function(elm, name, ...opts) {
        let eventName;
        if (name.includes("mouse") || name.includes("click")) {
          eventName = "MouseEvents";
        } else if (name.includes("key")) {
          eventName = "KeyboardEvent";
        } else {
          eventName = "HTMLEvents";
        }
        const evt = document.createEvent(eventName);
        evt.initEvent(name, ...opts);
        elm.dispatchEvent(evt);
        return elm;
      };
      var INFINITY$1 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY$1 || value === -INFINITY$1) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result = toFinite(value), remainder = result % 1;
        return result === result ? remainder ? result - remainder : result : 0;
      }
      function noop() {
      }
      function arrayEach(array4, iteratee) {
        var index = -1, length = array4 == null ? 0 : array4.length;
        while (++index < length) {
          if (iteratee(array4[index], index, array4) === false) {
            break;
          }
        }
        return array4;
      }
      function baseFindIndex(array4, predicate, fromIndex, fromRight) {
        var length = array4.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array4[index], index, array4)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function strictIndexOf(array4, value, fromIndex) {
        var index = fromIndex - 1, length = array4.length;
        while (++index < length) {
          if (array4[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array4, value, fromIndex) {
        return value === value ? strictIndexOf(array4, value, fromIndex) : baseFindIndex(array4, baseIsNaN, fromIndex);
      }
      function arrayIncludes(array4, value) {
        var length = array4 == null ? 0 : array4.length;
        return !!length && baseIndexOf(array4, value, 0) > -1;
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }
      function baseAssign(object4, source) {
        return object4 && copyObject(source, keys(source), object4);
      }
      function baseAssignIn(object4, source) {
        return object4 && copyObject(source, keysIn(source), object4);
      }
      function copySymbols(source, object4) {
        return copyObject(source, getSymbols(source), object4);
      }
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object4) {
        var result = [];
        while (object4) {
          arrayPush(result, getSymbols(object4));
          object4 = getPrototype$1(object4);
        }
        return result;
      };
      function copySymbolsIn(source, object4) {
        return copyObject(source, getSymbolsIn(source), object4);
      }
      function getAllKeysIn(object4) {
        return baseGetAllKeys(object4, keysIn, getSymbolsIn);
      }
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function initCloneArray(array4) {
        var length = array4.length, result = new array4.constructor(length);
        if (length && typeof array4[0] == "string" && hasOwnProperty.call(array4, "index")) {
          result.index = array4.index;
          result.input = array4.input;
        }
        return result;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      var reFlags = /\w*$/;
      function cloneRegExp(regexp4) {
        var result = new regexp4.constructor(regexp4.source, reFlags.exec(regexp4));
        result.lastIndex = regexp4.lastIndex;
        return result;
      }
      var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
      }
      var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
      var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
      function initCloneByTag(object4, tag, isDeep) {
        var Ctor = object4.constructor;
        switch (tag) {
          case arrayBufferTag$1:
            return cloneArrayBuffer(object4);
          case boolTag$1:
          case dateTag$1:
            return new Ctor(+object4);
          case dataViewTag$1:
            return cloneDataView(object4, isDeep);
          case float32Tag$1:
          case float64Tag$1:
          case int8Tag$1:
          case int16Tag$1:
          case int32Tag$1:
          case uint8Tag$1:
          case uint8ClampedTag$1:
          case uint16Tag$1:
          case uint32Tag$1:
            return cloneTypedArray(object4, isDeep);
          case mapTag$2:
            return new Ctor();
          case numberTag$1:
          case stringTag$1:
            return new Ctor(object4);
          case regexpTag$1:
            return cloneRegExp(object4);
          case setTag$2:
            return new Ctor();
          case symbolTag$1:
            return cloneSymbol(object4);
        }
      }
      var mapTag$1 = "[object Map]";
      function baseIsMap(value) {
        return isObjectLike(value) && getTag$1(value) == mapTag$1;
      }
      var nodeIsMap = nodeUtil && nodeUtil.isMap;
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      var setTag$1 = "[object Set]";
      function baseIsSet(value) {
        return isObjectLike(value) && getTag$1(value) == setTag$1;
      }
      var nodeIsSet = nodeUtil && nodeUtil.isSet;
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$2 = 4;
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      function baseClone(value, bitmask, customizer, key, object4, stack) {
        var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
        if (customizer) {
          result = object4 ? customizer(value, key, object4, stack) : customizer(value);
        }
        if (result !== void 0) {
          return result;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result);
          }
        } else {
          var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object4) {
            result = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object4 ? value : {};
            }
            result = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? void 0 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result;
      }
      var CLONE_SYMBOLS_FLAG$1 = 4;
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG$1);
      }
      var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function arrayIncludesWith(array4, value, comparator) {
        var index = -1, length = array4 == null ? 0 : array4.length;
        while (++index < length) {
          if (comparator(value, array4[index])) {
            return true;
          }
        }
        return false;
      }
      var nativeMax = Math.max, nativeMin = Math.min;
      function findLastIndex(array4, predicate, fromIndex) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== void 0) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array4, baseIteratee(predicate), index, true);
      }
      var INFINITY = 1 / 0;
      var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY) ? noop : function(values) {
        return new Set$1(values);
      };
      var LARGE_ARRAY_SIZE = 200;
      function baseUniq(array4, iteratee, comparator) {
        var index = -1, includes = arrayIncludes, length = array4.length, isCommon = true, result = [], seen = result;
        if (comparator) {
          isCommon = false;
          includes = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set = iteratee ? null : createSet(array4);
          if (set) {
            return setToArray(set);
          }
          isCommon = false;
          includes = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee ? [] : result;
        }
        outer:
          while (++index < length) {
            var value = array4[index], computed2 = iteratee ? iteratee(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed2) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed2);
              }
              result.push(value);
            } else if (!includes(seen, computed2, comparator)) {
              if (seen !== result) {
                seen.push(computed2);
              }
              result.push(value);
            }
          }
        return result;
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      const escapeStringRegexp = (string3 = "") => string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      const isValidComponentSize = (val) => ["", ...componentSizes].includes(val);
      const DEFAULT_EMPTY_VALUES = ["", void 0, null];
      const DEFAULT_VALUE_ON_CLEAR = void 0;
      const useEmptyValuesProps = buildProps({
        emptyValues: Array,
        valueOnClear: {
          type: [String, Number, Boolean, Function],
          default: void 0,
          validator: (val) => isFunction$1(val) ? !val() : !val
        }
      });
      const useEmptyValues = (props, defaultValue) => {
        const config = useGlobalConfig();
        config.value = config.value || {};
        const emptyValues = computed(() => props.emptyValues || config.value.emptyValues || DEFAULT_EMPTY_VALUES);
        const valueOnClear = computed(() => {
          if (isFunction$1(props.valueOnClear)) {
            return props.valueOnClear();
          } else if (props.valueOnClear !== void 0) {
            return props.valueOnClear;
          } else if (isFunction$1(config.value.valueOnClear)) {
            return config.value.valueOnClear();
          } else if (config.value.valueOnClear !== void 0) {
            return config.value.valueOnClear;
          }
          return defaultValue !== void 0 ? defaultValue : DEFAULT_VALUE_ON_CLEAR;
        });
        const isEmptyValue2 = (value) => {
          return emptyValues.value.includes(value);
        };
        if (!emptyValues.value.includes(valueOnClear.value))
          ;
        return {
          emptyValues,
          valueOnClear,
          isEmptyValue: isEmptyValue2
        };
      };
      const formMetaProps = buildProps({
        size: {
          type: String,
          values: componentSizes
        },
        disabled: Boolean
      });
      const formProps = buildProps({
        ...formMetaProps,
        model: Object,
        rules: {
          type: definePropType(Object)
        },
        labelPosition: {
          type: String,
          values: ["left", "right", "top"],
          default: "right"
        },
        requireAsteriskPosition: {
          type: String,
          values: ["left", "right"],
          default: "left"
        },
        labelWidth: {
          type: [String, Number],
          default: ""
        },
        labelSuffix: {
          type: String,
          default: ""
        },
        inline: Boolean,
        inlineMessage: Boolean,
        statusIcon: Boolean,
        showMessage: {
          type: Boolean,
          default: true
        },
        validateOnRuleChange: {
          type: Boolean,
          default: true
        },
        hideRequiredAsterisk: Boolean,
        scrollToError: Boolean,
        scrollIntoViewOptions: {
          type: [Object, Boolean]
        }
      });
      const formEmits = {
        validate: (prop, isValid, message) => (isArray$1(prop) || isString(prop)) && isBoolean(isValid) && isString(message)
      };
      function useFormLabelWidth() {
        const potentialLabelWidthArr = ref([]);
        const autoLabelWidth = computed(() => {
          if (!potentialLabelWidthArr.value.length)
            return "0";
          const max = Math.max(...potentialLabelWidthArr.value);
          return max ? `${max}px` : "";
        });
        function getLabelWidthIndex(width) {
          const index = potentialLabelWidthArr.value.indexOf(width);
          if (index === -1 && autoLabelWidth.value === "0")
            ;
          return index;
        }
        function registerLabelWidth(val, oldVal) {
          if (val && oldVal) {
            const index = getLabelWidthIndex(oldVal);
            potentialLabelWidthArr.value.splice(index, 1, val);
          } else if (val) {
            potentialLabelWidthArr.value.push(val);
          }
        }
        function deregisterLabelWidth(val) {
          const index = getLabelWidthIndex(val);
          if (index > -1) {
            potentialLabelWidthArr.value.splice(index, 1);
          }
        }
        return {
          autoLabelWidth,
          registerLabelWidth,
          deregisterLabelWidth
        };
      }
      const filterFields = (fields, props) => {
        const normalized = castArray(props);
        return normalized.length > 0 ? fields.filter((field) => field.prop && normalized.includes(field.prop)) : fields;
      };
      const COMPONENT_NAME$7 = "ElForm";
      const __default__$o = defineComponent({
        name: COMPONENT_NAME$7
      });
      const _sfc_main$L = /* @__PURE__ */ defineComponent({
        ...__default__$o,
        props: formProps,
        emits: formEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const fields = [];
          const formSize = useFormSize();
          const ns = useNamespace("form");
          const formClasses = computed(() => {
            const { labelPosition, inline } = props;
            return [
              ns.b(),
              ns.m(formSize.value || "default"),
              {
                [ns.m(`label-${labelPosition}`)]: labelPosition,
                [ns.m("inline")]: inline
              }
            ];
          });
          const getField = (prop) => {
            return fields.find((field) => field.prop === prop);
          };
          const addField = (field) => {
            fields.push(field);
          };
          const removeField = (field) => {
            if (field.prop) {
              fields.splice(fields.indexOf(field), 1);
            }
          };
          const resetFields = (properties = []) => {
            if (!props.model) {
              return;
            }
            filterFields(fields, properties).forEach((field) => field.resetField());
          };
          const clearValidate = (props2 = []) => {
            filterFields(fields, props2).forEach((field) => field.clearValidate());
          };
          const isValidatable = computed(() => {
            const hasModel = !!props.model;
            return hasModel;
          });
          const obtainValidateFields = (props2) => {
            if (fields.length === 0)
              return [];
            const filteredFields = filterFields(fields, props2);
            if (!filteredFields.length) {
              return [];
            }
            return filteredFields;
          };
          const validate = async (callback) => validateField(void 0, callback);
          const doValidateField = async (props2 = []) => {
            if (!isValidatable.value)
              return false;
            const fields2 = obtainValidateFields(props2);
            if (fields2.length === 0)
              return true;
            let validationErrors = {};
            for (const field of fields2) {
              try {
                await field.validate("");
              } catch (fields3) {
                validationErrors = {
                  ...validationErrors,
                  ...fields3
                };
              }
            }
            if (Object.keys(validationErrors).length === 0)
              return true;
            return Promise.reject(validationErrors);
          };
          const validateField = async (modelProps = [], callback) => {
            const shouldThrow = !isFunction$1(callback);
            try {
              const result = await doValidateField(modelProps);
              if (result === true) {
                callback == null ? void 0 : callback(result);
              }
              return result;
            } catch (e) {
              if (e instanceof Error)
                throw e;
              const invalidFields = e;
              if (props.scrollToError) {
                scrollToField(Object.keys(invalidFields)[0]);
              }
              callback == null ? void 0 : callback(false, invalidFields);
              return shouldThrow && Promise.reject(invalidFields);
            }
          };
          const scrollToField = (prop) => {
            var _a;
            const field = filterFields(fields, prop)[0];
            if (field) {
              (_a = field.$el) == null ? void 0 : _a.scrollIntoView(props.scrollIntoViewOptions);
            }
          };
          watch(() => props.rules, () => {
            if (props.validateOnRuleChange) {
              validate().catch((err) => debugWarn());
            }
          }, { deep: true });
          provide(formContextKey, reactive({
            ...toRefs(props),
            emit,
            resetFields,
            clearValidate,
            validateField,
            getField,
            addField,
            removeField,
            ...useFormLabelWidth()
          }));
          expose({
            validate,
            validateField,
            resetFields,
            clearValidate,
            scrollToField
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("form", {
              class: normalizeClass(unref(formClasses))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var Form = /* @__PURE__ */ _export_sfc$1(_sfc_main$L, [["__file", "form.vue"]]);
      var define_process_env_default = {};
      function _extends() {
        _extends = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct.bind();
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a = [null];
            a.push.apply(a, args2);
            var Constructor = Function.bind.apply(Parent2, a);
            var instance = new Constructor();
            if (Class2)
              _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _isNativeFunction(fn) {
        return Function.toString.call(fn).indexOf("[native code]") !== -1;
      }
      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
        _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
          if (Class2 === null || !_isNativeFunction(Class2))
            return Class2;
          if (typeof Class2 !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }
          if (typeof _cache !== "undefined") {
            if (_cache.has(Class2))
              return _cache.get(Class2);
            _cache.set(Class2, Wrapper);
          }
          function Wrapper() {
            return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
          }
          Wrapper.prototype = Object.create(Class2.prototype, {
            constructor: {
              value: Wrapper,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          return _setPrototypeOf(Wrapper, Class2);
        };
        return _wrapNativeSuper(Class);
      }
      var formatRegExp = /%[sdj%]/g;
      var warning = function warning2() {
      };
      if (typeof process !== "undefined" && define_process_env_default && false) {
        warning = function warning3(type4, errors) {
          if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
            if (errors.every(function(e) {
              return typeof e === "string";
            })) {
              console.warn(type4, errors);
            }
          }
        };
      }
      function convertFieldsError(errors) {
        if (!errors || !errors.length)
          return null;
        var fields = {};
        errors.forEach(function(error) {
          var field = error.field;
          fields[field] = fields[field] || [];
          fields[field].push(error);
        });
        return fields;
      }
      function format(template) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var i = 0;
        var len = args.length;
        if (typeof template === "function") {
          return template.apply(null, args);
        }
        if (typeof template === "string") {
          var str = template.replace(formatRegExp, function(x) {
            if (x === "%%") {
              return "%";
            }
            if (i >= len) {
              return x;
            }
            switch (x) {
              case "%s":
                return String(args[i++]);
              case "%d":
                return Number(args[i++]);
              case "%j":
                try {
                  return JSON.stringify(args[i++]);
                } catch (_) {
                  return "[Circular]";
                }
                break;
              default:
                return x;
            }
          });
          return str;
        }
        return template;
      }
      function isNativeStringType(type4) {
        return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
      }
      function isEmptyValue(value, type4) {
        if (value === void 0 || value === null) {
          return true;
        }
        if (type4 === "array" && Array.isArray(value) && !value.length) {
          return true;
        }
        if (isNativeStringType(type4) && typeof value === "string" && !value) {
          return true;
        }
        return false;
      }
      function asyncParallelArray(arr, func, callback) {
        var results = [];
        var total = 0;
        var arrLength = arr.length;
        function count(errors) {
          results.push.apply(results, errors || []);
          total++;
          if (total === arrLength) {
            callback(results);
          }
        }
        arr.forEach(function(a) {
          func(a, count);
        });
      }
      function asyncSerialArray(arr, func, callback) {
        var index = 0;
        var arrLength = arr.length;
        function next(errors) {
          if (errors && errors.length) {
            callback(errors);
            return;
          }
          var original = index;
          index = index + 1;
          if (original < arrLength) {
            func(arr[original], next);
          } else {
            callback([]);
          }
        }
        next([]);
      }
      function flattenObjArr(objArr) {
        var ret = [];
        Object.keys(objArr).forEach(function(k) {
          ret.push.apply(ret, objArr[k] || []);
        });
        return ret;
      }
      var AsyncValidationError = /* @__PURE__ */ function(_Error) {
        _inheritsLoose(AsyncValidationError2, _Error);
        function AsyncValidationError2(errors, fields) {
          var _this;
          _this = _Error.call(this, "Async Validation Error") || this;
          _this.errors = errors;
          _this.fields = fields;
          return _this;
        }
        return AsyncValidationError2;
      }(/* @__PURE__ */ _wrapNativeSuper(Error));
      function asyncMap(objArr, option, func, callback, source) {
        if (option.first) {
          var _pending = new Promise(function(resolve, reject) {
            var next = function next2(errors) {
              callback(errors);
              return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
            };
            var flattenArr = flattenObjArr(objArr);
            asyncSerialArray(flattenArr, func, next);
          });
          _pending["catch"](function(e) {
            return e;
          });
          return _pending;
        }
        var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
        var objArrKeys = Object.keys(objArr);
        var objArrLength = objArrKeys.length;
        var total = 0;
        var results = [];
        var pending = new Promise(function(resolve, reject) {
          var next = function next2(errors) {
            results.push.apply(results, errors);
            total++;
            if (total === objArrLength) {
              callback(results);
              return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
            }
          };
          if (!objArrKeys.length) {
            callback(results);
            resolve(source);
          }
          objArrKeys.forEach(function(key) {
            var arr = objArr[key];
            if (firstFields.indexOf(key) !== -1) {
              asyncSerialArray(arr, func, next);
            } else {
              asyncParallelArray(arr, func, next);
            }
          });
        });
        pending["catch"](function(e) {
          return e;
        });
        return pending;
      }
      function isErrorObj(obj) {
        return !!(obj && obj.message !== void 0);
      }
      function getValue(value, path) {
        var v = value;
        for (var i = 0; i < path.length; i++) {
          if (v == void 0) {
            return v;
          }
          v = v[path[i]];
        }
        return v;
      }
      function complementError(rule, source) {
        return function(oe) {
          var fieldValue;
          if (rule.fullFields) {
            fieldValue = getValue(source, rule.fullFields);
          } else {
            fieldValue = source[oe.field || rule.fullField];
          }
          if (isErrorObj(oe)) {
            oe.field = oe.field || rule.fullField;
            oe.fieldValue = fieldValue;
            return oe;
          }
          return {
            message: typeof oe === "function" ? oe() : oe,
            fieldValue,
            field: oe.field || rule.fullField
          };
        };
      }
      function deepMerge(target, source) {
        if (source) {
          for (var s in source) {
            if (source.hasOwnProperty(s)) {
              var value = source[s];
              if (typeof value === "object" && typeof target[s] === "object") {
                target[s] = _extends({}, target[s], value);
              } else {
                target[s] = value;
              }
            }
          }
        }
        return target;
      }
      var required$1 = function required(rule, value, source, errors, options, type4) {
        if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
          errors.push(format(options.messages.required, rule.fullField));
        }
      };
      var whitespace = function whitespace2(rule, value, source, errors, options) {
        if (/^\s+$/.test(value) || value === "") {
          errors.push(format(options.messages.whitespace, rule.fullField));
        }
      };
      var urlReg;
      var getUrlRegex = function() {
        if (urlReg) {
          return urlReg;
        }
        var word = "[a-fA-F\\d:]";
        var b = function b2(options) {
          return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
        };
        var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
        var v6seg = "[a-fA-F\\d]{1,4}";
        var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
        var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
        var v4exact = new RegExp("^" + v4 + "$");
        var v6exact = new RegExp("^" + v6 + "$");
        var ip = function ip2(options) {
          return options && options.exact ? v46Exact : new RegExp("(?:" + b(options) + v4 + b(options) + ")|(?:" + b(options) + v6 + b(options) + ")", "g");
        };
        ip.v4 = function(options) {
          return options && options.exact ? v4exact : new RegExp("" + b(options) + v4 + b(options), "g");
        };
        ip.v6 = function(options) {
          return options && options.exact ? v6exact : new RegExp("" + b(options) + v6 + b(options), "g");
        };
        var protocol = "(?:(?:[a-z]+:)?//)";
        var auth = "(?:\\S+(?::\\S*)?@)?";
        var ipv4 = ip.v4().source;
        var ipv6 = ip.v6().source;
        var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
        var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
        var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
        var port = "(?::\\d{2,5})?";
        var path = '(?:[/?#][^\\s"]*)?';
        var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
        urlReg = new RegExp("(?:^" + regex + "$)", "i");
        return urlReg;
      };
      var pattern$2 = {
        // http://emailregex.com/
        email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
        // url: new RegExp(
        //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
        //   'i',
        // ),
        hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
      };
      var types = {
        integer: function integer(value) {
          return types.number(value) && parseInt(value, 10) === value;
        },
        "float": function float(value) {
          return types.number(value) && !types.integer(value);
        },
        array: function array(value) {
          return Array.isArray(value);
        },
        regexp: function regexp(value) {
          if (value instanceof RegExp) {
            return true;
          }
          try {
            return !!new RegExp(value);
          } catch (e) {
            return false;
          }
        },
        date: function date(value) {
          return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
        },
        number: function number(value) {
          if (isNaN(value)) {
            return false;
          }
          return typeof value === "number";
        },
        object: function object(value) {
          return typeof value === "object" && !types.array(value);
        },
        method: function method(value) {
          return typeof value === "function";
        },
        email: function email(value) {
          return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
        },
        url: function url(value) {
          return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
        },
        hex: function hex(value) {
          return typeof value === "string" && !!value.match(pattern$2.hex);
        }
      };
      var type$1 = function type(rule, value, source, errors, options) {
        if (rule.required && value === void 0) {
          required$1(rule, value, source, errors, options);
          return;
        }
        var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
        var ruleType = rule.type;
        if (custom.indexOf(ruleType) > -1) {
          if (!types[ruleType](value)) {
            errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
          }
        } else if (ruleType && typeof value !== rule.type) {
          errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      };
      var range = function range2(rule, value, source, errors, options) {
        var len = typeof rule.len === "number";
        var min = typeof rule.min === "number";
        var max = typeof rule.max === "number";
        var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        var val = value;
        var key = null;
        var num = typeof value === "number";
        var str = typeof value === "string";
        var arr = Array.isArray(value);
        if (num) {
          key = "number";
        } else if (str) {
          key = "string";
        } else if (arr) {
          key = "array";
        }
        if (!key) {
          return false;
        }
        if (arr) {
          val = value.length;
        }
        if (str) {
          val = value.replace(spRegexp, "_").length;
        }
        if (len) {
          if (val !== rule.len) {
            errors.push(format(options.messages[key].len, rule.fullField, rule.len));
          }
        } else if (min && !max && val < rule.min) {
          errors.push(format(options.messages[key].min, rule.fullField, rule.min));
        } else if (max && !min && val > rule.max) {
          errors.push(format(options.messages[key].max, rule.fullField, rule.max));
        } else if (min && max && (val < rule.min || val > rule.max)) {
          errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
        }
      };
      var ENUM$1 = "enum";
      var enumerable$1 = function enumerable(rule, value, source, errors, options) {
        rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
        if (rule[ENUM$1].indexOf(value) === -1) {
          errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
        }
      };
      var pattern$1 = function pattern(rule, value, source, errors, options) {
        if (rule.pattern) {
          if (rule.pattern instanceof RegExp) {
            rule.pattern.lastIndex = 0;
            if (!rule.pattern.test(value)) {
              errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          } else if (typeof rule.pattern === "string") {
            var _pattern = new RegExp(rule.pattern);
            if (!_pattern.test(value)) {
              errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          }
        }
      };
      var rules = {
        required: required$1,
        whitespace,
        type: type$1,
        range,
        "enum": enumerable$1,
        pattern: pattern$1
      };
      var string = function string2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, "string");
          if (!isEmptyValue(value, "string")) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
            rules.pattern(rule, value, source, errors, options);
            if (rule.whitespace === true) {
              rules.whitespace(rule, value, source, errors, options);
            }
          }
        }
        callback(errors);
      };
      var method2 = function method3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var number2 = function number3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (value === "") {
            value = void 0;
          }
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var _boolean = function _boolean2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var regexp2 = function regexp3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value)) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var integer2 = function integer3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var floatFn = function floatFn2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var array2 = function array3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if ((value === void 0 || value === null) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, "array");
          if (value !== void 0 && value !== null) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var object2 = function object3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var ENUM = "enum";
      var enumerable2 = function enumerable3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules[ENUM](rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var pattern2 = function pattern3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, "string")) {
            rules.pattern(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var date2 = function date3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "date") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, "date")) {
            var dateObject;
            if (value instanceof Date) {
              dateObject = value;
            } else {
              dateObject = new Date(value);
            }
            rules.type(rule, dateObject, source, errors, options);
            if (dateObject) {
              rules.range(rule, dateObject.getTime(), source, errors, options);
            }
          }
        }
        callback(errors);
      };
      var required2 = function required3(rule, value, callback, source, options) {
        var errors = [];
        var type4 = Array.isArray(value) ? "array" : typeof value;
        rules.required(rule, value, source, errors, options, type4);
        callback(errors);
      };
      var type2 = function type3(rule, value, callback, source, options) {
        var ruleType = rule.type;
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, ruleType) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, ruleType);
          if (!isEmptyValue(value, ruleType)) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var any = function any2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
        }
        callback(errors);
      };
      var validators = {
        string,
        method: method2,
        number: number2,
        "boolean": _boolean,
        regexp: regexp2,
        integer: integer2,
        "float": floatFn,
        array: array2,
        object: object2,
        "enum": enumerable2,
        pattern: pattern2,
        date: date2,
        url: type2,
        hex: type2,
        email: type2,
        required: required2,
        any
      };
      function newMessages() {
        return {
          "default": "Validation error on field %s",
          required: "%s is required",
          "enum": "%s must be one of %s",
          whitespace: "%s cannot be empty",
          date: {
            format: "%s date %s is invalid for format %s",
            parse: "%s date could not be parsed, %s is invalid ",
            invalid: "%s date %s is invalid"
          },
          types: {
            string: "%s is not a %s",
            method: "%s is not a %s (function)",
            array: "%s is not an %s",
            object: "%s is not an %s",
            number: "%s is not a %s",
            date: "%s is not a %s",
            "boolean": "%s is not a %s",
            integer: "%s is not an %s",
            "float": "%s is not a %s",
            regexp: "%s is not a valid %s",
            email: "%s is not a valid %s",
            url: "%s is not a valid %s",
            hex: "%s is not a valid %s"
          },
          string: {
            len: "%s must be exactly %s characters",
            min: "%s must be at least %s characters",
            max: "%s cannot be longer than %s characters",
            range: "%s must be between %s and %s characters"
          },
          number: {
            len: "%s must equal %s",
            min: "%s cannot be less than %s",
            max: "%s cannot be greater than %s",
            range: "%s must be between %s and %s"
          },
          array: {
            len: "%s must be exactly %s in length",
            min: "%s cannot be less than %s in length",
            max: "%s cannot be greater than %s in length",
            range: "%s must be between %s and %s in length"
          },
          pattern: {
            mismatch: "%s value %s does not match pattern %s"
          },
          clone: function clone2() {
            var cloned = JSON.parse(JSON.stringify(this));
            cloned.clone = this.clone;
            return cloned;
          }
        };
      }
      var messages = newMessages();
      var Schema = /* @__PURE__ */ function() {
        function Schema2(descriptor) {
          this.rules = null;
          this._messages = messages;
          this.define(descriptor);
        }
        var _proto = Schema2.prototype;
        _proto.define = function define(rules2) {
          var _this = this;
          if (!rules2) {
            throw new Error("Cannot configure a schema with no rules");
          }
          if (typeof rules2 !== "object" || Array.isArray(rules2)) {
            throw new Error("Rules must be an object");
          }
          this.rules = {};
          Object.keys(rules2).forEach(function(name) {
            var item = rules2[name];
            _this.rules[name] = Array.isArray(item) ? item : [item];
          });
        };
        _proto.messages = function messages2(_messages) {
          if (_messages) {
            this._messages = deepMerge(newMessages(), _messages);
          }
          return this._messages;
        };
        _proto.validate = function validate(source_, o, oc) {
          var _this2 = this;
          if (o === void 0) {
            o = {};
          }
          if (oc === void 0) {
            oc = function oc2() {
            };
          }
          var source = source_;
          var options = o;
          var callback = oc;
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          if (!this.rules || Object.keys(this.rules).length === 0) {
            if (callback) {
              callback(null, source);
            }
            return Promise.resolve(source);
          }
          function complete(results) {
            var errors = [];
            var fields = {};
            function add(e) {
              if (Array.isArray(e)) {
                var _errors;
                errors = (_errors = errors).concat.apply(_errors, e);
              } else {
                errors.push(e);
              }
            }
            for (var i = 0; i < results.length; i++) {
              add(results[i]);
            }
            if (!errors.length) {
              callback(null, source);
            } else {
              fields = convertFieldsError(errors);
              callback(errors, fields);
            }
          }
          if (options.messages) {
            var messages$1 = this.messages();
            if (messages$1 === messages) {
              messages$1 = newMessages();
            }
            deepMerge(messages$1, options.messages);
            options.messages = messages$1;
          } else {
            options.messages = this.messages();
          }
          var series = {};
          var keys2 = options.keys || Object.keys(this.rules);
          keys2.forEach(function(z) {
            var arr = _this2.rules[z];
            var value = source[z];
            arr.forEach(function(r) {
              var rule = r;
              if (typeof rule.transform === "function") {
                if (source === source_) {
                  source = _extends({}, source);
                }
                value = source[z] = rule.transform(value);
              }
              if (typeof rule === "function") {
                rule = {
                  validator: rule
                };
              } else {
                rule = _extends({}, rule);
              }
              rule.validator = _this2.getValidationMethod(rule);
              if (!rule.validator) {
                return;
              }
              rule.field = z;
              rule.fullField = rule.fullField || z;
              rule.type = _this2.getType(rule);
              series[z] = series[z] || [];
              series[z].push({
                rule,
                value,
                source,
                field: z
              });
            });
          });
          var errorFields = {};
          return asyncMap(series, options, function(data, doIt) {
            var rule = data.rule;
            var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
            deep = deep && (rule.required || !rule.required && data.value);
            rule.field = data.field;
            function addFullField(key, schema) {
              return _extends({}, schema, {
                fullField: rule.fullField + "." + key,
                fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
              });
            }
            function cb(e) {
              if (e === void 0) {
                e = [];
              }
              var errorList = Array.isArray(e) ? e : [e];
              if (!options.suppressWarning && errorList.length) {
                Schema2.warning("async-validator:", errorList);
              }
              if (errorList.length && rule.message !== void 0) {
                errorList = [].concat(rule.message);
              }
              var filledErrors = errorList.map(complementError(rule, source));
              if (options.first && filledErrors.length) {
                errorFields[rule.field] = 1;
                return doIt(filledErrors);
              }
              if (!deep) {
                doIt(filledErrors);
              } else {
                if (rule.required && !data.value) {
                  if (rule.message !== void 0) {
                    filledErrors = [].concat(rule.message).map(complementError(rule, source));
                  } else if (options.error) {
                    filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
                  }
                  return doIt(filledErrors);
                }
                var fieldsSchema = {};
                if (rule.defaultField) {
                  Object.keys(data.value).map(function(key) {
                    fieldsSchema[key] = rule.defaultField;
                  });
                }
                fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
                var paredFieldsSchema = {};
                Object.keys(fieldsSchema).forEach(function(field) {
                  var fieldSchema = fieldsSchema[field];
                  var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                  paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
                });
                var schema = new Schema2(paredFieldsSchema);
                schema.messages(options.messages);
                if (data.rule.options) {
                  data.rule.options.messages = options.messages;
                  data.rule.options.error = options.error;
                }
                schema.validate(data.value, data.rule.options || options, function(errs) {
                  var finalErrors = [];
                  if (filledErrors && filledErrors.length) {
                    finalErrors.push.apply(finalErrors, filledErrors);
                  }
                  if (errs && errs.length) {
                    finalErrors.push.apply(finalErrors, errs);
                  }
                  doIt(finalErrors.length ? finalErrors : null);
                });
              }
            }
            var res;
            if (rule.asyncValidator) {
              res = rule.asyncValidator(rule, data.value, cb, data.source, options);
            } else if (rule.validator) {
              try {
                res = rule.validator(rule, data.value, cb, data.source, options);
              } catch (error) {
                console.error == null ? void 0 : console.error(error);
                if (!options.suppressValidatorError) {
                  setTimeout(function() {
                    throw error;
                  }, 0);
                }
                cb(error.message);
              }
              if (res === true) {
                cb();
              } else if (res === false) {
                cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
              } else if (res instanceof Array) {
                cb(res);
              } else if (res instanceof Error) {
                cb(res.message);
              }
            }
            if (res && res.then) {
              res.then(function() {
                return cb();
              }, function(e) {
                return cb(e);
              });
            }
          }, function(results) {
            complete(results);
          }, source);
        };
        _proto.getType = function getType(rule) {
          if (rule.type === void 0 && rule.pattern instanceof RegExp) {
            rule.type = "pattern";
          }
          if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
            throw new Error(format("Unknown rule type %s", rule.type));
          }
          return rule.type || "string";
        };
        _proto.getValidationMethod = function getValidationMethod(rule) {
          if (typeof rule.validator === "function") {
            return rule.validator;
          }
          var keys2 = Object.keys(rule);
          var messageIndex = keys2.indexOf("message");
          if (messageIndex !== -1) {
            keys2.splice(messageIndex, 1);
          }
          if (keys2.length === 1 && keys2[0] === "required") {
            return validators.required;
          }
          return validators[this.getType(rule)] || void 0;
        };
        return Schema2;
      }();
      Schema.register = function register(type4, validator) {
        if (typeof validator !== "function") {
          throw new Error("Cannot register a validator by type, validator is not a function");
        }
        validators[type4] = validator;
      };
      Schema.warning = warning;
      Schema.messages = messages;
      Schema.validators = validators;
      const formItemValidateStates = [
        "",
        "error",
        "validating",
        "success"
      ];
      const formItemProps = buildProps({
        label: String,
        labelWidth: {
          type: [String, Number],
          default: ""
        },
        prop: {
          type: definePropType([String, Array])
        },
        required: {
          type: Boolean,
          default: void 0
        },
        rules: {
          type: definePropType([Object, Array])
        },
        error: String,
        validateStatus: {
          type: String,
          values: formItemValidateStates
        },
        for: String,
        inlineMessage: {
          type: [String, Boolean],
          default: ""
        },
        showMessage: {
          type: Boolean,
          default: true
        },
        size: {
          type: String,
          values: componentSizes
        }
      });
      const COMPONENT_NAME$6 = "ElLabelWrap";
      var FormLabelWrap = defineComponent({
        name: COMPONENT_NAME$6,
        props: {
          isAutoWidth: Boolean,
          updateAll: Boolean
        },
        setup(props, {
          slots
        }) {
          const formContext = inject(formContextKey, void 0);
          const formItemContext = inject(formItemContextKey);
          if (!formItemContext)
            throwError(COMPONENT_NAME$6, "usage: <el-form-item><label-wrap /></el-form-item>");
          const ns = useNamespace("form");
          const el = ref();
          const computedWidth = ref(0);
          const getLabelWidth = () => {
            var _a;
            if ((_a = el.value) == null ? void 0 : _a.firstElementChild) {
              const width = window.getComputedStyle(el.value.firstElementChild).width;
              return Math.ceil(Number.parseFloat(width));
            } else {
              return 0;
            }
          };
          const updateLabelWidth = (action = "update") => {
            nextTick(() => {
              if (slots.default && props.isAutoWidth) {
                if (action === "update") {
                  computedWidth.value = getLabelWidth();
                } else if (action === "remove") {
                  formContext == null ? void 0 : formContext.deregisterLabelWidth(computedWidth.value);
                }
              }
            });
          };
          const updateLabelWidthFn = () => updateLabelWidth("update");
          onMounted(() => {
            updateLabelWidthFn();
          });
          onBeforeUnmount(() => {
            updateLabelWidth("remove");
          });
          onUpdated(() => updateLabelWidthFn());
          watch(computedWidth, (val, oldVal) => {
            if (props.updateAll) {
              formContext == null ? void 0 : formContext.registerLabelWidth(val, oldVal);
            }
          });
          useResizeObserver(computed(() => {
            var _a, _b;
            return (_b = (_a = el.value) == null ? void 0 : _a.firstElementChild) != null ? _b : null;
          }), updateLabelWidthFn);
          return () => {
            var _a, _b;
            if (!slots)
              return null;
            const {
              isAutoWidth
            } = props;
            if (isAutoWidth) {
              const autoLabelWidth = formContext == null ? void 0 : formContext.autoLabelWidth;
              const hasLabel = formItemContext == null ? void 0 : formItemContext.hasLabel;
              const style = {};
              if (hasLabel && autoLabelWidth && autoLabelWidth !== "auto") {
                const marginWidth = Math.max(0, Number.parseInt(autoLabelWidth, 10) - computedWidth.value);
                const marginPosition = formContext.labelPosition === "left" ? "marginRight" : "marginLeft";
                if (marginWidth) {
                  style[marginPosition] = `${marginWidth}px`;
                }
              }
              return createVNode("div", {
                "ref": el,
                "class": [ns.be("item", "label-wrap")],
                "style": style
              }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
            } else {
              return createVNode(Fragment, {
                "ref": el
              }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
            }
          };
        }
      });
      const _hoisted_1$u = ["role", "aria-labelledby"];
      const __default__$n = defineComponent({
        name: "ElFormItem"
      });
      const _sfc_main$K = /* @__PURE__ */ defineComponent({
        ...__default__$n,
        props: formItemProps,
        setup(__props, { expose }) {
          const props = __props;
          const slots = useSlots();
          const formContext = inject(formContextKey, void 0);
          const parentFormItemContext = inject(formItemContextKey, void 0);
          const _size = useFormSize(void 0, { formItem: false });
          const ns = useNamespace("form-item");
          const labelId = useId().value;
          const inputIds = ref([]);
          const validateState = ref("");
          const validateStateDebounced = refDebounced(validateState, 100);
          const validateMessage = ref("");
          const formItemRef = ref();
          let initialValue = void 0;
          let isResettingField = false;
          const labelStyle = computed(() => {
            if ((formContext == null ? void 0 : formContext.labelPosition) === "top") {
              return {};
            }
            const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
            if (labelWidth)
              return { width: labelWidth };
            return {};
          });
          const contentStyle = computed(() => {
            if ((formContext == null ? void 0 : formContext.labelPosition) === "top" || (formContext == null ? void 0 : formContext.inline)) {
              return {};
            }
            if (!props.label && !props.labelWidth && isNested) {
              return {};
            }
            const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
            if (!props.label && !slots.label) {
              return { marginLeft: labelWidth };
            }
            return {};
          });
          const formItemClasses = computed(() => [
            ns.b(),
            ns.m(_size.value),
            ns.is("error", validateState.value === "error"),
            ns.is("validating", validateState.value === "validating"),
            ns.is("success", validateState.value === "success"),
            ns.is("required", isRequired.value || props.required),
            ns.is("no-asterisk", formContext == null ? void 0 : formContext.hideRequiredAsterisk),
            (formContext == null ? void 0 : formContext.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
            { [ns.m("feedback")]: formContext == null ? void 0 : formContext.statusIcon }
          ]);
          const _inlineMessage = computed(() => isBoolean(props.inlineMessage) ? props.inlineMessage : (formContext == null ? void 0 : formContext.inlineMessage) || false);
          const validateClasses = computed(() => [
            ns.e("error"),
            { [ns.em("error", "inline")]: _inlineMessage.value }
          ]);
          const propString = computed(() => {
            if (!props.prop)
              return "";
            return isString(props.prop) ? props.prop : props.prop.join(".");
          });
          const hasLabel = computed(() => {
            return !!(props.label || slots.label);
          });
          const labelFor = computed(() => {
            return props.for || (inputIds.value.length === 1 ? inputIds.value[0] : void 0);
          });
          const isGroup = computed(() => {
            return !labelFor.value && hasLabel.value;
          });
          const isNested = !!parentFormItemContext;
          const fieldValue = computed(() => {
            const model = formContext == null ? void 0 : formContext.model;
            if (!model || !props.prop) {
              return;
            }
            return getProp(model, props.prop).value;
          });
          const normalizedRules = computed(() => {
            const { required: required4 } = props;
            const rules2 = [];
            if (props.rules) {
              rules2.push(...castArray(props.rules));
            }
            const formRules = formContext == null ? void 0 : formContext.rules;
            if (formRules && props.prop) {
              const _rules = getProp(formRules, props.prop).value;
              if (_rules) {
                rules2.push(...castArray(_rules));
              }
            }
            if (required4 !== void 0) {
              const requiredRules = rules2.map((rule, i) => [rule, i]).filter(([rule]) => Object.keys(rule).includes("required"));
              if (requiredRules.length > 0) {
                for (const [rule, i] of requiredRules) {
                  if (rule.required === required4)
                    continue;
                  rules2[i] = { ...rule, required: required4 };
                }
              } else {
                rules2.push({ required: required4 });
              }
            }
            return rules2;
          });
          const validateEnabled = computed(() => normalizedRules.value.length > 0);
          const getFilteredRule = (trigger) => {
            const rules2 = normalizedRules.value;
            return rules2.filter((rule) => {
              if (!rule.trigger || !trigger)
                return true;
              if (Array.isArray(rule.trigger)) {
                return rule.trigger.includes(trigger);
              } else {
                return rule.trigger === trigger;
              }
            }).map(({ trigger: trigger2, ...rule }) => rule);
          };
          const isRequired = computed(() => normalizedRules.value.some((rule) => rule.required));
          const shouldShowError = computed(() => {
            var _a;
            return validateStateDebounced.value === "error" && props.showMessage && ((_a = formContext == null ? void 0 : formContext.showMessage) != null ? _a : true);
          });
          const currentLabel = computed(() => `${props.label || ""}${(formContext == null ? void 0 : formContext.labelSuffix) || ""}`);
          const setValidationState = (state) => {
            validateState.value = state;
          };
          const onValidationFailed = (error) => {
            var _a, _b;
            const { errors, fields } = error;
            if (!errors || !fields) {
              console.error(error);
            }
            setValidationState("error");
            validateMessage.value = errors ? (_b = (_a = errors == null ? void 0 : errors[0]) == null ? void 0 : _a.message) != null ? _b : `${props.prop} is required` : "";
            formContext == null ? void 0 : formContext.emit("validate", props.prop, false, validateMessage.value);
          };
          const onValidationSucceeded = () => {
            setValidationState("success");
            formContext == null ? void 0 : formContext.emit("validate", props.prop, true, "");
          };
          const doValidate = async (rules2) => {
            const modelName = propString.value;
            const validator = new Schema({
              [modelName]: rules2
            });
            return validator.validate({ [modelName]: fieldValue.value }, { firstFields: true }).then(() => {
              onValidationSucceeded();
              return true;
            }).catch((err) => {
              onValidationFailed(err);
              return Promise.reject(err);
            });
          };
          const validate = async (trigger, callback) => {
            if (isResettingField || !props.prop) {
              return false;
            }
            const hasCallback = isFunction$1(callback);
            if (!validateEnabled.value) {
              callback == null ? void 0 : callback(false);
              return false;
            }
            const rules2 = getFilteredRule(trigger);
            if (rules2.length === 0) {
              callback == null ? void 0 : callback(true);
              return true;
            }
            setValidationState("validating");
            return doValidate(rules2).then(() => {
              callback == null ? void 0 : callback(true);
              return true;
            }).catch((err) => {
              const { fields } = err;
              callback == null ? void 0 : callback(false, fields);
              return hasCallback ? false : Promise.reject(fields);
            });
          };
          const clearValidate = () => {
            setValidationState("");
            validateMessage.value = "";
            isResettingField = false;
          };
          const resetField = async () => {
            const model = formContext == null ? void 0 : formContext.model;
            if (!model || !props.prop)
              return;
            const computedValue = getProp(model, props.prop);
            isResettingField = true;
            computedValue.value = clone(initialValue);
            await nextTick();
            clearValidate();
            isResettingField = false;
          };
          const addInputId = (id) => {
            if (!inputIds.value.includes(id)) {
              inputIds.value.push(id);
            }
          };
          const removeInputId = (id) => {
            inputIds.value = inputIds.value.filter((listId) => listId !== id);
          };
          watch(() => props.error, (val) => {
            validateMessage.value = val || "";
            setValidationState(val ? "error" : "");
          }, { immediate: true });
          watch(() => props.validateStatus, (val) => setValidationState(val || ""));
          const context = reactive({
            ...toRefs(props),
            $el: formItemRef,
            size: _size,
            validateState,
            labelId,
            inputIds,
            isGroup,
            hasLabel,
            fieldValue,
            addInputId,
            removeInputId,
            resetField,
            clearValidate,
            validate
          });
          provide(formItemContextKey, context);
          onMounted(() => {
            if (props.prop) {
              formContext == null ? void 0 : formContext.addField(context);
              initialValue = clone(fieldValue.value);
            }
          });
          onBeforeUnmount(() => {
            formContext == null ? void 0 : formContext.removeField(context);
          });
          expose({
            size: _size,
            validateMessage,
            validateState,
            validate,
            clearValidate,
            resetField
          });
          return (_ctx, _cache) => {
            var _a;
            return openBlock(), createElementBlock("div", {
              ref_key: "formItemRef",
              ref: formItemRef,
              class: normalizeClass(unref(formItemClasses)),
              role: unref(isGroup) ? "group" : void 0,
              "aria-labelledby": unref(isGroup) ? unref(labelId) : void 0
            }, [
              createVNode(unref(FormLabelWrap), {
                "is-auto-width": unref(labelStyle).width === "auto",
                "update-all": ((_a = unref(formContext)) == null ? void 0 : _a.labelWidth) === "auto"
              }, {
                default: withCtx(() => [
                  unref(hasLabel) ? (openBlock(), createBlock(resolveDynamicComponent(unref(labelFor) ? "label" : "div"), {
                    key: 0,
                    id: unref(labelId),
                    for: unref(labelFor),
                    class: normalizeClass(unref(ns).e("label")),
                    style: normalizeStyle(unref(labelStyle))
                  }, {
                    default: withCtx(() => [
                      renderSlot(_ctx.$slots, "label", { label: unref(currentLabel) }, () => [
                        createTextVNode(toDisplayString(unref(currentLabel)), 1)
                      ])
                    ]),
                    _: 3
                  }, 8, ["id", "for", "class", "style"])) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["is-auto-width", "update-all"]),
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("content")),
                style: normalizeStyle(unref(contentStyle))
              }, [
                renderSlot(_ctx.$slots, "default"),
                createVNode(TransitionGroup, {
                  name: `${unref(ns).namespace.value}-zoom-in-top`
                }, {
                  default: withCtx(() => [
                    unref(shouldShowError) ? renderSlot(_ctx.$slots, "error", {
                      key: 0,
                      error: validateMessage.value
                    }, () => [
                      createElementVNode("div", {
                        class: normalizeClass(unref(validateClasses))
                      }, toDisplayString(validateMessage.value), 3)
                    ]) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["name"])
              ], 6)
            ], 10, _hoisted_1$u);
          };
        }
      });
      var FormItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$K, [["__file", "form-item.vue"]]);
      const ElForm = withInstall(Form, {
        FormItem
      });
      const ElFormItem = withNoopInstall(FormItem);
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      function getDefaultExportFromCjs(x) {
        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
      }
      var dayjs_min = { exports: {} };
      (function(module, exports) {
        !function(t, e) {
          module.exports = e();
        }(commonjsGlobal, function() {
          var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h2 = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
            var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
            return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
          } }, m = function(t2, e2, n2) {
            var r2 = String(t2);
            return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
          }, v = { s: m, z: function(t2) {
            var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
            return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
          }, m: function t2(e2, n2) {
            if (e2.date() < n2.date())
              return -t2(n2, e2);
            var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
            return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
          }, a: function(t2) {
            return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
          }, p: function(t2) {
            return { M: c, y: h2, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
          }, u: function(t2) {
            return void 0 === t2;
          } }, g = "en", D = {};
          D[g] = M;
          var p = "$isDayjsObject", S = function(t2) {
            return t2 instanceof _ || !(!t2 || !t2[p]);
          }, w = function t2(e2, n2, r2) {
            var i2;
            if (!e2)
              return g;
            if ("string" == typeof e2) {
              var s2 = e2.toLowerCase();
              D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
              var u2 = e2.split("-");
              if (!i2 && u2.length > 1)
                return t2(u2[0]);
            } else {
              var a2 = e2.name;
              D[a2] = e2, i2 = a2;
            }
            return !r2 && i2 && (g = i2), i2 || !r2 && g;
          }, O = function(t2, e2) {
            if (S(t2))
              return t2.clone();
            var n2 = "object" == typeof e2 ? e2 : {};
            return n2.date = t2, n2.args = arguments, new _(n2);
          }, b = v;
          b.l = w, b.i = S, b.w = function(t2, e2) {
            return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
          };
          var _ = function() {
            function M2(t2) {
              this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
            }
            var m2 = M2.prototype;
            return m2.parse = function(t2) {
              this.$d = function(t3) {
                var e2 = t3.date, n2 = t3.utc;
                if (null === e2)
                  return /* @__PURE__ */ new Date(NaN);
                if (b.u(e2))
                  return /* @__PURE__ */ new Date();
                if (e2 instanceof Date)
                  return new Date(e2);
                if ("string" == typeof e2 && !/Z$/i.test(e2)) {
                  var r2 = e2.match($);
                  if (r2) {
                    var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                    return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
                  }
                }
                return new Date(e2);
              }(t2), this.init();
            }, m2.init = function() {
              var t2 = this.$d;
              this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
            }, m2.$utils = function() {
              return b;
            }, m2.isValid = function() {
              return !(this.$d.toString() === l);
            }, m2.isSame = function(t2, e2) {
              var n2 = O(t2);
              return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
            }, m2.isAfter = function(t2, e2) {
              return O(t2) < this.startOf(e2);
            }, m2.isBefore = function(t2, e2) {
              return this.endOf(e2) < O(t2);
            }, m2.$g = function(t2, e2, n2) {
              return b.u(t2) ? this[e2] : this.set(n2, t2);
            }, m2.unix = function() {
              return Math.floor(this.valueOf() / 1e3);
            }, m2.valueOf = function() {
              return this.$d.getTime();
            }, m2.startOf = function(t2, e2) {
              var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function(t3, e3) {
                var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
                return r2 ? i2 : i2.endOf(a);
              }, $2 = function(t3, e3) {
                return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
              }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
              switch (f2) {
                case h2:
                  return r2 ? l2(1, 0) : l2(31, 11);
                case c:
                  return r2 ? l2(1, M3) : l2(0, M3 + 1);
                case o:
                  var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
                  return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
                case a:
                case d:
                  return $2(v2 + "Hours", 0);
                case u:
                  return $2(v2 + "Minutes", 1);
                case s:
                  return $2(v2 + "Seconds", 2);
                case i:
                  return $2(v2 + "Milliseconds", 3);
                default:
                  return this.clone();
              }
            }, m2.endOf = function(t2) {
              return this.startOf(t2, false);
            }, m2.$set = function(t2, e2) {
              var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h2] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
              if (o2 === c || o2 === h2) {
                var y2 = this.clone().set(d, 1);
                y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
              } else
                l2 && this.$d[l2]($2);
              return this.init(), this;
            }, m2.set = function(t2, e2) {
              return this.clone().$set(t2, e2);
            }, m2.get = function(t2) {
              return this[b.p(t2)]();
            }, m2.add = function(r2, f2) {
              var d2, l2 = this;
              r2 = Number(r2);
              var $2 = b.p(f2), y2 = function(t2) {
                var e2 = O(l2);
                return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
              };
              if ($2 === c)
                return this.set(c, this.$M + r2);
              if ($2 === h2)
                return this.set(h2, this.$y + r2);
              if ($2 === a)
                return y2(1);
              if ($2 === o)
                return y2(7);
              var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
              return b.w(m3, this);
            }, m2.subtract = function(t2, e2) {
              return this.add(-1 * t2, e2);
            }, m2.format = function(t2) {
              var e2 = this, n2 = this.$locale();
              if (!this.isValid())
                return n2.invalidDate || l;
              var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h3 = function(t3, n3, i3, s3) {
                return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
              }, d2 = function(t3) {
                return b.s(s2 % 12 || 12, t3, "0");
              }, $2 = f2 || function(t3, e3, n3) {
                var r3 = t3 < 12 ? "AM" : "PM";
                return n3 ? r3.toLowerCase() : r3;
              };
              return r2.replace(y, function(t3, r3) {
                return r3 || function(t4) {
                  switch (t4) {
                    case "YY":
                      return String(e2.$y).slice(-2);
                    case "YYYY":
                      return b.s(e2.$y, 4, "0");
                    case "M":
                      return a2 + 1;
                    case "MM":
                      return b.s(a2 + 1, 2, "0");
                    case "MMM":
                      return h3(n2.monthsShort, a2, c2, 3);
                    case "MMMM":
                      return h3(c2, a2);
                    case "D":
                      return e2.$D;
                    case "DD":
                      return b.s(e2.$D, 2, "0");
                    case "d":
                      return String(e2.$W);
                    case "dd":
                      return h3(n2.weekdaysMin, e2.$W, o2, 2);
                    case "ddd":
                      return h3(n2.weekdaysShort, e2.$W, o2, 3);
                    case "dddd":
                      return o2[e2.$W];
                    case "H":
                      return String(s2);
                    case "HH":
                      return b.s(s2, 2, "0");
                    case "h":
                      return d2(1);
                    case "hh":
                      return d2(2);
                    case "a":
                      return $2(s2, u2, true);
                    case "A":
                      return $2(s2, u2, false);
                    case "m":
                      return String(u2);
                    case "mm":
                      return b.s(u2, 2, "0");
                    case "s":
                      return String(e2.$s);
                    case "ss":
                      return b.s(e2.$s, 2, "0");
                    case "SSS":
                      return b.s(e2.$ms, 3, "0");
                    case "Z":
                      return i2;
                  }
                  return null;
                }(t3) || i2.replace(":", "");
              });
            }, m2.utcOffset = function() {
              return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
            }, m2.diff = function(r2, d2, l2) {
              var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
                return b.m(y2, m3);
              };
              switch (M3) {
                case h2:
                  $2 = D2() / 12;
                  break;
                case c:
                  $2 = D2();
                  break;
                case f:
                  $2 = D2() / 3;
                  break;
                case o:
                  $2 = (g2 - v2) / 6048e5;
                  break;
                case a:
                  $2 = (g2 - v2) / 864e5;
                  break;
                case u:
                  $2 = g2 / n;
                  break;
                case s:
                  $2 = g2 / e;
                  break;
                case i:
                  $2 = g2 / t;
                  break;
                default:
                  $2 = g2;
              }
              return l2 ? $2 : b.a($2);
            }, m2.daysInMonth = function() {
              return this.endOf(c).$D;
            }, m2.$locale = function() {
              return D[this.$L];
            }, m2.locale = function(t2, e2) {
              if (!t2)
                return this.$L;
              var n2 = this.clone(), r2 = w(t2, e2, true);
              return r2 && (n2.$L = r2), n2;
            }, m2.clone = function() {
              return b.w(this.$d, this);
            }, m2.toDate = function() {
              return new Date(this.valueOf());
            }, m2.toJSON = function() {
              return this.isValid() ? this.toISOString() : null;
            }, m2.toISOString = function() {
              return this.$d.toISOString();
            }, m2.toString = function() {
              return this.$d.toUTCString();
            }, M2;
          }(), k = _.prototype;
          return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h2], ["$D", d]].forEach(function(t2) {
            k[t2[1]] = function(e2) {
              return this.$g(e2, t2[0], t2[1]);
            };
          }), O.extend = function(t2, e2) {
            return t2.$i || (t2(e2, _, O), t2.$i = true), O;
          }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
            return O(1e3 * t2);
          }, O.en = D[g], O.Ls = D, O.p = {}, O;
        });
      })(dayjs_min);
      var dayjs_minExports = dayjs_min.exports;
      const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
      var customParseFormat$1 = { exports: {} };
      (function(module, exports) {
        !function(e, t) {
          module.exports = t();
        }(commonjsGlobal, function() {
          var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d\d/, r = /\d\d?/, i = /\d*[^-_:/,()\s\d]+/, o = {}, s = function(e2) {
            return (e2 = +e2) + (e2 > 68 ? 1900 : 2e3);
          };
          var a = function(e2) {
            return function(t2) {
              this[e2] = +t2;
            };
          }, f = [/[+-]\d\d:?(\d\d)?|Z/, function(e2) {
            (this.zone || (this.zone = {})).offset = function(e3) {
              if (!e3)
                return 0;
              if ("Z" === e3)
                return 0;
              var t2 = e3.match(/([+-]|\d\d)/g), n2 = 60 * t2[1] + (+t2[2] || 0);
              return 0 === n2 ? 0 : "+" === t2[0] ? -n2 : n2;
            }(e2);
          }], h2 = function(e2) {
            var t2 = o[e2];
            return t2 && (t2.indexOf ? t2 : t2.s.concat(t2.f));
          }, u = function(e2, t2) {
            var n2, r2 = o.meridiem;
            if (r2) {
              for (var i2 = 1; i2 <= 24; i2 += 1)
                if (e2.indexOf(r2(i2, 0, t2)) > -1) {
                  n2 = i2 > 12;
                  break;
                }
            } else
              n2 = e2 === (t2 ? "pm" : "PM");
            return n2;
          }, d = { A: [i, function(e2) {
            this.afternoon = u(e2, false);
          }], a: [i, function(e2) {
            this.afternoon = u(e2, true);
          }], S: [/\d/, function(e2) {
            this.milliseconds = 100 * +e2;
          }], SS: [n, function(e2) {
            this.milliseconds = 10 * +e2;
          }], SSS: [/\d{3}/, function(e2) {
            this.milliseconds = +e2;
          }], s: [r, a("seconds")], ss: [r, a("seconds")], m: [r, a("minutes")], mm: [r, a("minutes")], H: [r, a("hours")], h: [r, a("hours")], HH: [r, a("hours")], hh: [r, a("hours")], D: [r, a("day")], DD: [n, a("day")], Do: [i, function(e2) {
            var t2 = o.ordinal, n2 = e2.match(/\d+/);
            if (this.day = n2[0], t2)
              for (var r2 = 1; r2 <= 31; r2 += 1)
                t2(r2).replace(/\[|\]/g, "") === e2 && (this.day = r2);
          }], M: [r, a("month")], MM: [n, a("month")], MMM: [i, function(e2) {
            var t2 = h2("months"), n2 = (h2("monthsShort") || t2.map(function(e3) {
              return e3.slice(0, 3);
            })).indexOf(e2) + 1;
            if (n2 < 1)
              throw new Error();
            this.month = n2 % 12 || n2;
          }], MMMM: [i, function(e2) {
            var t2 = h2("months").indexOf(e2) + 1;
            if (t2 < 1)
              throw new Error();
            this.month = t2 % 12 || t2;
          }], Y: [/[+-]?\d+/, a("year")], YY: [n, function(e2) {
            this.year = s(e2);
          }], YYYY: [/\d{4}/, a("year")], Z: f, ZZ: f };
          function c(n2) {
            var r2, i2;
            r2 = n2, i2 = o && o.formats;
            for (var s2 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t2, n3, r3) {
              var o2 = r3 && r3.toUpperCase();
              return n3 || i2[r3] || e[r3] || i2[o2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t3, n4) {
                return t3 || n4.slice(1);
              });
            })).match(t), a2 = s2.length, f2 = 0; f2 < a2; f2 += 1) {
              var h3 = s2[f2], u2 = d[h3], c2 = u2 && u2[0], l = u2 && u2[1];
              s2[f2] = l ? { regex: c2, parser: l } : h3.replace(/^\[|\]$/g, "");
            }
            return function(e2) {
              for (var t2 = {}, n3 = 0, r3 = 0; n3 < a2; n3 += 1) {
                var i3 = s2[n3];
                if ("string" == typeof i3)
                  r3 += i3.length;
                else {
                  var o2 = i3.regex, f3 = i3.parser, h4 = e2.slice(r3), u3 = o2.exec(h4)[0];
                  f3.call(t2, u3), e2 = e2.replace(u3, "");
                }
              }
              return function(e3) {
                var t3 = e3.afternoon;
                if (void 0 !== t3) {
                  var n4 = e3.hours;
                  t3 ? n4 < 12 && (e3.hours += 12) : 12 === n4 && (e3.hours = 0), delete e3.afternoon;
                }
              }(t2), t2;
            };
          }
          return function(e2, t2, n2) {
            n2.p.customParseFormat = true, e2 && e2.parseTwoDigitYear && (s = e2.parseTwoDigitYear);
            var r2 = t2.prototype, i2 = r2.parse;
            r2.parse = function(e3) {
              var t3 = e3.date, r3 = e3.utc, s2 = e3.args;
              this.$u = r3;
              var a2 = s2[1];
              if ("string" == typeof a2) {
                var f2 = true === s2[2], h3 = true === s2[3], u2 = f2 || h3, d2 = s2[2];
                h3 && (d2 = s2[2]), o = this.$locale(), !f2 && d2 && (o = n2.Ls[d2]), this.$d = function(e4, t4, n3) {
                  try {
                    if (["x", "X"].indexOf(t4) > -1)
                      return new Date(("X" === t4 ? 1e3 : 1) * e4);
                    var r4 = c(t4)(e4), i3 = r4.year, o2 = r4.month, s3 = r4.day, a3 = r4.hours, f3 = r4.minutes, h4 = r4.seconds, u3 = r4.milliseconds, d3 = r4.zone, l2 = /* @__PURE__ */ new Date(), m2 = s3 || (i3 || o2 ? 1 : l2.getDate()), M2 = i3 || l2.getFullYear(), Y = 0;
                    i3 && !o2 || (Y = o2 > 0 ? o2 - 1 : l2.getMonth());
                    var p = a3 || 0, v = f3 || 0, D = h4 || 0, g = u3 || 0;
                    return d3 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g + 60 * d3.offset * 1e3)) : n3 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g)) : new Date(M2, Y, m2, p, v, D, g);
                  } catch (e5) {
                    return /* @__PURE__ */ new Date("");
                  }
                }(t3, a2, r3), this.init(), d2 && true !== d2 && (this.$L = this.locale(d2).$L), u2 && t3 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), o = {};
              } else if (a2 instanceof Array)
                for (var l = a2.length, m = 1; m <= l; m += 1) {
                  s2[1] = a2[m - 1];
                  var M = n2.apply(this, s2);
                  if (M.isValid()) {
                    this.$d = M.$d, this.$L = M.$L, this.init();
                    break;
                  }
                  m === l && (this.$d = /* @__PURE__ */ new Date(""));
                }
              else
                i2.call(this, e3);
            };
          };
        });
      })(customParseFormat$1);
      var customParseFormatExports = customParseFormat$1.exports;
      const customParseFormat = /* @__PURE__ */ getDefaultExportFromCjs(customParseFormatExports);
      const timeUnits = ["hours", "minutes", "seconds"];
      const DEFAULT_FORMATS_TIME = "HH:mm:ss";
      const buildTimeList = (value, bound) => {
        return [
          value > 0 ? value - 1 : void 0,
          value,
          value < bound ? value + 1 : void 0
        ];
      };
      const dateEquals = function(a, b) {
        const aIsDate = isDate(a);
        const bIsDate = isDate(b);
        if (aIsDate && bIsDate) {
          return a.getTime() === b.getTime();
        }
        if (!aIsDate && !bIsDate) {
          return a === b;
        }
        return false;
      };
      const valueEquals = function(a, b) {
        const aIsArray = isArray$1(a);
        const bIsArray = isArray$1(b);
        if (aIsArray && bIsArray) {
          if (a.length !== b.length) {
            return false;
          }
          return a.every((item, index) => dateEquals(item, b[index]));
        }
        if (!aIsArray && !bIsArray) {
          return dateEquals(a, b);
        }
        return false;
      };
      const parseDate = function(date4, format2, lang) {
        const day = isEmpty(format2) || format2 === "x" ? dayjs(date4).locale(lang) : dayjs(date4, format2).locale(lang);
        return day.isValid() ? day : void 0;
      };
      const formatter = function(date4, format2, lang) {
        if (isEmpty(format2))
          return date4;
        if (format2 === "x")
          return +date4;
        return dayjs(date4).locale(lang).format(format2);
      };
      const makeList = (total, method4) => {
        var _a;
        const arr = [];
        const disabledArr = method4 == null ? void 0 : method4();
        for (let i = 0; i < total; i++) {
          arr.push((_a = disabledArr == null ? void 0 : disabledArr.includes(i)) != null ? _a : false);
        }
        return arr;
      };
      const disabledTimeListsProps = buildProps({
        disabledHours: {
          type: definePropType(Function)
        },
        disabledMinutes: {
          type: definePropType(Function)
        },
        disabledSeconds: {
          type: definePropType(Function)
        }
      });
      const timePanelSharedProps = buildProps({
        visible: Boolean,
        actualVisible: {
          type: Boolean,
          default: void 0
        },
        format: {
          type: String,
          default: ""
        }
      });
      const timePickerDefaultProps = buildProps({
        id: {
          type: definePropType([Array, String])
        },
        name: {
          type: definePropType([Array, String]),
          default: ""
        },
        popperClass: {
          type: String,
          default: ""
        },
        format: String,
        valueFormat: String,
        dateFormat: String,
        timeFormat: String,
        type: {
          type: String,
          default: ""
        },
        clearable: {
          type: Boolean,
          default: true
        },
        clearIcon: {
          type: definePropType([String, Object]),
          default: circle_close_default
        },
        editable: {
          type: Boolean,
          default: true
        },
        prefixIcon: {
          type: definePropType([String, Object]),
          default: ""
        },
        size: useSizeProp,
        readonly: Boolean,
        disabled: Boolean,
        placeholder: {
          type: String,
          default: ""
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        modelValue: {
          type: definePropType([Date, Array, String, Number]),
          default: ""
        },
        rangeSeparator: {
          type: String,
          default: "-"
        },
        startPlaceholder: String,
        endPlaceholder: String,
        defaultValue: {
          type: definePropType([Date, Array])
        },
        defaultTime: {
          type: definePropType([Date, Array])
        },
        isRange: Boolean,
        ...disabledTimeListsProps,
        disabledDate: {
          type: Function
        },
        cellClassName: {
          type: Function
        },
        shortcuts: {
          type: Array,
          default: () => []
        },
        arrowControl: Boolean,
        label: {
          type: String,
          default: void 0
        },
        tabindex: {
          type: definePropType([String, Number]),
          default: 0
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        unlinkPanels: Boolean,
        ...useEmptyValuesProps
      });
      const _hoisted_1$t = ["id", "name", "placeholder", "value", "disabled", "readonly"];
      const _hoisted_2$n = ["id", "name", "placeholder", "value", "disabled", "readonly"];
      const __default__$m = defineComponent({
        name: "Picker"
      });
      const _sfc_main$J = /* @__PURE__ */ defineComponent({
        ...__default__$m,
        props: timePickerDefaultProps,
        emits: [
          "update:modelValue",
          "change",
          "focus",
          "blur",
          "calendar-change",
          "panel-change",
          "visible-change",
          "keydown"
        ],
        setup(__props, { expose, emit }) {
          const props = __props;
          const attrs = useAttrs();
          const { lang } = useLocale();
          const nsDate = useNamespace("date");
          const nsInput = useNamespace("input");
          const nsRange = useNamespace("range");
          const { form, formItem } = useFormItem();
          const elPopperOptions = inject("ElPopperOptions", {});
          const { valueOnClear } = useEmptyValues(props, null);
          const refPopper = ref();
          const inputRef = ref();
          const pickerVisible = ref(false);
          const pickerActualVisible = ref(false);
          const valueOnOpen = ref(null);
          let hasJustTabExitedInput = false;
          let ignoreFocusEvent = false;
          const rangeInputKls = computed(() => [
            nsDate.b("editor"),
            nsDate.bm("editor", props.type),
            nsInput.e("wrapper"),
            nsDate.is("disabled", pickerDisabled.value),
            nsDate.is("active", pickerVisible.value),
            nsRange.b("editor"),
            pickerSize ? nsRange.bm("editor", pickerSize.value) : "",
            attrs.class
          ]);
          const clearIconKls = computed(() => [
            nsInput.e("icon"),
            nsRange.e("close-icon"),
            !showClose.value ? nsRange.e("close-icon--hidden") : ""
          ]);
          watch(pickerVisible, (val) => {
            if (!val) {
              userInput.value = null;
              nextTick(() => {
                emitChange(props.modelValue);
              });
            } else {
              nextTick(() => {
                if (val) {
                  valueOnOpen.value = props.modelValue;
                }
              });
            }
          });
          const emitChange = (val, isClear) => {
            if (isClear || !valueEquals(val, valueOnOpen.value)) {
              emit("change", val);
              props.validateEvent && (formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn()));
            }
          };
          const emitInput = (input) => {
            if (!valueEquals(props.modelValue, input)) {
              let formatted;
              if (isArray$1(input)) {
                formatted = input.map((item) => formatter(item, props.valueFormat, lang.value));
              } else if (input) {
                formatted = formatter(input, props.valueFormat, lang.value);
              }
              emit("update:modelValue", input ? formatted : input, lang.value);
            }
          };
          const emitKeydown = (e) => {
            emit("keydown", e);
          };
          const refInput = computed(() => {
            if (inputRef.value) {
              const _r = isRangeInput.value ? inputRef.value : inputRef.value.$el;
              return Array.from(_r.querySelectorAll("input"));
            }
            return [];
          });
          const setSelectionRange = (start, end, pos) => {
            const _inputs = refInput.value;
            if (!_inputs.length)
              return;
            if (!pos || pos === "min") {
              _inputs[0].setSelectionRange(start, end);
              _inputs[0].focus();
            } else if (pos === "max") {
              _inputs[1].setSelectionRange(start, end);
              _inputs[1].focus();
            }
          };
          const focusOnInputBox = () => {
            focus(true, true);
            nextTick(() => {
              ignoreFocusEvent = false;
            });
          };
          const onPick = (date4 = "", visible = false) => {
            if (!visible) {
              ignoreFocusEvent = true;
            }
            pickerVisible.value = visible;
            let result;
            if (isArray$1(date4)) {
              result = date4.map((_) => _.toDate());
            } else {
              result = date4 ? date4.toDate() : date4;
            }
            userInput.value = null;
            emitInput(result);
          };
          const onBeforeShow = () => {
            pickerActualVisible.value = true;
          };
          const onShow = () => {
            emit("visible-change", true);
          };
          const onKeydownPopperContent = (event) => {
            if ((event == null ? void 0 : event.key) === EVENT_CODE.esc) {
              focus(true, true);
            }
          };
          const onHide = () => {
            pickerActualVisible.value = false;
            pickerVisible.value = false;
            ignoreFocusEvent = false;
            emit("visible-change", false);
          };
          const handleOpen = () => {
            pickerVisible.value = true;
          };
          const handleClose = () => {
            pickerVisible.value = false;
          };
          const focus = (focusStartInput = true, isIgnoreFocusEvent = false) => {
            ignoreFocusEvent = isIgnoreFocusEvent;
            const [leftInput, rightInput] = unref(refInput);
            let input = leftInput;
            if (!focusStartInput && isRangeInput.value) {
              input = rightInput;
            }
            if (input) {
              input.focus();
            }
          };
          const handleFocusInput = (e) => {
            if (props.readonly || pickerDisabled.value || pickerVisible.value || ignoreFocusEvent) {
              return;
            }
            pickerVisible.value = true;
            emit("focus", e);
          };
          let currentHandleBlurDeferCallback = void 0;
          const handleBlurInput = (e) => {
            const handleBlurDefer = async () => {
              setTimeout(() => {
                var _a;
                if (currentHandleBlurDeferCallback === handleBlurDefer) {
                  if (!(((_a = refPopper.value) == null ? void 0 : _a.isFocusInsideContent()) && !hasJustTabExitedInput) && refInput.value.filter((input) => {
                    return input.contains(document.activeElement);
                  }).length === 0) {
                    handleChange();
                    pickerVisible.value = false;
                    emit("blur", e);
                    props.validateEvent && (formItem == null ? void 0 : formItem.validate("blur").catch((err) => debugWarn()));
                  }
                  hasJustTabExitedInput = false;
                }
              }, 0);
            };
            currentHandleBlurDeferCallback = handleBlurDefer;
            handleBlurDefer();
          };
          const pickerDisabled = computed(() => {
            return props.disabled || (form == null ? void 0 : form.disabled);
          });
          const parsedValue = computed(() => {
            let dayOrDays;
            if (valueIsEmpty.value) {
              if (pickerOptions.value.getDefaultValue) {
                dayOrDays = pickerOptions.value.getDefaultValue();
              }
            } else {
              if (isArray$1(props.modelValue)) {
                dayOrDays = props.modelValue.map((d) => parseDate(d, props.valueFormat, lang.value));
              } else {
                dayOrDays = parseDate(props.modelValue, props.valueFormat, lang.value);
              }
            }
            if (pickerOptions.value.getRangeAvailableTime) {
              const availableResult = pickerOptions.value.getRangeAvailableTime(dayOrDays);
              if (!isEqual(availableResult, dayOrDays)) {
                dayOrDays = availableResult;
                emitInput(isArray$1(dayOrDays) ? dayOrDays.map((_) => _.toDate()) : dayOrDays.toDate());
              }
            }
            if (isArray$1(dayOrDays) && dayOrDays.some((day) => !day)) {
              dayOrDays = [];
            }
            return dayOrDays;
          });
          const displayValue = computed(() => {
            if (!pickerOptions.value.panelReady)
              return "";
            const formattedValue = formatDayjsToString(parsedValue.value);
            if (isArray$1(userInput.value)) {
              return [
                userInput.value[0] || formattedValue && formattedValue[0] || "",
                userInput.value[1] || formattedValue && formattedValue[1] || ""
              ];
            } else if (userInput.value !== null) {
              return userInput.value;
            }
            if (!isTimePicker.value && valueIsEmpty.value)
              return "";
            if (!pickerVisible.value && valueIsEmpty.value)
              return "";
            if (formattedValue) {
              return isDatesPicker.value || isYearsPicker.value ? formattedValue.join(", ") : formattedValue;
            }
            return "";
          });
          const isTimeLikePicker = computed(() => props.type.includes("time"));
          const isTimePicker = computed(() => props.type.startsWith("time"));
          const isDatesPicker = computed(() => props.type === "dates");
          const isYearsPicker = computed(() => props.type === "years");
          const triggerIcon = computed(() => props.prefixIcon || (isTimeLikePicker.value ? clock_default : calendar_default));
          const showClose = ref(false);
          const onClearIconClick = (event) => {
            if (props.readonly || pickerDisabled.value)
              return;
            if (showClose.value) {
              event.stopPropagation();
              focusOnInputBox();
              emitInput(valueOnClear.value);
              emitChange(valueOnClear.value, true);
              showClose.value = false;
              pickerVisible.value = false;
              pickerOptions.value.handleClear && pickerOptions.value.handleClear();
            }
          };
          const valueIsEmpty = computed(() => {
            const { modelValue } = props;
            return !modelValue || isArray$1(modelValue) && !modelValue.filter(Boolean).length;
          });
          const onMouseDownInput = async (event) => {
            var _a;
            if (props.readonly || pickerDisabled.value)
              return;
            if (((_a = event.target) == null ? void 0 : _a.tagName) !== "INPUT" || refInput.value.includes(document.activeElement)) {
              pickerVisible.value = true;
            }
          };
          const onMouseEnter = () => {
            if (props.readonly || pickerDisabled.value)
              return;
            if (!valueIsEmpty.value && props.clearable) {
              showClose.value = true;
            }
          };
          const onMouseLeave = () => {
            showClose.value = false;
          };
          const onTouchStartInput = (event) => {
            var _a;
            if (props.readonly || pickerDisabled.value)
              return;
            if (((_a = event.touches[0].target) == null ? void 0 : _a.tagName) !== "INPUT" || refInput.value.includes(document.activeElement)) {
              pickerVisible.value = true;
            }
          };
          const isRangeInput = computed(() => {
            return props.type.includes("range");
          });
          const pickerSize = useFormSize();
          const popperEl = computed(() => {
            var _a, _b;
            return (_b = (_a = unref(refPopper)) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef;
          });
          const actualInputRef = computed(() => {
            var _a;
            if (unref(isRangeInput)) {
              return unref(inputRef);
            }
            return (_a = unref(inputRef)) == null ? void 0 : _a.$el;
          });
          onClickOutside(actualInputRef, (e) => {
            const unrefedPopperEl = unref(popperEl);
            const inputEl = unref(actualInputRef);
            if (unrefedPopperEl && (e.target === unrefedPopperEl || e.composedPath().includes(unrefedPopperEl)) || e.target === inputEl || e.composedPath().includes(inputEl))
              return;
            pickerVisible.value = false;
          });
          const userInput = ref(null);
          const handleChange = () => {
            if (userInput.value) {
              const value = parseUserInputToDayjs(displayValue.value);
              if (value) {
                if (isValidValue(value)) {
                  emitInput(isArray$1(value) ? value.map((_) => _.toDate()) : value.toDate());
                  userInput.value = null;
                }
              }
            }
            if (userInput.value === "") {
              emitInput(valueOnClear.value);
              emitChange(valueOnClear.value);
              userInput.value = null;
            }
          };
          const parseUserInputToDayjs = (value) => {
            if (!value)
              return null;
            return pickerOptions.value.parseUserInput(value);
          };
          const formatDayjsToString = (value) => {
            if (!value)
              return null;
            return pickerOptions.value.formatToString(value);
          };
          const isValidValue = (value) => {
            return pickerOptions.value.isValidValue(value);
          };
          const handleKeydownInput = async (event) => {
            if (props.readonly || pickerDisabled.value)
              return;
            const { code } = event;
            emitKeydown(event);
            if (code === EVENT_CODE.esc) {
              if (pickerVisible.value === true) {
                pickerVisible.value = false;
                event.preventDefault();
                event.stopPropagation();
              }
              return;
            }
            if (code === EVENT_CODE.down) {
              if (pickerOptions.value.handleFocusPicker) {
                event.preventDefault();
                event.stopPropagation();
              }
              if (pickerVisible.value === false) {
                pickerVisible.value = true;
                await nextTick();
              }
              if (pickerOptions.value.handleFocusPicker) {
                pickerOptions.value.handleFocusPicker();
                return;
              }
            }
            if (code === EVENT_CODE.tab) {
              hasJustTabExitedInput = true;
              return;
            }
            if (code === EVENT_CODE.enter || code === EVENT_CODE.numpadEnter) {
              if (userInput.value === null || userInput.value === "" || isValidValue(parseUserInputToDayjs(displayValue.value))) {
                handleChange();
                pickerVisible.value = false;
              }
              event.stopPropagation();
              return;
            }
            if (userInput.value) {
              event.stopPropagation();
              return;
            }
            if (pickerOptions.value.handleKeydownInput) {
              pickerOptions.value.handleKeydownInput(event);
            }
          };
          const onUserInput = (e) => {
            userInput.value = e;
            if (!pickerVisible.value) {
              pickerVisible.value = true;
            }
          };
          const handleStartInput = (event) => {
            const target = event.target;
            if (userInput.value) {
              userInput.value = [target.value, userInput.value[1]];
            } else {
              userInput.value = [target.value, null];
            }
          };
          const handleEndInput = (event) => {
            const target = event.target;
            if (userInput.value) {
              userInput.value = [userInput.value[0], target.value];
            } else {
              userInput.value = [null, target.value];
            }
          };
          const handleStartChange = () => {
            var _a;
            const values = userInput.value;
            const value = parseUserInputToDayjs(values && values[0]);
            const parsedVal = unref(parsedValue);
            if (value && value.isValid()) {
              userInput.value = [
                formatDayjsToString(value),
                ((_a = displayValue.value) == null ? void 0 : _a[1]) || null
              ];
              const newValue = [value, parsedVal && (parsedVal[1] || null)];
              if (isValidValue(newValue)) {
                emitInput(newValue);
                userInput.value = null;
              }
            }
          };
          const handleEndChange = () => {
            var _a;
            const values = unref(userInput);
            const value = parseUserInputToDayjs(values && values[1]);
            const parsedVal = unref(parsedValue);
            if (value && value.isValid()) {
              userInput.value = [
                ((_a = unref(displayValue)) == null ? void 0 : _a[0]) || null,
                formatDayjsToString(value)
              ];
              const newValue = [parsedVal && parsedVal[0], value];
              if (isValidValue(newValue)) {
                emitInput(newValue);
                userInput.value = null;
              }
            }
          };
          const pickerOptions = ref({});
          const onSetPickerOption = (e) => {
            pickerOptions.value[e[0]] = e[1];
            pickerOptions.value.panelReady = true;
          };
          const onCalendarChange = (e) => {
            emit("calendar-change", e);
          };
          const onPanelChange = (value, mode, view) => {
            emit("panel-change", value, mode, view);
          };
          provide("EP_PICKER_BASE", {
            props
          });
          expose({
            focus,
            handleFocusInput,
            handleBlurInput,
            handleOpen,
            handleClose,
            onPick
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElTooltip), mergeProps({
              ref_key: "refPopper",
              ref: refPopper,
              visible: pickerVisible.value,
              effect: "light",
              pure: "",
              trigger: "click"
            }, _ctx.$attrs, {
              role: "dialog",
              teleported: "",
              transition: `${unref(nsDate).namespace.value}-zoom-in-top`,
              "popper-class": [`${unref(nsDate).namespace.value}-picker__popper`, _ctx.popperClass],
              "popper-options": unref(elPopperOptions),
              "fallback-placements": ["bottom", "top", "right", "left"],
              "gpu-acceleration": false,
              "stop-popper-mouse-event": false,
              "hide-after": 0,
              persistent: "",
              onBeforeShow,
              onShow,
              onHide
            }), {
              default: withCtx(() => [
                !unref(isRangeInput) ? (openBlock(), createBlock(unref(ElInput), {
                  key: 0,
                  id: _ctx.id,
                  ref_key: "inputRef",
                  ref: inputRef,
                  "container-role": "combobox",
                  "model-value": unref(displayValue),
                  name: _ctx.name,
                  size: unref(pickerSize),
                  disabled: unref(pickerDisabled),
                  placeholder: _ctx.placeholder,
                  class: normalizeClass([unref(nsDate).b("editor"), unref(nsDate).bm("editor", _ctx.type), _ctx.$attrs.class]),
                  style: normalizeStyle(_ctx.$attrs.style),
                  readonly: !_ctx.editable || _ctx.readonly || unref(isDatesPicker) || unref(isYearsPicker) || _ctx.type === "week",
                  label: _ctx.label,
                  tabindex: _ctx.tabindex,
                  "validate-event": false,
                  onInput: onUserInput,
                  onFocus: handleFocusInput,
                  onBlur: handleBlurInput,
                  onKeydown: handleKeydownInput,
                  onChange: handleChange,
                  onMousedown: onMouseDownInput,
                  onMouseenter: onMouseEnter,
                  onMouseleave: onMouseLeave,
                  onTouchstart: onTouchStartInput,
                  onClick: _cache[0] || (_cache[0] = withModifiers(() => {
                  }, ["stop"]))
                }, {
                  prefix: withCtx(() => [
                    unref(triggerIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass(unref(nsInput).e("icon")),
                      onMousedown: withModifiers(onMouseDownInput, ["prevent"]),
                      onTouchstart: onTouchStartInput
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(unref(triggerIcon))))
                      ]),
                      _: 1
                    }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true)
                  ]),
                  suffix: withCtx(() => [
                    showClose.value && _ctx.clearIcon ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass(`${unref(nsInput).e("icon")} clear-icon`),
                      onClick: withModifiers(onClearIconClick, ["stop"])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                      ]),
                      _: 1
                    }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 1
                }, 8, ["id", "model-value", "name", "size", "disabled", "placeholder", "class", "style", "readonly", "label", "tabindex", "onKeydown"])) : (openBlock(), createElementBlock("div", {
                  key: 1,
                  ref_key: "inputRef",
                  ref: inputRef,
                  class: normalizeClass(unref(rangeInputKls)),
                  style: normalizeStyle(_ctx.$attrs.style),
                  onClick: handleFocusInput,
                  onMouseenter: onMouseEnter,
                  onMouseleave: onMouseLeave,
                  onTouchstart: onTouchStartInput,
                  onKeydown: handleKeydownInput
                }, [
                  unref(triggerIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass([unref(nsInput).e("icon"), unref(nsRange).e("icon")]),
                    onMousedown: withModifiers(onMouseDownInput, ["prevent"]),
                    onTouchstart: onTouchStartInput
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(triggerIcon))))
                    ]),
                    _: 1
                  }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true),
                  createElementVNode("input", {
                    id: _ctx.id && _ctx.id[0],
                    autocomplete: "off",
                    name: _ctx.name && _ctx.name[0],
                    placeholder: _ctx.startPlaceholder,
                    value: unref(displayValue) && unref(displayValue)[0],
                    disabled: unref(pickerDisabled),
                    readonly: !_ctx.editable || _ctx.readonly,
                    class: normalizeClass(unref(nsRange).b("input")),
                    onMousedown: onMouseDownInput,
                    onInput: handleStartInput,
                    onChange: handleStartChange,
                    onFocus: handleFocusInput,
                    onBlur: handleBlurInput
                  }, null, 42, _hoisted_1$t),
                  renderSlot(_ctx.$slots, "range-separator", {}, () => [
                    createElementVNode("span", {
                      class: normalizeClass(unref(nsRange).b("separator"))
                    }, toDisplayString(_ctx.rangeSeparator), 3)
                  ]),
                  createElementVNode("input", {
                    id: _ctx.id && _ctx.id[1],
                    autocomplete: "off",
                    name: _ctx.name && _ctx.name[1],
                    placeholder: _ctx.endPlaceholder,
                    value: unref(displayValue) && unref(displayValue)[1],
                    disabled: unref(pickerDisabled),
                    readonly: !_ctx.editable || _ctx.readonly,
                    class: normalizeClass(unref(nsRange).b("input")),
                    onMousedown: onMouseDownInput,
                    onFocus: handleFocusInput,
                    onBlur: handleBlurInput,
                    onInput: handleEndInput,
                    onChange: handleEndChange
                  }, null, 42, _hoisted_2$n),
                  _ctx.clearIcon ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 1,
                    class: normalizeClass(unref(clearIconKls)),
                    onClick: onClearIconClick
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true)
                ], 38))
              ]),
              content: withCtx(() => [
                renderSlot(_ctx.$slots, "default", {
                  visible: pickerVisible.value,
                  actualVisible: pickerActualVisible.value,
                  parsedValue: unref(parsedValue),
                  format: _ctx.format,
                  dateFormat: _ctx.dateFormat,
                  timeFormat: _ctx.timeFormat,
                  unlinkPanels: _ctx.unlinkPanels,
                  type: _ctx.type,
                  defaultValue: _ctx.defaultValue,
                  onPick,
                  onSelectRange: setSelectionRange,
                  onSetPickerOption,
                  onCalendarChange,
                  onPanelChange,
                  onKeydown: onKeydownPopperContent,
                  onMousedown: _cache[1] || (_cache[1] = withModifiers(() => {
                  }, ["stop"]))
                })
              ]),
              _: 3
            }, 16, ["visible", "transition", "popper-class", "popper-options"]);
          };
        }
      });
      var CommonPicker = /* @__PURE__ */ _export_sfc$1(_sfc_main$J, [["__file", "picker.vue"]]);
      const panelTimePickerProps = buildProps({
        ...timePanelSharedProps,
        datetimeRole: String,
        parsedValue: {
          type: definePropType(Object)
        }
      });
      const useTimePanel = ({
        getAvailableHours,
        getAvailableMinutes,
        getAvailableSeconds
      }) => {
        const getAvailableTime = (date4, role, first, compareDate) => {
          const availableTimeGetters = {
            hour: getAvailableHours,
            minute: getAvailableMinutes,
            second: getAvailableSeconds
          };
          let result = date4;
          ["hour", "minute", "second"].forEach((type4) => {
            if (availableTimeGetters[type4]) {
              let availableTimeSlots;
              const method4 = availableTimeGetters[type4];
              switch (type4) {
                case "minute": {
                  availableTimeSlots = method4(result.hour(), role, compareDate);
                  break;
                }
                case "second": {
                  availableTimeSlots = method4(result.hour(), result.minute(), role, compareDate);
                  break;
                }
                default: {
                  availableTimeSlots = method4(role, compareDate);
                  break;
                }
              }
              if ((availableTimeSlots == null ? void 0 : availableTimeSlots.length) && !availableTimeSlots.includes(result[type4]())) {
                const pos = first ? 0 : availableTimeSlots.length - 1;
                result = result[type4](availableTimeSlots[pos]);
              }
            }
          });
          return result;
        };
        const timePickerOptions = {};
        const onSetOption = ([key, val]) => {
          timePickerOptions[key] = val;
        };
        return {
          timePickerOptions,
          getAvailableTime,
          onSetOption
        };
      };
      const makeAvailableArr = (disabledList) => {
        const trueOrNumber = (isDisabled, index) => isDisabled || index;
        const getNumber = (predicate) => predicate !== true;
        return disabledList.map(trueOrNumber).filter(getNumber);
      };
      const getTimeLists = (disabledHours, disabledMinutes, disabledSeconds) => {
        const getHoursList = (role, compare) => {
          return makeList(24, disabledHours && (() => disabledHours == null ? void 0 : disabledHours(role, compare)));
        };
        const getMinutesList = (hour, role, compare) => {
          return makeList(60, disabledMinutes && (() => disabledMinutes == null ? void 0 : disabledMinutes(hour, role, compare)));
        };
        const getSecondsList = (hour, minute, role, compare) => {
          return makeList(60, disabledSeconds && (() => disabledSeconds == null ? void 0 : disabledSeconds(hour, minute, role, compare)));
        };
        return {
          getHoursList,
          getMinutesList,
          getSecondsList
        };
      };
      const buildAvailableTimeSlotGetter = (disabledHours, disabledMinutes, disabledSeconds) => {
        const { getHoursList, getMinutesList, getSecondsList } = getTimeLists(disabledHours, disabledMinutes, disabledSeconds);
        const getAvailableHours = (role, compare) => {
          return makeAvailableArr(getHoursList(role, compare));
        };
        const getAvailableMinutes = (hour, role, compare) => {
          return makeAvailableArr(getMinutesList(hour, role, compare));
        };
        const getAvailableSeconds = (hour, minute, role, compare) => {
          return makeAvailableArr(getSecondsList(hour, minute, role, compare));
        };
        return {
          getAvailableHours,
          getAvailableMinutes,
          getAvailableSeconds
        };
      };
      const useOldValue = (props) => {
        const oldValue = ref(props.parsedValue);
        watch(() => props.visible, (val) => {
          if (!val) {
            oldValue.value = props.parsedValue;
          }
        });
        return oldValue;
      };
      const REPEAT_INTERVAL = 100;
      const REPEAT_DELAY = 600;
      const vRepeatClick = {
        beforeMount(el, binding) {
          const value = binding.value;
          const { interval = REPEAT_INTERVAL, delay = REPEAT_DELAY } = isFunction$1(value) ? {} : value;
          let intervalId;
          let delayId;
          const handler = () => isFunction$1(value) ? value() : value.handler();
          const clear = () => {
            if (delayId) {
              clearTimeout(delayId);
              delayId = void 0;
            }
            if (intervalId) {
              clearInterval(intervalId);
              intervalId = void 0;
            }
          };
          el.addEventListener("mousedown", (evt) => {
            if (evt.button !== 0)
              return;
            clear();
            handler();
            document.addEventListener("mouseup", () => clear(), {
              once: true
            });
            delayId = setTimeout(() => {
              intervalId = setInterval(() => {
                handler();
              }, interval);
            }, delay);
          });
        }
      };
      const basicTimeSpinnerProps = buildProps({
        role: {
          type: String,
          required: true
        },
        spinnerDate: {
          type: definePropType(Object),
          required: true
        },
        showSeconds: {
          type: Boolean,
          default: true
        },
        arrowControl: Boolean,
        amPmMode: {
          type: definePropType(String),
          default: ""
        },
        ...disabledTimeListsProps
      });
      const _hoisted_1$s = ["onClick"];
      const _hoisted_2$m = ["onMouseenter"];
      const _sfc_main$I = /* @__PURE__ */ defineComponent({
        __name: "basic-time-spinner",
        props: basicTimeSpinnerProps,
        emits: ["change", "select-range", "set-option"],
        setup(__props, { emit }) {
          const props = __props;
          const ns = useNamespace("time");
          const { getHoursList, getMinutesList, getSecondsList } = getTimeLists(props.disabledHours, props.disabledMinutes, props.disabledSeconds);
          let isScrolling = false;
          const currentScrollbar = ref();
          const listHoursRef = ref();
          const listMinutesRef = ref();
          const listSecondsRef = ref();
          const listRefsMap = {
            hours: listHoursRef,
            minutes: listMinutesRef,
            seconds: listSecondsRef
          };
          const spinnerItems = computed(() => {
            return props.showSeconds ? timeUnits : timeUnits.slice(0, 2);
          });
          const timePartials = computed(() => {
            const { spinnerDate } = props;
            const hours = spinnerDate.hour();
            const minutes = spinnerDate.minute();
            const seconds = spinnerDate.second();
            return { hours, minutes, seconds };
          });
          const timeList = computed(() => {
            const { hours, minutes } = unref(timePartials);
            return {
              hours: getHoursList(props.role),
              minutes: getMinutesList(hours, props.role),
              seconds: getSecondsList(hours, minutes, props.role)
            };
          });
          const arrowControlTimeList = computed(() => {
            const { hours, minutes, seconds } = unref(timePartials);
            return {
              hours: buildTimeList(hours, 23),
              minutes: buildTimeList(minutes, 59),
              seconds: buildTimeList(seconds, 59)
            };
          });
          const debouncedResetScroll = debounce((type4) => {
            isScrolling = false;
            adjustCurrentSpinner(type4);
          }, 200);
          const getAmPmFlag = (hour) => {
            const shouldShowAmPm = !!props.amPmMode;
            if (!shouldShowAmPm)
              return "";
            const isCapital = props.amPmMode === "A";
            let content = hour < 12 ? " am" : " pm";
            if (isCapital)
              content = content.toUpperCase();
            return content;
          };
          const emitSelectRange = (type4) => {
            let range3;
            switch (type4) {
              case "hours":
                range3 = [0, 2];
                break;
              case "minutes":
                range3 = [3, 5];
                break;
              case "seconds":
                range3 = [6, 8];
                break;
            }
            const [left, right] = range3;
            emit("select-range", left, right);
            currentScrollbar.value = type4;
          };
          const adjustCurrentSpinner = (type4) => {
            adjustSpinner(type4, unref(timePartials)[type4]);
          };
          const adjustSpinners = () => {
            adjustCurrentSpinner("hours");
            adjustCurrentSpinner("minutes");
            adjustCurrentSpinner("seconds");
          };
          const getScrollbarElement = (el) => el.querySelector(`.${ns.namespace.value}-scrollbar__wrap`);
          const adjustSpinner = (type4, value) => {
            if (props.arrowControl)
              return;
            const scrollbar = unref(listRefsMap[type4]);
            if (scrollbar && scrollbar.$el) {
              getScrollbarElement(scrollbar.$el).scrollTop = Math.max(0, value * typeItemHeight(type4));
            }
          };
          const typeItemHeight = (type4) => {
            const scrollbar = unref(listRefsMap[type4]);
            const listItem = scrollbar == null ? void 0 : scrollbar.$el.querySelector("li");
            if (listItem) {
              return Number.parseFloat(getStyle(listItem, "height")) || 0;
            }
            return 0;
          };
          const onIncrement = () => {
            scrollDown(1);
          };
          const onDecrement = () => {
            scrollDown(-1);
          };
          const scrollDown = (step) => {
            if (!currentScrollbar.value) {
              emitSelectRange("hours");
            }
            const label = currentScrollbar.value;
            const now = unref(timePartials)[label];
            const total = currentScrollbar.value === "hours" ? 24 : 60;
            const next = findNextUnDisabled(label, now, step, total);
            modifyDateField(label, next);
            adjustSpinner(label, next);
            nextTick(() => emitSelectRange(label));
          };
          const findNextUnDisabled = (type4, now, step, total) => {
            let next = (now + step + total) % total;
            const list = unref(timeList)[type4];
            while (list[next] && next !== now) {
              next = (next + step + total) % total;
            }
            return next;
          };
          const modifyDateField = (type4, value) => {
            const list = unref(timeList)[type4];
            const isDisabled = list[value];
            if (isDisabled)
              return;
            const { hours, minutes, seconds } = unref(timePartials);
            let changeTo;
            switch (type4) {
              case "hours":
                changeTo = props.spinnerDate.hour(value).minute(minutes).second(seconds);
                break;
              case "minutes":
                changeTo = props.spinnerDate.hour(hours).minute(value).second(seconds);
                break;
              case "seconds":
                changeTo = props.spinnerDate.hour(hours).minute(minutes).second(value);
                break;
            }
            emit("change", changeTo);
          };
          const handleClick = (type4, { value, disabled }) => {
            if (!disabled) {
              modifyDateField(type4, value);
              emitSelectRange(type4);
              adjustSpinner(type4, value);
            }
          };
          const handleScroll = (type4) => {
            isScrolling = true;
            debouncedResetScroll(type4);
            const value = Math.min(Math.round((getScrollbarElement(unref(listRefsMap[type4]).$el).scrollTop - (scrollBarHeight(type4) * 0.5 - 10) / typeItemHeight(type4) + 3) / typeItemHeight(type4)), type4 === "hours" ? 23 : 59);
            modifyDateField(type4, value);
          };
          const scrollBarHeight = (type4) => {
            return unref(listRefsMap[type4]).$el.offsetHeight;
          };
          const bindScrollEvent = () => {
            const bindFunction = (type4) => {
              const scrollbar = unref(listRefsMap[type4]);
              if (scrollbar && scrollbar.$el) {
                getScrollbarElement(scrollbar.$el).onscroll = () => {
                  handleScroll(type4);
                };
              }
            };
            bindFunction("hours");
            bindFunction("minutes");
            bindFunction("seconds");
          };
          onMounted(() => {
            nextTick(() => {
              !props.arrowControl && bindScrollEvent();
              adjustSpinners();
              if (props.role === "start")
                emitSelectRange("hours");
            });
          });
          const setRef = (scrollbar, type4) => {
            listRefsMap[type4].value = scrollbar;
          };
          emit("set-option", [`${props.role}_scrollDown`, scrollDown]);
          emit("set-option", [`${props.role}_emitSelectRange`, emitSelectRange]);
          watch(() => props.spinnerDate, () => {
            if (isScrolling)
              return;
            adjustSpinners();
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([unref(ns).b("spinner"), { "has-seconds": _ctx.showSeconds }])
            }, [
              !_ctx.arrowControl ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(spinnerItems), (item) => {
                return openBlock(), createBlock(unref(ElScrollbar), {
                  key: item,
                  ref_for: true,
                  ref: (scrollbar) => setRef(scrollbar, item),
                  class: normalizeClass(unref(ns).be("spinner", "wrapper")),
                  "wrap-style": "max-height: inherit;",
                  "view-class": unref(ns).be("spinner", "list"),
                  noresize: "",
                  tag: "ul",
                  onMouseenter: ($event) => emitSelectRange(item),
                  onMousemove: ($event) => adjustCurrentSpinner(item)
                }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(timeList)[item], (disabled, key) => {
                      return openBlock(), createElementBlock("li", {
                        key,
                        class: normalizeClass([
                          unref(ns).be("spinner", "item"),
                          unref(ns).is("active", key === unref(timePartials)[item]),
                          unref(ns).is("disabled", disabled)
                        ]),
                        onClick: ($event) => handleClick(item, { value: key, disabled })
                      }, [
                        item === "hours" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                          createTextVNode(toDisplayString(("0" + (_ctx.amPmMode ? key % 12 || 12 : key)).slice(-2)) + toDisplayString(getAmPmFlag(key)), 1)
                        ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                          createTextVNode(toDisplayString(("0" + key).slice(-2)), 1)
                        ], 64))
                      ], 10, _hoisted_1$s);
                    }), 128))
                  ]),
                  _: 2
                }, 1032, ["class", "view-class", "onMouseenter", "onMousemove"]);
              }), 128)) : createCommentVNode("v-if", true),
              _ctx.arrowControl ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(unref(spinnerItems), (item) => {
                return openBlock(), createElementBlock("div", {
                  key: item,
                  class: normalizeClass([unref(ns).be("spinner", "wrapper"), unref(ns).is("arrow")]),
                  onMouseenter: ($event) => emitSelectRange(item)
                }, [
                  withDirectives((openBlock(), createBlock(unref(ElIcon), {
                    class: normalizeClass(["arrow-up", unref(ns).be("spinner", "arrow")])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(arrow_up_default))
                    ]),
                    _: 1
                  }, 8, ["class"])), [
                    [unref(vRepeatClick), onDecrement]
                  ]),
                  withDirectives((openBlock(), createBlock(unref(ElIcon), {
                    class: normalizeClass(["arrow-down", unref(ns).be("spinner", "arrow")])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(arrow_down_default))
                    ]),
                    _: 1
                  }, 8, ["class"])), [
                    [unref(vRepeatClick), onIncrement]
                  ]),
                  createElementVNode("ul", {
                    class: normalizeClass(unref(ns).be("spinner", "list"))
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(arrowControlTimeList)[item], (time, key) => {
                      return openBlock(), createElementBlock("li", {
                        key,
                        class: normalizeClass([
                          unref(ns).be("spinner", "item"),
                          unref(ns).is("active", time === unref(timePartials)[item]),
                          unref(ns).is("disabled", unref(timeList)[item][time])
                        ])
                      }, [
                        typeof time === "number" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                          item === "hours" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                            createTextVNode(toDisplayString(("0" + (_ctx.amPmMode ? time % 12 || 12 : time)).slice(-2)) + toDisplayString(getAmPmFlag(time)), 1)
                          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                            createTextVNode(toDisplayString(("0" + time).slice(-2)), 1)
                          ], 64))
                        ], 64)) : createCommentVNode("v-if", true)
                      ], 2);
                    }), 128))
                  ], 2)
                ], 42, _hoisted_2$m);
              }), 128)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var TimeSpinner = /* @__PURE__ */ _export_sfc$1(_sfc_main$I, [["__file", "basic-time-spinner.vue"]]);
      const _sfc_main$H = /* @__PURE__ */ defineComponent({
        __name: "panel-time-pick",
        props: panelTimePickerProps,
        emits: ["pick", "select-range", "set-picker-option"],
        setup(__props, { emit }) {
          const props = __props;
          const pickerBase = inject("EP_PICKER_BASE");
          const {
            arrowControl,
            disabledHours,
            disabledMinutes,
            disabledSeconds,
            defaultValue
          } = pickerBase.props;
          const { getAvailableHours, getAvailableMinutes, getAvailableSeconds } = buildAvailableTimeSlotGetter(disabledHours, disabledMinutes, disabledSeconds);
          const ns = useNamespace("time");
          const { t, lang } = useLocale();
          const selectionRange = ref([0, 2]);
          const oldValue = useOldValue(props);
          const transitionName = computed(() => {
            return isUndefined(props.actualVisible) ? `${ns.namespace.value}-zoom-in-top` : "";
          });
          const showSeconds = computed(() => {
            return props.format.includes("ss");
          });
          const amPmMode = computed(() => {
            if (props.format.includes("A"))
              return "A";
            if (props.format.includes("a"))
              return "a";
            return "";
          });
          const isValidValue = (_date) => {
            const parsedDate = dayjs(_date).locale(lang.value);
            const result = getRangeAvailableTime(parsedDate);
            return parsedDate.isSame(result);
          };
          const handleCancel = () => {
            emit("pick", oldValue.value, false);
          };
          const handleConfirm = (visible = false, first = false) => {
            if (first)
              return;
            emit("pick", props.parsedValue, visible);
          };
          const handleChange = (_date) => {
            if (!props.visible) {
              return;
            }
            const result = getRangeAvailableTime(_date).millisecond(0);
            emit("pick", result, true);
          };
          const setSelectionRange = (start, end) => {
            emit("select-range", start, end);
            selectionRange.value = [start, end];
          };
          const changeSelectionRange = (step) => {
            const list = [0, 3].concat(showSeconds.value ? [6] : []);
            const mapping = ["hours", "minutes"].concat(showSeconds.value ? ["seconds"] : []);
            const index = list.indexOf(selectionRange.value[0]);
            const next = (index + step + list.length) % list.length;
            timePickerOptions["start_emitSelectRange"](mapping[next]);
          };
          const handleKeydown = (event) => {
            const code = event.code;
            const { left, right, up, down } = EVENT_CODE;
            if ([left, right].includes(code)) {
              const step = code === left ? -1 : 1;
              changeSelectionRange(step);
              event.preventDefault();
              return;
            }
            if ([up, down].includes(code)) {
              const step = code === up ? -1 : 1;
              timePickerOptions["start_scrollDown"](step);
              event.preventDefault();
              return;
            }
          };
          const { timePickerOptions, onSetOption, getAvailableTime } = useTimePanel({
            getAvailableHours,
            getAvailableMinutes,
            getAvailableSeconds
          });
          const getRangeAvailableTime = (date4) => {
            return getAvailableTime(date4, props.datetimeRole || "", true);
          };
          const parseUserInput = (value) => {
            if (!value)
              return null;
            return dayjs(value, props.format).locale(lang.value);
          };
          const formatToString = (value) => {
            if (!value)
              return null;
            return value.format(props.format);
          };
          const getDefaultValue = () => {
            return dayjs(defaultValue).locale(lang.value);
          };
          emit("set-picker-option", ["isValidValue", isValidValue]);
          emit("set-picker-option", ["formatToString", formatToString]);
          emit("set-picker-option", ["parseUserInput", parseUserInput]);
          emit("set-picker-option", ["handleKeydownInput", handleKeydown]);
          emit("set-picker-option", ["getRangeAvailableTime", getRangeAvailableTime]);
          emit("set-picker-option", ["getDefaultValue", getDefaultValue]);
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, { name: unref(transitionName) }, {
              default: withCtx(() => [
                _ctx.actualVisible || _ctx.visible ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ns).b("panel"))
                }, [
                  createElementVNode("div", {
                    class: normalizeClass([unref(ns).be("panel", "content"), { "has-seconds": unref(showSeconds) }])
                  }, [
                    createVNode(TimeSpinner, {
                      ref: "spinner",
                      role: _ctx.datetimeRole || "start",
                      "arrow-control": unref(arrowControl),
                      "show-seconds": unref(showSeconds),
                      "am-pm-mode": unref(amPmMode),
                      "spinner-date": _ctx.parsedValue,
                      "disabled-hours": unref(disabledHours),
                      "disabled-minutes": unref(disabledMinutes),
                      "disabled-seconds": unref(disabledSeconds),
                      onChange: handleChange,
                      onSetOption: unref(onSetOption),
                      onSelectRange: setSelectionRange
                    }, null, 8, ["role", "arrow-control", "show-seconds", "am-pm-mode", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onSetOption"])
                  ], 2),
                  createElementVNode("div", {
                    class: normalizeClass(unref(ns).be("panel", "footer"))
                  }, [
                    createElementVNode("button", {
                      type: "button",
                      class: normalizeClass([unref(ns).be("panel", "btn"), "cancel"]),
                      onClick: handleCancel
                    }, toDisplayString(unref(t)("el.datepicker.cancel")), 3),
                    createElementVNode("button", {
                      type: "button",
                      class: normalizeClass([unref(ns).be("panel", "btn"), "confirm"]),
                      onClick: _cache[0] || (_cache[0] = ($event) => handleConfirm())
                    }, toDisplayString(unref(t)("el.datepicker.confirm")), 3)
                  ], 2)
                ], 2)) : createCommentVNode("v-if", true)
              ]),
              _: 1
            }, 8, ["name"]);
          };
        }
      });
      var TimePickPanel = /* @__PURE__ */ _export_sfc$1(_sfc_main$H, [["__file", "panel-time-pick.vue"]]);
      const panelTimeRangeProps = buildProps({
        ...timePanelSharedProps,
        parsedValue: {
          type: definePropType(Array)
        }
      });
      const _hoisted_1$r = ["disabled"];
      const _sfc_main$G = /* @__PURE__ */ defineComponent({
        __name: "panel-time-range",
        props: panelTimeRangeProps,
        emits: ["pick", "select-range", "set-picker-option"],
        setup(__props, { emit }) {
          const props = __props;
          const makeSelectRange = (start, end) => {
            const result = [];
            for (let i = start; i <= end; i++) {
              result.push(i);
            }
            return result;
          };
          const { t, lang } = useLocale();
          const nsTime = useNamespace("time");
          const nsPicker = useNamespace("picker");
          const pickerBase = inject("EP_PICKER_BASE");
          const {
            arrowControl,
            disabledHours,
            disabledMinutes,
            disabledSeconds,
            defaultValue
          } = pickerBase.props;
          const startContainerKls = computed(() => [
            nsTime.be("range-picker", "body"),
            nsTime.be("panel", "content"),
            nsTime.is("arrow", arrowControl),
            showSeconds.value ? "has-seconds" : ""
          ]);
          const endContainerKls = computed(() => [
            nsTime.be("range-picker", "body"),
            nsTime.be("panel", "content"),
            nsTime.is("arrow", arrowControl),
            showSeconds.value ? "has-seconds" : ""
          ]);
          const startTime = computed(() => props.parsedValue[0]);
          const endTime = computed(() => props.parsedValue[1]);
          const oldValue = useOldValue(props);
          const handleCancel = () => {
            emit("pick", oldValue.value, false);
          };
          const showSeconds = computed(() => {
            return props.format.includes("ss");
          });
          const amPmMode = computed(() => {
            if (props.format.includes("A"))
              return "A";
            if (props.format.includes("a"))
              return "a";
            return "";
          });
          const handleConfirm = (visible = false) => {
            emit("pick", [startTime.value, endTime.value], visible);
          };
          const handleMinChange = (date4) => {
            handleChange(date4.millisecond(0), endTime.value);
          };
          const handleMaxChange = (date4) => {
            handleChange(startTime.value, date4.millisecond(0));
          };
          const isValidValue = (_date) => {
            const parsedDate = _date.map((_) => dayjs(_).locale(lang.value));
            const result = getRangeAvailableTime(parsedDate);
            return parsedDate[0].isSame(result[0]) && parsedDate[1].isSame(result[1]);
          };
          const handleChange = (start, end) => {
            emit("pick", [start, end], true);
          };
          const btnConfirmDisabled = computed(() => {
            return startTime.value > endTime.value;
          });
          const selectionRange = ref([0, 2]);
          const setMinSelectionRange = (start, end) => {
            emit("select-range", start, end, "min");
            selectionRange.value = [start, end];
          };
          const offset = computed(() => showSeconds.value ? 11 : 8);
          const setMaxSelectionRange = (start, end) => {
            emit("select-range", start, end, "max");
            const _offset = unref(offset);
            selectionRange.value = [start + _offset, end + _offset];
          };
          const changeSelectionRange = (step) => {
            const list = showSeconds.value ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11];
            const mapping = ["hours", "minutes"].concat(showSeconds.value ? ["seconds"] : []);
            const index = list.indexOf(selectionRange.value[0]);
            const next = (index + step + list.length) % list.length;
            const half = list.length / 2;
            if (next < half) {
              timePickerOptions["start_emitSelectRange"](mapping[next]);
            } else {
              timePickerOptions["end_emitSelectRange"](mapping[next - half]);
            }
          };
          const handleKeydown = (event) => {
            const code = event.code;
            const { left, right, up, down } = EVENT_CODE;
            if ([left, right].includes(code)) {
              const step = code === left ? -1 : 1;
              changeSelectionRange(step);
              event.preventDefault();
              return;
            }
            if ([up, down].includes(code)) {
              const step = code === up ? -1 : 1;
              const role = selectionRange.value[0] < offset.value ? "start" : "end";
              timePickerOptions[`${role}_scrollDown`](step);
              event.preventDefault();
              return;
            }
          };
          const disabledHours_ = (role, compare) => {
            const defaultDisable = disabledHours ? disabledHours(role) : [];
            const isStart = role === "start";
            const compareDate = compare || (isStart ? endTime.value : startTime.value);
            const compareHour = compareDate.hour();
            const nextDisable = isStart ? makeSelectRange(compareHour + 1, 23) : makeSelectRange(0, compareHour - 1);
            return union(defaultDisable, nextDisable);
          };
          const disabledMinutes_ = (hour, role, compare) => {
            const defaultDisable = disabledMinutes ? disabledMinutes(hour, role) : [];
            const isStart = role === "start";
            const compareDate = compare || (isStart ? endTime.value : startTime.value);
            const compareHour = compareDate.hour();
            if (hour !== compareHour) {
              return defaultDisable;
            }
            const compareMinute = compareDate.minute();
            const nextDisable = isStart ? makeSelectRange(compareMinute + 1, 59) : makeSelectRange(0, compareMinute - 1);
            return union(defaultDisable, nextDisable);
          };
          const disabledSeconds_ = (hour, minute, role, compare) => {
            const defaultDisable = disabledSeconds ? disabledSeconds(hour, minute, role) : [];
            const isStart = role === "start";
            const compareDate = compare || (isStart ? endTime.value : startTime.value);
            const compareHour = compareDate.hour();
            const compareMinute = compareDate.minute();
            if (hour !== compareHour || minute !== compareMinute) {
              return defaultDisable;
            }
            const compareSecond = compareDate.second();
            const nextDisable = isStart ? makeSelectRange(compareSecond + 1, 59) : makeSelectRange(0, compareSecond - 1);
            return union(defaultDisable, nextDisable);
          };
          const getRangeAvailableTime = ([start, end]) => {
            return [
              getAvailableTime(start, "start", true, end),
              getAvailableTime(end, "end", false, start)
            ];
          };
          const { getAvailableHours, getAvailableMinutes, getAvailableSeconds } = buildAvailableTimeSlotGetter(disabledHours_, disabledMinutes_, disabledSeconds_);
          const {
            timePickerOptions,
            getAvailableTime,
            onSetOption
          } = useTimePanel({
            getAvailableHours,
            getAvailableMinutes,
            getAvailableSeconds
          });
          const parseUserInput = (days) => {
            if (!days)
              return null;
            if (isArray$1(days)) {
              return days.map((d) => dayjs(d, props.format).locale(lang.value));
            }
            return dayjs(days, props.format).locale(lang.value);
          };
          const formatToString = (days) => {
            if (!days)
              return null;
            if (isArray$1(days)) {
              return days.map((d) => d.format(props.format));
            }
            return days.format(props.format);
          };
          const getDefaultValue = () => {
            if (isArray$1(defaultValue)) {
              return defaultValue.map((d) => dayjs(d).locale(lang.value));
            }
            const defaultDay = dayjs(defaultValue).locale(lang.value);
            return [defaultDay, defaultDay.add(60, "m")];
          };
          emit("set-picker-option", ["formatToString", formatToString]);
          emit("set-picker-option", ["parseUserInput", parseUserInput]);
          emit("set-picker-option", ["isValidValue", isValidValue]);
          emit("set-picker-option", ["handleKeydownInput", handleKeydown]);
          emit("set-picker-option", ["getDefaultValue", getDefaultValue]);
          emit("set-picker-option", ["getRangeAvailableTime", getRangeAvailableTime]);
          return (_ctx, _cache) => {
            return _ctx.actualVisible ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass([unref(nsTime).b("range-picker"), unref(nsPicker).b("panel")])
            }, [
              createElementVNode("div", {
                class: normalizeClass(unref(nsTime).be("range-picker", "content"))
              }, [
                createElementVNode("div", {
                  class: normalizeClass(unref(nsTime).be("range-picker", "cell"))
                }, [
                  createElementVNode("div", {
                    class: normalizeClass(unref(nsTime).be("range-picker", "header"))
                  }, toDisplayString(unref(t)("el.datepicker.startTime")), 3),
                  createElementVNode("div", {
                    class: normalizeClass(unref(startContainerKls))
                  }, [
                    createVNode(TimeSpinner, {
                      ref: "minSpinner",
                      role: "start",
                      "show-seconds": unref(showSeconds),
                      "am-pm-mode": unref(amPmMode),
                      "arrow-control": unref(arrowControl),
                      "spinner-date": unref(startTime),
                      "disabled-hours": disabledHours_,
                      "disabled-minutes": disabledMinutes_,
                      "disabled-seconds": disabledSeconds_,
                      onChange: handleMinChange,
                      onSetOption: unref(onSetOption),
                      onSelectRange: setMinSelectionRange
                    }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])
                  ], 2)
                ], 2),
                createElementVNode("div", {
                  class: normalizeClass(unref(nsTime).be("range-picker", "cell"))
                }, [
                  createElementVNode("div", {
                    class: normalizeClass(unref(nsTime).be("range-picker", "header"))
                  }, toDisplayString(unref(t)("el.datepicker.endTime")), 3),
                  createElementVNode("div", {
                    class: normalizeClass(unref(endContainerKls))
                  }, [
                    createVNode(TimeSpinner, {
                      ref: "maxSpinner",
                      role: "end",
                      "show-seconds": unref(showSeconds),
                      "am-pm-mode": unref(amPmMode),
                      "arrow-control": unref(arrowControl),
                      "spinner-date": unref(endTime),
                      "disabled-hours": disabledHours_,
                      "disabled-minutes": disabledMinutes_,
                      "disabled-seconds": disabledSeconds_,
                      onChange: handleMaxChange,
                      onSetOption: unref(onSetOption),
                      onSelectRange: setMaxSelectionRange
                    }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])
                  ], 2)
                ], 2)
              ], 2),
              createElementVNode("div", {
                class: normalizeClass(unref(nsTime).be("panel", "footer"))
              }, [
                createElementVNode("button", {
                  type: "button",
                  class: normalizeClass([unref(nsTime).be("panel", "btn"), "cancel"]),
                  onClick: _cache[0] || (_cache[0] = ($event) => handleCancel())
                }, toDisplayString(unref(t)("el.datepicker.cancel")), 3),
                createElementVNode("button", {
                  type: "button",
                  class: normalizeClass([unref(nsTime).be("panel", "btn"), "confirm"]),
                  disabled: unref(btnConfirmDisabled),
                  onClick: _cache[1] || (_cache[1] = ($event) => handleConfirm())
                }, toDisplayString(unref(t)("el.datepicker.confirm")), 11, _hoisted_1$r)
              ], 2)
            ], 2)) : createCommentVNode("v-if", true);
          };
        }
      });
      var TimeRangePanel = /* @__PURE__ */ _export_sfc$1(_sfc_main$G, [["__file", "panel-time-range.vue"]]);
      dayjs.extend(customParseFormat);
      var TimePicker = defineComponent({
        name: "ElTimePicker",
        install: null,
        props: {
          ...timePickerDefaultProps,
          isRange: {
            type: Boolean,
            default: false
          }
        },
        emits: ["update:modelValue"],
        setup(props, ctx) {
          const commonPicker = ref();
          const [type4, Panel2] = props.isRange ? ["timerange", TimeRangePanel] : ["time", TimePickPanel];
          const modelUpdater = (value) => ctx.emit("update:modelValue", value);
          provide("ElPopperOptions", props.popperOptions);
          ctx.expose({
            focus: (e) => {
              var _a;
              (_a = commonPicker.value) == null ? void 0 : _a.handleFocusInput(e);
            },
            blur: (e) => {
              var _a;
              (_a = commonPicker.value) == null ? void 0 : _a.handleBlurInput(e);
            },
            handleOpen: () => {
              var _a;
              (_a = commonPicker.value) == null ? void 0 : _a.handleOpen();
            },
            handleClose: () => {
              var _a;
              (_a = commonPicker.value) == null ? void 0 : _a.handleClose();
            }
          });
          return () => {
            var _a;
            const format2 = (_a = props.format) != null ? _a : DEFAULT_FORMATS_TIME;
            return createVNode(CommonPicker, mergeProps(props, {
              "ref": commonPicker,
              "type": type4,
              "format": format2,
              "onUpdate:modelValue": modelUpdater
            }), {
              default: (props2) => createVNode(Panel2, props2, null)
            });
          };
        }
      });
      const _TimePicker = TimePicker;
      _TimePicker.install = (app) => {
        app.component(_TimePicker.name, _TimePicker);
      };
      const ElTimePicker = _TimePicker;
      const cardProps = buildProps({
        header: {
          type: String,
          default: ""
        },
        footer: {
          type: String,
          default: ""
        },
        bodyStyle: {
          type: definePropType([String, Object, Array]),
          default: ""
        },
        bodyClass: String,
        shadow: {
          type: String,
          values: ["always", "hover", "never"],
          default: "always"
        }
      });
      const __default__$l = defineComponent({
        name: "ElCard"
      });
      const _sfc_main$F = /* @__PURE__ */ defineComponent({
        ...__default__$l,
        props: cardProps,
        setup(__props) {
          const ns = useNamespace("card");
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([unref(ns).b(), unref(ns).is(`${_ctx.shadow}-shadow`)])
            }, [
              _ctx.$slots.header || _ctx.header ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).e("header"))
              }, [
                renderSlot(_ctx.$slots, "header", {}, () => [
                  createTextVNode(toDisplayString(_ctx.header), 1)
                ])
              ], 2)) : createCommentVNode("v-if", true),
              createElementVNode("div", {
                class: normalizeClass([unref(ns).e("body"), _ctx.bodyClass]),
                style: normalizeStyle(_ctx.bodyStyle)
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 6),
              _ctx.$slots.footer || _ctx.footer ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(ns).e("footer"))
              }, [
                renderSlot(_ctx.$slots, "footer", {}, () => [
                  createTextVNode(toDisplayString(_ctx.footer), 1)
                ])
              ], 2)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var Card = /* @__PURE__ */ _export_sfc$1(_sfc_main$F, [["__file", "card.vue"]]);
      const ElCard = withInstall(Card);
      const rowContextKey = Symbol("rowContextKey");
      const RowJustify = [
        "start",
        "center",
        "end",
        "space-around",
        "space-between",
        "space-evenly"
      ];
      const RowAlign = ["top", "middle", "bottom"];
      const rowProps = buildProps({
        tag: {
          type: String,
          default: "div"
        },
        gutter: {
          type: Number,
          default: 0
        },
        justify: {
          type: String,
          values: RowJustify,
          default: "start"
        },
        align: {
          type: String,
          values: RowAlign
        }
      });
      const __default__$k = defineComponent({
        name: "ElRow"
      });
      const _sfc_main$E = /* @__PURE__ */ defineComponent({
        ...__default__$k,
        props: rowProps,
        setup(__props) {
          const props = __props;
          const ns = useNamespace("row");
          const gutter = computed(() => props.gutter);
          provide(rowContextKey, {
            gutter
          });
          const style = computed(() => {
            const styles = {};
            if (!props.gutter) {
              return styles;
            }
            styles.marginRight = styles.marginLeft = `-${props.gutter / 2}px`;
            return styles;
          });
          const rowKls = computed(() => [
            ns.b(),
            ns.is(`justify-${props.justify}`, props.justify !== "start"),
            ns.is(`align-${props.align}`, !!props.align)
          ]);
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
              class: normalizeClass(unref(rowKls)),
              style: normalizeStyle(unref(style))
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["class", "style"]);
          };
        }
      });
      var Row = /* @__PURE__ */ _export_sfc$1(_sfc_main$E, [["__file", "row.vue"]]);
      const ElRow = withInstall(Row);
      const colProps = buildProps({
        tag: {
          type: String,
          default: "div"
        },
        span: {
          type: Number,
          default: 24
        },
        offset: {
          type: Number,
          default: 0
        },
        pull: {
          type: Number,
          default: 0
        },
        push: {
          type: Number,
          default: 0
        },
        xs: {
          type: definePropType([Number, Object]),
          default: () => mutable({})
        },
        sm: {
          type: definePropType([Number, Object]),
          default: () => mutable({})
        },
        md: {
          type: definePropType([Number, Object]),
          default: () => mutable({})
        },
        lg: {
          type: definePropType([Number, Object]),
          default: () => mutable({})
        },
        xl: {
          type: definePropType([Number, Object]),
          default: () => mutable({})
        }
      });
      const __default__$j = defineComponent({
        name: "ElCol"
      });
      const _sfc_main$D = /* @__PURE__ */ defineComponent({
        ...__default__$j,
        props: colProps,
        setup(__props) {
          const props = __props;
          const { gutter } = inject(rowContextKey, { gutter: computed(() => 0) });
          const ns = useNamespace("col");
          const style = computed(() => {
            const styles = {};
            if (gutter.value) {
              styles.paddingLeft = styles.paddingRight = `${gutter.value / 2}px`;
            }
            return styles;
          });
          const colKls = computed(() => {
            const classes = [];
            const pos = ["span", "offset", "pull", "push"];
            pos.forEach((prop) => {
              const size = props[prop];
              if (isNumber(size)) {
                if (prop === "span")
                  classes.push(ns.b(`${props[prop]}`));
                else if (size > 0)
                  classes.push(ns.b(`${prop}-${props[prop]}`));
              }
            });
            const sizes = ["xs", "sm", "md", "lg", "xl"];
            sizes.forEach((size) => {
              if (isNumber(props[size])) {
                classes.push(ns.b(`${size}-${props[size]}`));
              } else if (isObject$1(props[size])) {
                Object.entries(props[size]).forEach(([prop, sizeProp]) => {
                  classes.push(prop !== "span" ? ns.b(`${size}-${prop}-${sizeProp}`) : ns.b(`${size}-${sizeProp}`));
                });
              }
            });
            if (gutter.value) {
              classes.push(ns.is("guttered"));
            }
            return [ns.b(), classes];
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
              class: normalizeClass(unref(colKls)),
              style: normalizeStyle(unref(style))
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["class", "style"]);
          };
        }
      });
      var Col = /* @__PURE__ */ _export_sfc$1(_sfc_main$D, [["__file", "col.vue"]]);
      const ElCol = withInstall(Col);
      const emitChangeFn = (value) => isNumber(value) || isString(value) || isArray$1(value);
      const collapseProps = buildProps({
        accordion: Boolean,
        modelValue: {
          type: definePropType([Array, String, Number]),
          default: () => mutable([])
        }
      });
      const collapseEmits = {
        [UPDATE_MODEL_EVENT]: emitChangeFn,
        [CHANGE_EVENT]: emitChangeFn
      };
      const collapseContextKey = Symbol("collapseContextKey");
      const useCollapse = (props, emit) => {
        const activeNames = ref(castArray(props.modelValue));
        const setActiveNames = (_activeNames) => {
          activeNames.value = _activeNames;
          const value = props.accordion ? activeNames.value[0] : activeNames.value;
          emit(UPDATE_MODEL_EVENT, value);
          emit(CHANGE_EVENT, value);
        };
        const handleItemClick = (name) => {
          if (props.accordion) {
            setActiveNames([activeNames.value[0] === name ? "" : name]);
          } else {
            const _activeNames = [...activeNames.value];
            const index = _activeNames.indexOf(name);
            if (index > -1) {
              _activeNames.splice(index, 1);
            } else {
              _activeNames.push(name);
            }
            setActiveNames(_activeNames);
          }
        };
        watch(() => props.modelValue, () => activeNames.value = castArray(props.modelValue), { deep: true });
        provide(collapseContextKey, {
          activeNames,
          handleItemClick
        });
        return {
          activeNames,
          setActiveNames
        };
      };
      const useCollapseDOM = () => {
        const ns = useNamespace("collapse");
        const rootKls = computed(() => ns.b());
        return {
          rootKls
        };
      };
      const __default__$i = defineComponent({
        name: "ElCollapse"
      });
      const _sfc_main$C = /* @__PURE__ */ defineComponent({
        ...__default__$i,
        props: collapseProps,
        emits: collapseEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const { activeNames, setActiveNames } = useCollapse(props, emit);
          const { rootKls } = useCollapseDOM();
          expose({
            activeNames,
            setActiveNames
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(rootKls))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var Collapse = /* @__PURE__ */ _export_sfc$1(_sfc_main$C, [["__file", "collapse.vue"]]);
      const __default__$h = defineComponent({
        name: "ElCollapseTransition"
      });
      const _sfc_main$B = /* @__PURE__ */ defineComponent({
        ...__default__$h,
        setup(__props) {
          const ns = useNamespace("collapse-transition");
          const reset = (el) => {
            el.style.maxHeight = "";
            el.style.overflow = el.dataset.oldOverflow;
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
          };
          const on = {
            beforeEnter(el) {
              if (!el.dataset)
                el.dataset = {};
              el.dataset.oldPaddingTop = el.style.paddingTop;
              el.dataset.oldPaddingBottom = el.style.paddingBottom;
              if (el.style.height)
                el.dataset.elExistsHeight = el.style.height;
              el.style.maxHeight = 0;
              el.style.paddingTop = 0;
              el.style.paddingBottom = 0;
            },
            enter(el) {
              requestAnimationFrame(() => {
                el.dataset.oldOverflow = el.style.overflow;
                if (el.dataset.elExistsHeight) {
                  el.style.maxHeight = el.dataset.elExistsHeight;
                } else if (el.scrollHeight !== 0) {
                  el.style.maxHeight = `${el.scrollHeight}px`;
                } else {
                  el.style.maxHeight = 0;
                }
                el.style.paddingTop = el.dataset.oldPaddingTop;
                el.style.paddingBottom = el.dataset.oldPaddingBottom;
                el.style.overflow = "hidden";
              });
            },
            afterEnter(el) {
              el.style.maxHeight = "";
              el.style.overflow = el.dataset.oldOverflow;
            },
            enterCancelled(el) {
              reset(el);
            },
            beforeLeave(el) {
              if (!el.dataset)
                el.dataset = {};
              el.dataset.oldPaddingTop = el.style.paddingTop;
              el.dataset.oldPaddingBottom = el.style.paddingBottom;
              el.dataset.oldOverflow = el.style.overflow;
              el.style.maxHeight = `${el.scrollHeight}px`;
              el.style.overflow = "hidden";
            },
            leave(el) {
              if (el.scrollHeight !== 0) {
                el.style.maxHeight = 0;
                el.style.paddingTop = 0;
                el.style.paddingBottom = 0;
              }
            },
            afterLeave(el) {
              reset(el);
            },
            leaveCancelled(el) {
              reset(el);
            }
          };
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, mergeProps({
              name: unref(ns).b()
            }, toHandlers(on)), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, ["name"]);
          };
        }
      });
      var CollapseTransition = /* @__PURE__ */ _export_sfc$1(_sfc_main$B, [["__file", "collapse-transition.vue"]]);
      CollapseTransition.install = (app) => {
        app.component(CollapseTransition.name, CollapseTransition);
      };
      const _CollapseTransition = CollapseTransition;
      const collapseItemProps = buildProps({
        title: {
          type: String,
          default: ""
        },
        name: {
          type: definePropType([String, Number]),
          default: void 0
        },
        disabled: Boolean
      });
      const useCollapseItem = (props) => {
        const collapse = inject(collapseContextKey);
        const { namespace } = useNamespace("collapse");
        const focusing = ref(false);
        const isClick = ref(false);
        const idInjection = useIdInjection();
        const id = computed(() => idInjection.current++);
        const name = computed(() => {
          var _a;
          return (_a = props.name) != null ? _a : `${namespace.value}-id-${idInjection.prefix}-${unref(id)}`;
        });
        const isActive = computed(() => collapse == null ? void 0 : collapse.activeNames.value.includes(unref(name)));
        const handleFocus = () => {
          setTimeout(() => {
            if (!isClick.value) {
              focusing.value = true;
            } else {
              isClick.value = false;
            }
          }, 50);
        };
        const handleHeaderClick = () => {
          if (props.disabled)
            return;
          collapse == null ? void 0 : collapse.handleItemClick(unref(name));
          focusing.value = false;
          isClick.value = true;
        };
        const handleEnterClick = () => {
          collapse == null ? void 0 : collapse.handleItemClick(unref(name));
        };
        return {
          focusing,
          id,
          isActive,
          handleFocus,
          handleHeaderClick,
          handleEnterClick
        };
      };
      const useCollapseItemDOM = (props, { focusing, isActive, id }) => {
        const ns = useNamespace("collapse");
        const rootKls = computed(() => [
          ns.b("item"),
          ns.is("active", unref(isActive)),
          ns.is("disabled", props.disabled)
        ]);
        const headKls = computed(() => [
          ns.be("item", "header"),
          ns.is("active", unref(isActive)),
          { focusing: unref(focusing) && !props.disabled }
        ]);
        const arrowKls = computed(() => [
          ns.be("item", "arrow"),
          ns.is("active", unref(isActive))
        ]);
        const itemWrapperKls = computed(() => ns.be("item", "wrap"));
        const itemContentKls = computed(() => ns.be("item", "content"));
        const scopedContentId = computed(() => ns.b(`content-${unref(id)}`));
        const scopedHeadId = computed(() => ns.b(`head-${unref(id)}`));
        return {
          arrowKls,
          headKls,
          rootKls,
          itemWrapperKls,
          itemContentKls,
          scopedContentId,
          scopedHeadId
        };
      };
      const _hoisted_1$q = ["id", "aria-expanded", "aria-controls", "aria-describedby", "tabindex"];
      const _hoisted_2$l = ["id", "aria-hidden", "aria-labelledby"];
      const __default__$g = defineComponent({
        name: "ElCollapseItem"
      });
      const _sfc_main$A = /* @__PURE__ */ defineComponent({
        ...__default__$g,
        props: collapseItemProps,
        setup(__props, { expose }) {
          const props = __props;
          const {
            focusing,
            id,
            isActive,
            handleFocus,
            handleHeaderClick,
            handleEnterClick
          } = useCollapseItem(props);
          const {
            arrowKls,
            headKls,
            rootKls,
            itemWrapperKls,
            itemContentKls,
            scopedContentId,
            scopedHeadId
          } = useCollapseItemDOM(props, { focusing, isActive, id });
          expose({
            isActive
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(rootKls))
            }, [
              createElementVNode("button", {
                id: unref(scopedHeadId),
                class: normalizeClass(unref(headKls)),
                "aria-expanded": unref(isActive),
                "aria-controls": unref(scopedContentId),
                "aria-describedby": unref(scopedContentId),
                tabindex: _ctx.disabled ? -1 : 0,
                type: "button",
                onClick: _cache[0] || (_cache[0] = (...args) => unref(handleHeaderClick) && unref(handleHeaderClick)(...args)),
                onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => unref(handleEnterClick) && unref(handleEnterClick)(...args), ["stop", "prevent"]), ["space", "enter"])),
                onFocus: _cache[2] || (_cache[2] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                onBlur: _cache[3] || (_cache[3] = ($event) => focusing.value = false)
              }, [
                renderSlot(_ctx.$slots, "title", {}, () => [
                  createTextVNode(toDisplayString(_ctx.title), 1)
                ]),
                createVNode(unref(ElIcon), {
                  class: normalizeClass(unref(arrowKls))
                }, {
                  default: withCtx(() => [
                    createVNode(unref(arrow_right_default))
                  ]),
                  _: 1
                }, 8, ["class"])
              ], 42, _hoisted_1$q),
              createVNode(unref(_CollapseTransition), null, {
                default: withCtx(() => [
                  withDirectives(createElementVNode("div", {
                    id: unref(scopedContentId),
                    role: "region",
                    class: normalizeClass(unref(itemWrapperKls)),
                    "aria-hidden": !unref(isActive),
                    "aria-labelledby": unref(scopedHeadId)
                  }, [
                    createElementVNode("div", {
                      class: normalizeClass(unref(itemContentKls))
                    }, [
                      renderSlot(_ctx.$slots, "default")
                    ], 2)
                  ], 10, _hoisted_2$l), [
                    [vShow, unref(isActive)]
                  ])
                ]),
                _: 3
              })
            ], 2);
          };
        }
      });
      var CollapseItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$A, [["__file", "collapse-item.vue"]]);
      const ElCollapse = withInstall(Collapse, {
        CollapseItem
      });
      const ElCollapseItem = withNoopInstall(CollapseItem);
      const _hoisted_1$p = {
        viewBox: "0 0 79 86",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg",
        "xmlns:xlink": "http://www.w3.org/1999/xlink"
      };
      const _hoisted_2$k = ["id"];
      const _hoisted_3$c = ["stop-color"];
      const _hoisted_4$9 = ["stop-color"];
      const _hoisted_5$8 = ["id"];
      const _hoisted_6$6 = ["stop-color"];
      const _hoisted_7$4 = ["stop-color"];
      const _hoisted_8$4 = ["id"];
      const _hoisted_9$4 = {
        id: "Illustrations",
        stroke: "none",
        "stroke-width": "1",
        fill: "none",
        "fill-rule": "evenodd"
      };
      const _hoisted_10$4 = {
        id: "B-type",
        transform: "translate(-1268.000000, -535.000000)"
      };
      const _hoisted_11$4 = {
        id: "Group-2",
        transform: "translate(1268.000000, 535.000000)"
      };
      const _hoisted_12$2 = ["fill"];
      const _hoisted_13$2 = ["fill"];
      const _hoisted_14$2 = {
        id: "Group-Copy",
        transform: "translate(34.500000, 31.500000) scale(-1, 1) rotate(-25.000000) translate(-34.500000, -31.500000) translate(7.000000, 10.000000)"
      };
      const _hoisted_15$2 = ["fill"];
      const _hoisted_16$2 = ["fill"];
      const _hoisted_17$1 = ["fill"];
      const _hoisted_18$1 = ["fill"];
      const _hoisted_19$1 = ["fill"];
      const _hoisted_20$1 = {
        id: "Rectangle-Copy-17",
        transform: "translate(53.000000, 45.000000)"
      };
      const _hoisted_21$1 = ["fill", "xlink:href"];
      const _hoisted_22$1 = ["fill", "mask"];
      const _hoisted_23$1 = ["fill"];
      const __default__$f = defineComponent({
        name: "ImgEmpty"
      });
      const _sfc_main$z = /* @__PURE__ */ defineComponent({
        ...__default__$f,
        setup(__props) {
          const ns = useNamespace("empty");
          const id = useId();
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("svg", _hoisted_1$p, [
              createElementVNode("defs", null, [
                createElementVNode("linearGradient", {
                  id: `linearGradient-1-${unref(id)}`,
                  x1: "38.8503086%",
                  y1: "0%",
                  x2: "61.1496914%",
                  y2: "100%"
                }, [
                  createElementVNode("stop", {
                    "stop-color": `var(${unref(ns).cssVarBlockName("fill-color-1")})`,
                    offset: "0%"
                  }, null, 8, _hoisted_3$c),
                  createElementVNode("stop", {
                    "stop-color": `var(${unref(ns).cssVarBlockName("fill-color-4")})`,
                    offset: "100%"
                  }, null, 8, _hoisted_4$9)
                ], 8, _hoisted_2$k),
                createElementVNode("linearGradient", {
                  id: `linearGradient-2-${unref(id)}`,
                  x1: "0%",
                  y1: "9.5%",
                  x2: "100%",
                  y2: "90.5%"
                }, [
                  createElementVNode("stop", {
                    "stop-color": `var(${unref(ns).cssVarBlockName("fill-color-1")})`,
                    offset: "0%"
                  }, null, 8, _hoisted_6$6),
                  createElementVNode("stop", {
                    "stop-color": `var(${unref(ns).cssVarBlockName("fill-color-6")})`,
                    offset: "100%"
                  }, null, 8, _hoisted_7$4)
                ], 8, _hoisted_5$8),
                createElementVNode("rect", {
                  id: `path-3-${unref(id)}`,
                  x: "0",
                  y: "0",
                  width: "17",
                  height: "36"
                }, null, 8, _hoisted_8$4)
              ]),
              createElementVNode("g", _hoisted_9$4, [
                createElementVNode("g", _hoisted_10$4, [
                  createElementVNode("g", _hoisted_11$4, [
                    createElementVNode("path", {
                      id: "Oval-Copy-2",
                      d: "M39.5,86 C61.3152476,86 79,83.9106622 79,81.3333333 C79,78.7560045 57.3152476,78 35.5,78 C13.6847524,78 0,78.7560045 0,81.3333333 C0,83.9106622 17.6847524,86 39.5,86 Z",
                      fill: `var(${unref(ns).cssVarBlockName("fill-color-3")})`
                    }, null, 8, _hoisted_12$2),
                    createElementVNode("polygon", {
                      id: "Rectangle-Copy-14",
                      fill: `var(${unref(ns).cssVarBlockName("fill-color-7")})`,
                      transform: "translate(27.500000, 51.500000) scale(1, -1) translate(-27.500000, -51.500000) ",
                      points: "13 58 53 58 42 45 2 45"
                    }, null, 8, _hoisted_13$2),
                    createElementVNode("g", _hoisted_14$2, [
                      createElementVNode("polygon", {
                        id: "Rectangle-Copy-10",
                        fill: `var(${unref(ns).cssVarBlockName("fill-color-7")})`,
                        transform: "translate(11.500000, 5.000000) scale(1, -1) translate(-11.500000, -5.000000) ",
                        points: "2.84078316e-14 3 18 3 23 7 5 7"
                      }, null, 8, _hoisted_15$2),
                      createElementVNode("polygon", {
                        id: "Rectangle-Copy-11",
                        fill: `var(${unref(ns).cssVarBlockName("fill-color-5")})`,
                        points: "-3.69149156e-15 7 38 7 38 43 -3.69149156e-15 43"
                      }, null, 8, _hoisted_16$2),
                      createElementVNode("rect", {
                        id: "Rectangle-Copy-12",
                        fill: `url(#linearGradient-1-${unref(id)})`,
                        transform: "translate(46.500000, 25.000000) scale(-1, 1) translate(-46.500000, -25.000000) ",
                        x: "38",
                        y: "7",
                        width: "17",
                        height: "36"
                      }, null, 8, _hoisted_17$1),
                      createElementVNode("polygon", {
                        id: "Rectangle-Copy-13",
                        fill: `var(${unref(ns).cssVarBlockName("fill-color-2")})`,
                        transform: "translate(39.500000, 3.500000) scale(-1, 1) translate(-39.500000, -3.500000) ",
                        points: "24 7 41 7 55 -3.63806207e-12 38 -3.63806207e-12"
                      }, null, 8, _hoisted_18$1)
                    ]),
                    createElementVNode("rect", {
                      id: "Rectangle-Copy-15",
                      fill: `url(#linearGradient-2-${unref(id)})`,
                      x: "13",
                      y: "45",
                      width: "40",
                      height: "36"
                    }, null, 8, _hoisted_19$1),
                    createElementVNode("g", _hoisted_20$1, [
                      createElementVNode("use", {
                        id: "Mask",
                        fill: `var(${unref(ns).cssVarBlockName("fill-color-8")})`,
                        transform: "translate(8.500000, 18.000000) scale(-1, 1) translate(-8.500000, -18.000000) ",
                        "xlink:href": `#path-3-${unref(id)}`
                      }, null, 8, _hoisted_21$1),
                      createElementVNode("polygon", {
                        id: "Rectangle-Copy",
                        fill: `var(${unref(ns).cssVarBlockName("fill-color-9")})`,
                        mask: `url(#mask-4-${unref(id)})`,
                        transform: "translate(12.000000, 9.000000) scale(-1, 1) translate(-12.000000, -9.000000) ",
                        points: "7 0 24 0 20 18 7 16.5"
                      }, null, 8, _hoisted_22$1)
                    ]),
                    createElementVNode("polygon", {
                      id: "Rectangle-Copy-18",
                      fill: `var(${unref(ns).cssVarBlockName("fill-color-2")})`,
                      transform: "translate(66.000000, 51.500000) scale(-1, 1) translate(-66.000000, -51.500000) ",
                      points: "62 45 79 45 70 58 53 58"
                    }, null, 8, _hoisted_23$1)
                  ])
                ])
              ])
            ]);
          };
        }
      });
      var ImgEmpty = /* @__PURE__ */ _export_sfc$1(_sfc_main$z, [["__file", "img-empty.vue"]]);
      const emptyProps = buildProps({
        image: {
          type: String,
          default: ""
        },
        imageSize: Number,
        description: {
          type: String,
          default: ""
        }
      });
      const _hoisted_1$o = ["src"];
      const _hoisted_2$j = { key: 1 };
      const __default__$e = defineComponent({
        name: "ElEmpty"
      });
      const _sfc_main$y = /* @__PURE__ */ defineComponent({
        ...__default__$e,
        props: emptyProps,
        setup(__props) {
          const props = __props;
          const { t } = useLocale();
          const ns = useNamespace("empty");
          const emptyDescription = computed(() => props.description || t("el.table.emptyText"));
          const imageStyle = computed(() => ({
            width: addUnit(props.imageSize)
          }));
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(ns).b())
            }, [
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("image")),
                style: normalizeStyle(unref(imageStyle))
              }, [
                _ctx.image ? (openBlock(), createElementBlock("img", {
                  key: 0,
                  src: _ctx.image,
                  ondragstart: "return false"
                }, null, 8, _hoisted_1$o)) : renderSlot(_ctx.$slots, "image", { key: 1 }, () => [
                  createVNode(ImgEmpty)
                ])
              ], 6),
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("description"))
              }, [
                _ctx.$slots.description ? renderSlot(_ctx.$slots, "description", { key: 0 }) : (openBlock(), createElementBlock("p", _hoisted_2$j, toDisplayString(unref(emptyDescription)), 1))
              ], 2),
              _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).e("bottom"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var Empty = /* @__PURE__ */ _export_sfc$1(_sfc_main$y, [["__file", "empty.vue"]]);
      const ElEmpty = withInstall(Empty);
      const inputNumberProps = buildProps({
        id: {
          type: String,
          default: void 0
        },
        step: {
          type: Number,
          default: 1
        },
        stepStrictly: Boolean,
        max: {
          type: Number,
          default: Number.POSITIVE_INFINITY
        },
        min: {
          type: Number,
          default: Number.NEGATIVE_INFINITY
        },
        modelValue: Number,
        readonly: Boolean,
        disabled: Boolean,
        size: useSizeProp,
        controls: {
          type: Boolean,
          default: true
        },
        controlsPosition: {
          type: String,
          default: "",
          values: ["", "right"]
        },
        valueOnClear: {
          type: [String, Number, null],
          validator: (val) => val === null || isNumber(val) || ["min", "max"].includes(val),
          default: null
        },
        name: String,
        label: String,
        placeholder: String,
        precision: {
          type: Number,
          validator: (val) => val >= 0 && val === Number.parseInt(`${val}`, 10)
        },
        validateEvent: {
          type: Boolean,
          default: true
        }
      });
      const inputNumberEmits = {
        [CHANGE_EVENT]: (cur, prev) => prev !== cur,
        blur: (e) => e instanceof FocusEvent,
        focus: (e) => e instanceof FocusEvent,
        [INPUT_EVENT]: (val) => isNumber(val) || isNil(val),
        [UPDATE_MODEL_EVENT]: (val) => isNumber(val) || isNil(val)
      };
      const _hoisted_1$n = ["aria-label", "onKeydown"];
      const _hoisted_2$i = ["aria-label", "onKeydown"];
      const __default__$d = defineComponent({
        name: "ElInputNumber"
      });
      const _sfc_main$x = /* @__PURE__ */ defineComponent({
        ...__default__$d,
        props: inputNumberProps,
        emits: inputNumberEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const { t } = useLocale();
          const ns = useNamespace("input-number");
          const input = ref();
          const data = reactive({
            currentValue: props.modelValue,
            userInput: null
          });
          const { formItem } = useFormItem();
          const minDisabled = computed(() => isNumber(props.modelValue) && props.modelValue <= props.min);
          const maxDisabled = computed(() => isNumber(props.modelValue) && props.modelValue >= props.max);
          const numPrecision = computed(() => {
            const stepPrecision = getPrecision(props.step);
            if (!isUndefined(props.precision)) {
              if (stepPrecision > props.precision)
                ;
              return props.precision;
            } else {
              return Math.max(getPrecision(props.modelValue), stepPrecision);
            }
          });
          const controlsAtRight = computed(() => {
            return props.controls && props.controlsPosition === "right";
          });
          const inputNumberSize = useFormSize();
          const inputNumberDisabled = useFormDisabled();
          const displayValue = computed(() => {
            if (data.userInput !== null) {
              return data.userInput;
            }
            let currentValue = data.currentValue;
            if (isNil(currentValue))
              return "";
            if (isNumber(currentValue)) {
              if (Number.isNaN(currentValue))
                return "";
              if (!isUndefined(props.precision)) {
                currentValue = currentValue.toFixed(props.precision);
              }
            }
            return currentValue;
          });
          const toPrecision = (num, pre) => {
            if (isUndefined(pre))
              pre = numPrecision.value;
            if (pre === 0)
              return Math.round(num);
            let snum = String(num);
            const pointPos = snum.indexOf(".");
            if (pointPos === -1)
              return num;
            const nums = snum.replace(".", "").split("");
            const datum = nums[pointPos + pre];
            if (!datum)
              return num;
            const length = snum.length;
            if (snum.charAt(length - 1) === "5") {
              snum = `${snum.slice(0, Math.max(0, length - 1))}6`;
            }
            return Number.parseFloat(Number(snum).toFixed(pre));
          };
          const getPrecision = (value) => {
            if (isNil(value))
              return 0;
            const valueString = value.toString();
            const dotPosition = valueString.indexOf(".");
            let precision = 0;
            if (dotPosition !== -1) {
              precision = valueString.length - dotPosition - 1;
            }
            return precision;
          };
          const ensurePrecision = (val, coefficient = 1) => {
            if (!isNumber(val))
              return data.currentValue;
            return toPrecision(val + props.step * coefficient);
          };
          const increase = () => {
            if (props.readonly || inputNumberDisabled.value || maxDisabled.value)
              return;
            const value = Number(displayValue.value) || 0;
            const newVal = ensurePrecision(value);
            setCurrentValue(newVal);
            emit(INPUT_EVENT, data.currentValue);
            setCurrentValueToModelValue();
          };
          const decrease = () => {
            if (props.readonly || inputNumberDisabled.value || minDisabled.value)
              return;
            const value = Number(displayValue.value) || 0;
            const newVal = ensurePrecision(value, -1);
            setCurrentValue(newVal);
            emit(INPUT_EVENT, data.currentValue);
            setCurrentValueToModelValue();
          };
          const verifyValue = (value, update) => {
            const { max, min, step, precision, stepStrictly, valueOnClear } = props;
            if (max < min) {
              throwError("InputNumber", "min should not be greater than max.");
            }
            let newVal = Number(value);
            if (isNil(value) || Number.isNaN(newVal)) {
              return null;
            }
            if (value === "") {
              if (valueOnClear === null) {
                return null;
              }
              newVal = isString(valueOnClear) ? { min, max }[valueOnClear] : valueOnClear;
            }
            if (stepStrictly) {
              newVal = toPrecision(Math.round(newVal / step) * step, precision);
            }
            if (!isUndefined(precision)) {
              newVal = toPrecision(newVal, precision);
            }
            if (newVal > max || newVal < min) {
              newVal = newVal > max ? max : min;
              update && emit(UPDATE_MODEL_EVENT, newVal);
            }
            return newVal;
          };
          const setCurrentValue = (value, emitChange = true) => {
            var _a;
            const oldVal = data.currentValue;
            const newVal = verifyValue(value);
            if (!emitChange) {
              emit(UPDATE_MODEL_EVENT, newVal);
              return;
            }
            if (oldVal === newVal && value)
              return;
            data.userInput = null;
            emit(UPDATE_MODEL_EVENT, newVal);
            if (oldVal !== newVal) {
              emit(CHANGE_EVENT, newVal, oldVal);
            }
            if (props.validateEvent) {
              (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "change").catch((err) => debugWarn());
            }
            data.currentValue = newVal;
          };
          const handleInput = (value) => {
            data.userInput = value;
            const newVal = value === "" ? null : Number(value);
            emit(INPUT_EVENT, newVal);
            setCurrentValue(newVal, false);
          };
          const handleInputChange = (value) => {
            const newVal = value !== "" ? Number(value) : "";
            if (isNumber(newVal) && !Number.isNaN(newVal) || value === "") {
              setCurrentValue(newVal);
            }
            setCurrentValueToModelValue();
            data.userInput = null;
          };
          const focus = () => {
            var _a, _b;
            (_b = (_a = input.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
          };
          const blur = () => {
            var _a, _b;
            (_b = (_a = input.value) == null ? void 0 : _a.blur) == null ? void 0 : _b.call(_a);
          };
          const handleFocus = (event) => {
            emit("focus", event);
          };
          const handleBlur = (event) => {
            var _a;
            data.userInput = null;
            emit("blur", event);
            if (props.validateEvent) {
              (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "blur").catch((err) => debugWarn());
            }
          };
          const setCurrentValueToModelValue = () => {
            if (data.currentValue !== props.modelValue) {
              data.currentValue = props.modelValue;
            }
          };
          const handleWheel = (e) => {
            if (document.activeElement === e.target)
              e.preventDefault();
          };
          watch(() => props.modelValue, (value, oldValue) => {
            const newValue = verifyValue(value, true);
            if (data.userInput === null && newValue !== oldValue) {
              data.currentValue = newValue;
            }
          }, { immediate: true });
          onMounted(() => {
            var _a;
            const { min, max, modelValue } = props;
            const innerInput = (_a = input.value) == null ? void 0 : _a.input;
            innerInput.setAttribute("role", "spinbutton");
            if (Number.isFinite(max)) {
              innerInput.setAttribute("aria-valuemax", String(max));
            } else {
              innerInput.removeAttribute("aria-valuemax");
            }
            if (Number.isFinite(min)) {
              innerInput.setAttribute("aria-valuemin", String(min));
            } else {
              innerInput.removeAttribute("aria-valuemin");
            }
            innerInput.setAttribute("aria-valuenow", data.currentValue || data.currentValue === 0 ? String(data.currentValue) : "");
            innerInput.setAttribute("aria-disabled", String(inputNumberDisabled.value));
            if (!isNumber(modelValue) && modelValue != null) {
              let val = Number(modelValue);
              if (Number.isNaN(val)) {
                val = null;
              }
              emit(UPDATE_MODEL_EVENT, val);
            }
          });
          onUpdated(() => {
            var _a, _b;
            const innerInput = (_a = input.value) == null ? void 0 : _a.input;
            innerInput == null ? void 0 : innerInput.setAttribute("aria-valuenow", `${(_b = data.currentValue) != null ? _b : ""}`);
          });
          expose({
            focus,
            blur
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).m(unref(inputNumberSize)),
                unref(ns).is("disabled", unref(inputNumberDisabled)),
                unref(ns).is("without-controls", !_ctx.controls),
                unref(ns).is("controls-right", unref(controlsAtRight))
              ]),
              onDragstart: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["prevent"]))
            }, [
              _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
                key: 0,
                role: "button",
                "aria-label": unref(t)("el.inputNumber.decrease"),
                class: normalizeClass([unref(ns).e("decrease"), unref(ns).is("disabled", unref(minDisabled))]),
                onKeydown: withKeys(decrease, ["enter"])
              }, [
                renderSlot(_ctx.$slots, "decrease-icon", {}, () => [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_down_default), { key: 0 })) : (openBlock(), createBlock(unref(minus_default), { key: 1 }))
                    ]),
                    _: 1
                  })
                ])
              ], 42, _hoisted_1$n)), [
                [unref(vRepeatClick), decrease]
              ]) : createCommentVNode("v-if", true),
              _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
                key: 1,
                role: "button",
                "aria-label": unref(t)("el.inputNumber.increase"),
                class: normalizeClass([unref(ns).e("increase"), unref(ns).is("disabled", unref(maxDisabled))]),
                onKeydown: withKeys(increase, ["enter"])
              }, [
                renderSlot(_ctx.$slots, "increase-icon", {}, () => [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_up_default), { key: 0 })) : (openBlock(), createBlock(unref(plus_default), { key: 1 }))
                    ]),
                    _: 1
                  })
                ])
              ], 42, _hoisted_2$i)), [
                [unref(vRepeatClick), increase]
              ]) : createCommentVNode("v-if", true),
              createVNode(unref(ElInput), {
                id: _ctx.id,
                ref_key: "input",
                ref: input,
                type: "number",
                step: _ctx.step,
                "model-value": unref(displayValue),
                placeholder: _ctx.placeholder,
                readonly: _ctx.readonly,
                disabled: unref(inputNumberDisabled),
                size: unref(inputNumberSize),
                max: _ctx.max,
                min: _ctx.min,
                name: _ctx.name,
                label: _ctx.label,
                "validate-event": false,
                onWheel: handleWheel,
                onKeydown: [
                  withKeys(withModifiers(increase, ["prevent"]), ["up"]),
                  withKeys(withModifiers(decrease, ["prevent"]), ["down"])
                ],
                onBlur: handleBlur,
                onFocus: handleFocus,
                onInput: handleInput,
                onChange: handleInputChange
              }, null, 8, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "label", "onKeydown"])
            ], 34);
          };
        }
      });
      var InputNumber = /* @__PURE__ */ _export_sfc$1(_sfc_main$x, [["__file", "input-number.vue"]]);
      const ElInputNumber = withInstall(InputNumber);
      let SubMenu$1 = class SubMenu {
        constructor(parent, domNode) {
          this.parent = parent;
          this.domNode = domNode;
          this.subIndex = 0;
          this.subIndex = 0;
          this.init();
        }
        init() {
          this.subMenuItems = this.domNode.querySelectorAll("li");
          this.addListeners();
        }
        gotoSubIndex(idx) {
          if (idx === this.subMenuItems.length) {
            idx = 0;
          } else if (idx < 0) {
            idx = this.subMenuItems.length - 1;
          }
          this.subMenuItems[idx].focus();
          this.subIndex = idx;
        }
        addListeners() {
          const parentNode = this.parent.domNode;
          Array.prototype.forEach.call(this.subMenuItems, (el) => {
            el.addEventListener("keydown", (event) => {
              let prevDef = false;
              switch (event.code) {
                case EVENT_CODE.down: {
                  this.gotoSubIndex(this.subIndex + 1);
                  prevDef = true;
                  break;
                }
                case EVENT_CODE.up: {
                  this.gotoSubIndex(this.subIndex - 1);
                  prevDef = true;
                  break;
                }
                case EVENT_CODE.tab: {
                  triggerEvent(parentNode, "mouseleave");
                  break;
                }
                case EVENT_CODE.enter:
                case EVENT_CODE.space: {
                  prevDef = true;
                  event.currentTarget.click();
                  break;
                }
              }
              if (prevDef) {
                event.preventDefault();
                event.stopPropagation();
              }
              return false;
            });
          });
        }
      };
      let MenuItem$1 = class MenuItem {
        constructor(domNode, namespace) {
          this.domNode = domNode;
          this.submenu = null;
          this.submenu = null;
          this.init(namespace);
        }
        init(namespace) {
          this.domNode.setAttribute("tabindex", "0");
          const menuChild = this.domNode.querySelector(`.${namespace}-menu`);
          if (menuChild) {
            this.submenu = new SubMenu$1(this, menuChild);
          }
          this.addListeners();
        }
        addListeners() {
          this.domNode.addEventListener("keydown", (event) => {
            let prevDef = false;
            switch (event.code) {
              case EVENT_CODE.down: {
                triggerEvent(event.currentTarget, "mouseenter");
                this.submenu && this.submenu.gotoSubIndex(0);
                prevDef = true;
                break;
              }
              case EVENT_CODE.up: {
                triggerEvent(event.currentTarget, "mouseenter");
                this.submenu && this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1);
                prevDef = true;
                break;
              }
              case EVENT_CODE.tab: {
                triggerEvent(event.currentTarget, "mouseleave");
                break;
              }
              case EVENT_CODE.enter:
              case EVENT_CODE.space: {
                prevDef = true;
                event.currentTarget.click();
                break;
              }
            }
            if (prevDef) {
              event.preventDefault();
            }
          });
        }
      };
      let Menu$1 = class Menu {
        constructor(domNode, namespace) {
          this.domNode = domNode;
          this.init(namespace);
        }
        init(namespace) {
          const menuChildren = this.domNode.childNodes;
          Array.from(menuChildren).forEach((child) => {
            if (child.nodeType === 1) {
              new MenuItem$1(child, namespace);
            }
          });
        }
      };
      const _sfc_main$w = defineComponent({
        name: "ElMenuCollapseTransition",
        setup() {
          const ns = useNamespace("menu");
          const listeners = {
            onBeforeEnter: (el) => el.style.opacity = "0.2",
            onEnter(el, done) {
              addClass(el, `${ns.namespace.value}-opacity-transition`);
              el.style.opacity = "1";
              done();
            },
            onAfterEnter(el) {
              removeClass(el, `${ns.namespace.value}-opacity-transition`);
              el.style.opacity = "";
            },
            onBeforeLeave(el) {
              if (!el.dataset) {
                el.dataset = {};
              }
              if (hasClass(el, ns.m("collapse"))) {
                removeClass(el, ns.m("collapse"));
                el.dataset.oldOverflow = el.style.overflow;
                el.dataset.scrollWidth = el.clientWidth.toString();
                addClass(el, ns.m("collapse"));
              } else {
                addClass(el, ns.m("collapse"));
                el.dataset.oldOverflow = el.style.overflow;
                el.dataset.scrollWidth = el.clientWidth.toString();
                removeClass(el, ns.m("collapse"));
              }
              el.style.width = `${el.scrollWidth}px`;
              el.style.overflow = "hidden";
            },
            onLeave(el) {
              addClass(el, "horizontal-collapse-transition");
              el.style.width = `${el.dataset.scrollWidth}px`;
            }
          };
          return {
            listeners
          };
        }
      });
      function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createBlock(Transition, mergeProps({ mode: "out-in" }, _ctx.listeners), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16);
      }
      var ElMenuCollapseTransition = /* @__PURE__ */ _export_sfc$1(_sfc_main$w, [["render", _sfc_render$a], ["__file", "menu-collapse-transition.vue"]]);
      function useMenu(instance, currentIndex) {
        const indexPath = computed(() => {
          let parent = instance.parent;
          const path = [currentIndex.value];
          while (parent.type.name !== "ElMenu") {
            if (parent.props.index) {
              path.unshift(parent.props.index);
            }
            parent = parent.parent;
          }
          return path;
        });
        const parentMenu = computed(() => {
          let parent = instance.parent;
          while (parent && !["ElMenu", "ElSubMenu"].includes(parent.type.name)) {
            parent = parent.parent;
          }
          return parent;
        });
        return {
          parentMenu,
          indexPath
        };
      }
      function useMenuColor(props) {
        const menuBarColor = computed(() => {
          const color = props.backgroundColor;
          if (!color) {
            return "";
          } else {
            return new TinyColor(color).shade(20).toString();
          }
        });
        return menuBarColor;
      }
      const useMenuCssVar = (props, level) => {
        const ns = useNamespace("menu");
        return computed(() => {
          return ns.cssVarBlock({
            "text-color": props.textColor || "",
            "hover-text-color": props.textColor || "",
            "bg-color": props.backgroundColor || "",
            "hover-bg-color": useMenuColor(props).value || "",
            "active-color": props.activeTextColor || "",
            level: `${level}`
          });
        });
      };
      const subMenuProps = buildProps({
        index: {
          type: String,
          required: true
        },
        showTimeout: Number,
        hideTimeout: Number,
        popperClass: String,
        disabled: Boolean,
        teleported: {
          type: Boolean,
          default: void 0
        },
        popperOffset: Number,
        expandCloseIcon: {
          type: iconPropType
        },
        expandOpenIcon: {
          type: iconPropType
        },
        collapseCloseIcon: {
          type: iconPropType
        },
        collapseOpenIcon: {
          type: iconPropType
        }
      });
      const COMPONENT_NAME$5 = "ElSubMenu";
      var SubMenu2 = defineComponent({
        name: COMPONENT_NAME$5,
        props: subMenuProps,
        setup(props, { slots, expose }) {
          const instance = getCurrentInstance();
          const { indexPath, parentMenu } = useMenu(instance, computed(() => props.index));
          const nsMenu = useNamespace("menu");
          const nsSubMenu = useNamespace("sub-menu");
          const rootMenu = inject("rootMenu");
          if (!rootMenu)
            throwError(COMPONENT_NAME$5, "can not inject root menu");
          const subMenu = inject(`subMenu:${parentMenu.value.uid}`);
          if (!subMenu)
            throwError(COMPONENT_NAME$5, "can not inject sub menu");
          const items = ref({});
          const subMenus = ref({});
          let timeout;
          const mouseInChild = ref(false);
          const verticalTitleRef = ref();
          const vPopper = ref(null);
          const currentPlacement = computed(() => mode.value === "horizontal" && isFirstLevel.value ? "bottom-start" : "right-start");
          const subMenuTitleIcon = computed(() => {
            return mode.value === "horizontal" && isFirstLevel.value || mode.value === "vertical" && !rootMenu.props.collapse ? props.expandCloseIcon && props.expandOpenIcon ? opened.value ? props.expandOpenIcon : props.expandCloseIcon : arrow_down_default : props.collapseCloseIcon && props.collapseOpenIcon ? opened.value ? props.collapseOpenIcon : props.collapseCloseIcon : arrow_right_default;
          });
          const isFirstLevel = computed(() => {
            return subMenu.level === 0;
          });
          const appendToBody = computed(() => {
            const value = props.teleported;
            return value === void 0 ? isFirstLevel.value : value;
          });
          const menuTransitionName = computed(() => rootMenu.props.collapse ? `${nsMenu.namespace.value}-zoom-in-left` : `${nsMenu.namespace.value}-zoom-in-top`);
          const fallbackPlacements = computed(() => mode.value === "horizontal" && isFirstLevel.value ? [
            "bottom-start",
            "bottom-end",
            "top-start",
            "top-end",
            "right-start",
            "left-start"
          ] : [
            "right-start",
            "right",
            "right-end",
            "left-start",
            "bottom-start",
            "bottom-end",
            "top-start",
            "top-end"
          ]);
          const opened = computed(() => rootMenu.openedMenus.includes(props.index));
          const active = computed(() => {
            let isActive = false;
            Object.values(items.value).forEach((item2) => {
              if (item2.active) {
                isActive = true;
              }
            });
            Object.values(subMenus.value).forEach((subItem) => {
              if (subItem.active) {
                isActive = true;
              }
            });
            return isActive;
          });
          const mode = computed(() => rootMenu.props.mode);
          const item = reactive({
            index: props.index,
            indexPath,
            active
          });
          const ulStyle = useMenuCssVar(rootMenu.props, subMenu.level + 1);
          const subMenuPopperOffset = computed(() => {
            var _a;
            return (_a = props.popperOffset) != null ? _a : rootMenu.props.popperOffset;
          });
          const subMenuPopperClass = computed(() => {
            var _a;
            return (_a = props.popperClass) != null ? _a : rootMenu.props.popperClass;
          });
          const subMenuShowTimeout = computed(() => {
            var _a;
            return (_a = props.showTimeout) != null ? _a : rootMenu.props.showTimeout;
          });
          const subMenuHideTimeout = computed(() => {
            var _a;
            return (_a = props.hideTimeout) != null ? _a : rootMenu.props.hideTimeout;
          });
          const doDestroy = () => {
            var _a, _b, _c;
            return (_c = (_b = (_a = vPopper.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.popperInstanceRef) == null ? void 0 : _c.destroy();
          };
          const handleCollapseToggle = (value) => {
            if (!value) {
              doDestroy();
            }
          };
          const handleClick = () => {
            if (rootMenu.props.menuTrigger === "hover" && rootMenu.props.mode === "horizontal" || rootMenu.props.collapse && rootMenu.props.mode === "vertical" || props.disabled)
              return;
            rootMenu.handleSubMenuClick({
              index: props.index,
              indexPath: indexPath.value,
              active: active.value
            });
          };
          const handleMouseenter = (event, showTimeout = subMenuShowTimeout.value) => {
            var _a;
            if (event.type === "focus") {
              return;
            }
            if (rootMenu.props.menuTrigger === "click" && rootMenu.props.mode === "horizontal" || !rootMenu.props.collapse && rootMenu.props.mode === "vertical" || props.disabled) {
              subMenu.mouseInChild.value = true;
              return;
            }
            subMenu.mouseInChild.value = true;
            timeout == null ? void 0 : timeout();
            ({ stop: timeout } = useTimeoutFn(() => {
              rootMenu.openMenu(props.index, indexPath.value);
            }, showTimeout));
            if (appendToBody.value) {
              (_a = parentMenu.value.vnode.el) == null ? void 0 : _a.dispatchEvent(new MouseEvent("mouseenter"));
            }
          };
          const handleMouseleave = (deepDispatch = false) => {
            var _a;
            if (rootMenu.props.menuTrigger === "click" && rootMenu.props.mode === "horizontal" || !rootMenu.props.collapse && rootMenu.props.mode === "vertical") {
              subMenu.mouseInChild.value = false;
              return;
            }
            timeout == null ? void 0 : timeout();
            subMenu.mouseInChild.value = false;
            ({ stop: timeout } = useTimeoutFn(() => !mouseInChild.value && rootMenu.closeMenu(props.index, indexPath.value), subMenuHideTimeout.value));
            if (appendToBody.value && deepDispatch) {
              (_a = subMenu.handleMouseleave) == null ? void 0 : _a.call(subMenu, true);
            }
          };
          watch(() => rootMenu.props.collapse, (value) => handleCollapseToggle(Boolean(value)));
          {
            const addSubMenu = (item2) => {
              subMenus.value[item2.index] = item2;
            };
            const removeSubMenu = (item2) => {
              delete subMenus.value[item2.index];
            };
            provide(`subMenu:${instance.uid}`, {
              addSubMenu,
              removeSubMenu,
              handleMouseleave,
              mouseInChild,
              level: subMenu.level + 1
            });
          }
          expose({
            opened
          });
          onMounted(() => {
            rootMenu.addSubMenu(item);
            subMenu.addSubMenu(item);
          });
          onBeforeUnmount(() => {
            subMenu.removeSubMenu(item);
            rootMenu.removeSubMenu(item);
          });
          return () => {
            var _a;
            const titleTag = [
              (_a = slots.title) == null ? void 0 : _a.call(slots),
              h(ElIcon, {
                class: nsSubMenu.e("icon-arrow"),
                style: {
                  transform: opened.value ? props.expandCloseIcon && props.expandOpenIcon || props.collapseCloseIcon && props.collapseOpenIcon && rootMenu.props.collapse ? "none" : "rotateZ(180deg)" : "none"
                }
              }, {
                default: () => isString(subMenuTitleIcon.value) ? h(instance.appContext.components[subMenuTitleIcon.value]) : h(subMenuTitleIcon.value)
              })
            ];
            const child = rootMenu.isMenuPopup ? h(ElTooltip, {
              ref: vPopper,
              visible: opened.value,
              effect: "light",
              pure: true,
              offset: subMenuPopperOffset.value,
              showArrow: false,
              persistent: true,
              popperClass: subMenuPopperClass.value,
              placement: currentPlacement.value,
              teleported: appendToBody.value,
              fallbackPlacements: fallbackPlacements.value,
              transition: menuTransitionName.value,
              gpuAcceleration: false
            }, {
              content: () => {
                var _a2;
                return h("div", {
                  class: [
                    nsMenu.m(mode.value),
                    nsMenu.m("popup-container"),
                    subMenuPopperClass.value
                  ],
                  onMouseenter: (evt) => handleMouseenter(evt, 100),
                  onMouseleave: () => handleMouseleave(true),
                  onFocus: (evt) => handleMouseenter(evt, 100)
                }, [
                  h("ul", {
                    class: [
                      nsMenu.b(),
                      nsMenu.m("popup"),
                      nsMenu.m(`popup-${currentPlacement.value}`)
                    ],
                    style: ulStyle.value
                  }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)])
                ]);
              },
              default: () => h("div", {
                class: nsSubMenu.e("title"),
                onClick: handleClick
              }, titleTag)
            }) : h(Fragment, {}, [
              h("div", {
                class: nsSubMenu.e("title"),
                ref: verticalTitleRef,
                onClick: handleClick
              }, titleTag),
              h(_CollapseTransition, {}, {
                default: () => {
                  var _a2;
                  return withDirectives(h("ul", {
                    role: "menu",
                    class: [nsMenu.b(), nsMenu.m("inline")],
                    style: ulStyle.value
                  }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), [[vShow, opened.value]]);
                }
              })
            ]);
            return h("li", {
              class: [
                nsSubMenu.b(),
                nsSubMenu.is("active", active.value),
                nsSubMenu.is("opened", opened.value),
                nsSubMenu.is("disabled", props.disabled)
              ],
              role: "menuitem",
              ariaHaspopup: true,
              ariaExpanded: opened.value,
              onMouseenter: handleMouseenter,
              onMouseleave: () => handleMouseleave(),
              onFocus: handleMouseenter
            }, [child]);
          };
        }
      });
      const menuProps = buildProps({
        mode: {
          type: String,
          values: ["horizontal", "vertical"],
          default: "vertical"
        },
        defaultActive: {
          type: String,
          default: ""
        },
        defaultOpeneds: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        uniqueOpened: Boolean,
        router: Boolean,
        menuTrigger: {
          type: String,
          values: ["hover", "click"],
          default: "hover"
        },
        collapse: Boolean,
        backgroundColor: String,
        textColor: String,
        activeTextColor: String,
        closeOnClickOutside: Boolean,
        collapseTransition: {
          type: Boolean,
          default: true
        },
        ellipsis: {
          type: Boolean,
          default: true
        },
        popperOffset: {
          type: Number,
          default: 6
        },
        ellipsisIcon: {
          type: iconPropType,
          default: () => more_default
        },
        popperEffect: {
          type: String,
          values: ["dark", "light"],
          default: "dark"
        },
        popperClass: String,
        showTimeout: {
          type: Number,
          default: 300
        },
        hideTimeout: {
          type: Number,
          default: 300
        }
      });
      const checkIndexPath = (indexPath) => Array.isArray(indexPath) && indexPath.every((path) => isString(path));
      const menuEmits = {
        close: (index, indexPath) => isString(index) && checkIndexPath(indexPath),
        open: (index, indexPath) => isString(index) && checkIndexPath(indexPath),
        select: (index, indexPath, item, routerResult) => isString(index) && checkIndexPath(indexPath) && isObject$1(item) && (routerResult === void 0 || routerResult instanceof Promise)
      };
      var Menu2 = defineComponent({
        name: "ElMenu",
        props: menuProps,
        emits: menuEmits,
        setup(props, { emit, slots, expose }) {
          const instance = getCurrentInstance();
          const router = instance.appContext.config.globalProperties.$router;
          const menu = ref();
          const nsMenu = useNamespace("menu");
          const nsSubMenu = useNamespace("sub-menu");
          const sliceIndex = ref(-1);
          const openedMenus = ref(props.defaultOpeneds && !props.collapse ? props.defaultOpeneds.slice(0) : []);
          const activeIndex = ref(props.defaultActive);
          const items = ref({});
          const subMenus = ref({});
          const isMenuPopup = computed(() => {
            return props.mode === "horizontal" || props.mode === "vertical" && props.collapse;
          });
          const initMenu = () => {
            const activeItem = activeIndex.value && items.value[activeIndex.value];
            if (!activeItem || props.mode === "horizontal" || props.collapse)
              return;
            const indexPath = activeItem.indexPath;
            indexPath.forEach((index) => {
              const subMenu = subMenus.value[index];
              subMenu && openMenu(index, subMenu.indexPath);
            });
          };
          const openMenu = (index, indexPath) => {
            if (openedMenus.value.includes(index))
              return;
            if (props.uniqueOpened) {
              openedMenus.value = openedMenus.value.filter((index2) => indexPath.includes(index2));
            }
            openedMenus.value.push(index);
            emit("open", index, indexPath);
          };
          const close = (index) => {
            const i = openedMenus.value.indexOf(index);
            if (i !== -1) {
              openedMenus.value.splice(i, 1);
            }
          };
          const closeMenu = (index, indexPath) => {
            close(index);
            emit("close", index, indexPath);
          };
          const handleSubMenuClick = ({
            index,
            indexPath
          }) => {
            const isOpened = openedMenus.value.includes(index);
            if (isOpened) {
              closeMenu(index, indexPath);
            } else {
              openMenu(index, indexPath);
            }
          };
          const handleMenuItemClick = (menuItem) => {
            if (props.mode === "horizontal" || props.collapse) {
              openedMenus.value = [];
            }
            const { index, indexPath } = menuItem;
            if (isNil(index) || isNil(indexPath))
              return;
            if (props.router && router) {
              const route = menuItem.route || index;
              const routerResult = router.push(route).then((res) => {
                if (!res)
                  activeIndex.value = index;
                return res;
              });
              emit("select", index, indexPath, { index, indexPath, route }, routerResult);
            } else {
              activeIndex.value = index;
              emit("select", index, indexPath, { index, indexPath });
            }
          };
          const updateActiveIndex = (val) => {
            const itemsInData = items.value;
            const item = itemsInData[val] || activeIndex.value && itemsInData[activeIndex.value] || itemsInData[props.defaultActive];
            if (item) {
              activeIndex.value = item.index;
            } else {
              activeIndex.value = val;
            }
          };
          const calcMenuItemWidth = (menuItem) => {
            const computedStyle = getComputedStyle(menuItem);
            const marginLeft = Number.parseInt(computedStyle.marginLeft, 10);
            const marginRight = Number.parseInt(computedStyle.marginRight, 10);
            return menuItem.offsetWidth + marginLeft + marginRight || 0;
          };
          const calcSliceIndex = () => {
            var _a, _b;
            if (!menu.value)
              return -1;
            const items2 = Array.from((_b = (_a = menu.value) == null ? void 0 : _a.childNodes) != null ? _b : []).filter((item) => item.nodeName !== "#comment" && (item.nodeName !== "#text" || item.nodeValue));
            const moreItemWidth = 64;
            const computedMenuStyle = getComputedStyle(menu.value);
            const paddingLeft = Number.parseInt(computedMenuStyle.paddingLeft, 10);
            const paddingRight = Number.parseInt(computedMenuStyle.paddingRight, 10);
            const menuWidth = menu.value.clientWidth - paddingLeft - paddingRight;
            let calcWidth = 0;
            let sliceIndex2 = 0;
            items2.forEach((item, index) => {
              calcWidth += calcMenuItemWidth(item);
              if (calcWidth <= menuWidth - moreItemWidth) {
                sliceIndex2 = index + 1;
              }
            });
            return sliceIndex2 === items2.length ? -1 : sliceIndex2;
          };
          const getIndexPath = (index) => subMenus.value[index].indexPath;
          const debounce2 = (fn, wait = 33.34) => {
            let timmer;
            return () => {
              timmer && clearTimeout(timmer);
              timmer = setTimeout(() => {
                fn();
              }, wait);
            };
          };
          let isFirstTimeRender = true;
          const handleResize = () => {
            if (sliceIndex.value === calcSliceIndex())
              return;
            const callback = () => {
              sliceIndex.value = -1;
              nextTick(() => {
                sliceIndex.value = calcSliceIndex();
              });
            };
            isFirstTimeRender ? callback() : debounce2(callback)();
            isFirstTimeRender = false;
          };
          watch(() => props.defaultActive, (currentActive) => {
            if (!items.value[currentActive]) {
              activeIndex.value = "";
            }
            updateActiveIndex(currentActive);
          });
          watch(() => props.collapse, (value) => {
            if (value)
              openedMenus.value = [];
          });
          watch(items.value, initMenu);
          let resizeStopper;
          watchEffect(() => {
            if (props.mode === "horizontal" && props.ellipsis)
              resizeStopper = useResizeObserver(menu, handleResize).stop;
            else
              resizeStopper == null ? void 0 : resizeStopper();
          });
          const mouseInChild = ref(false);
          {
            const addSubMenu = (item) => {
              subMenus.value[item.index] = item;
            };
            const removeSubMenu = (item) => {
              delete subMenus.value[item.index];
            };
            const addMenuItem = (item) => {
              items.value[item.index] = item;
            };
            const removeMenuItem = (item) => {
              delete items.value[item.index];
            };
            provide("rootMenu", reactive({
              props,
              openedMenus,
              items,
              subMenus,
              activeIndex,
              isMenuPopup,
              addMenuItem,
              removeMenuItem,
              addSubMenu,
              removeSubMenu,
              openMenu,
              closeMenu,
              handleMenuItemClick,
              handleSubMenuClick
            }));
            provide(`subMenu:${instance.uid}`, {
              addSubMenu,
              removeSubMenu,
              mouseInChild,
              level: 0
            });
          }
          onMounted(() => {
            if (props.mode === "horizontal") {
              new Menu$1(instance.vnode.el, nsMenu.namespace.value);
            }
          });
          {
            const open = (index) => {
              const { indexPath } = subMenus.value[index];
              indexPath.forEach((i) => openMenu(i, indexPath));
            };
            expose({
              open,
              close,
              handleResize
            });
          }
          return () => {
            var _a, _b;
            let slot = (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : [];
            const vShowMore = [];
            if (props.mode === "horizontal" && menu.value) {
              const originalSlot = flattedChildren(slot);
              const slotDefault = sliceIndex.value === -1 ? originalSlot : originalSlot.slice(0, sliceIndex.value);
              const slotMore = sliceIndex.value === -1 ? [] : originalSlot.slice(sliceIndex.value);
              if ((slotMore == null ? void 0 : slotMore.length) && props.ellipsis) {
                slot = slotDefault;
                vShowMore.push(h(SubMenu2, {
                  index: "sub-menu-more",
                  class: nsSubMenu.e("hide-arrow"),
                  popperOffset: props.popperOffset
                }, {
                  title: () => h(ElIcon, {
                    class: nsSubMenu.e("icon-more")
                  }, {
                    default: () => h(props.ellipsisIcon)
                  }),
                  default: () => slotMore
                }));
              }
            }
            const ulStyle = useMenuCssVar(props, 0);
            const directives = props.closeOnClickOutside ? [
              [
                ClickOutside,
                () => {
                  if (!openedMenus.value.length)
                    return;
                  if (!mouseInChild.value) {
                    openedMenus.value.forEach((openedMenu) => emit("close", openedMenu, getIndexPath(openedMenu)));
                    openedMenus.value = [];
                  }
                }
              ]
            ] : [];
            const vMenu = withDirectives(h("ul", {
              key: String(props.collapse),
              role: "menubar",
              ref: menu,
              style: ulStyle.value,
              class: {
                [nsMenu.b()]: true,
                [nsMenu.m(props.mode)]: true,
                [nsMenu.m("collapse")]: props.collapse
              }
            }, [...slot, ...vShowMore]), directives);
            if (props.collapseTransition && props.mode === "vertical") {
              return h(ElMenuCollapseTransition, () => vMenu);
            }
            return vMenu;
          };
        }
      });
      const menuItemProps = buildProps({
        index: {
          type: definePropType([String, null]),
          default: null
        },
        route: {
          type: definePropType([String, Object])
        },
        disabled: Boolean
      });
      const menuItemEmits = {
        click: (item) => isString(item.index) && Array.isArray(item.indexPath)
      };
      const COMPONENT_NAME$4 = "ElMenuItem";
      const _sfc_main$v = defineComponent({
        name: COMPONENT_NAME$4,
        components: {
          ElTooltip
        },
        props: menuItemProps,
        emits: menuItemEmits,
        setup(props, { emit }) {
          const instance = getCurrentInstance();
          const rootMenu = inject("rootMenu");
          const nsMenu = useNamespace("menu");
          const nsMenuItem = useNamespace("menu-item");
          if (!rootMenu)
            throwError(COMPONENT_NAME$4, "can not inject root menu");
          const { parentMenu, indexPath } = useMenu(instance, toRef(props, "index"));
          const subMenu = inject(`subMenu:${parentMenu.value.uid}`);
          if (!subMenu)
            throwError(COMPONENT_NAME$4, "can not inject sub menu");
          const active = computed(() => props.index === rootMenu.activeIndex);
          const item = reactive({
            index: props.index,
            indexPath,
            active
          });
          const handleClick = () => {
            if (!props.disabled) {
              rootMenu.handleMenuItemClick({
                index: props.index,
                indexPath: indexPath.value,
                route: props.route
              });
              emit("click", item);
            }
          };
          onMounted(() => {
            subMenu.addSubMenu(item);
            rootMenu.addMenuItem(item);
          });
          onBeforeUnmount(() => {
            subMenu.removeSubMenu(item);
            rootMenu.removeMenuItem(item);
          });
          return {
            parentMenu,
            rootMenu,
            active,
            nsMenu,
            nsMenuItem,
            handleClick
          };
        }
      });
      function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_tooltip = resolveComponent("el-tooltip");
        return openBlock(), createElementBlock("li", {
          class: normalizeClass([
            _ctx.nsMenuItem.b(),
            _ctx.nsMenuItem.is("active", _ctx.active),
            _ctx.nsMenuItem.is("disabled", _ctx.disabled)
          ]),
          role: "menuitem",
          tabindex: "-1",
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
        }, [
          _ctx.parentMenu.type.name === "ElMenu" && _ctx.rootMenu.props.collapse && _ctx.$slots.title ? (openBlock(), createBlock(_component_el_tooltip, {
            key: 0,
            effect: _ctx.rootMenu.props.popperEffect,
            placement: "right",
            "fallback-placements": ["left"],
            persistent: ""
          }, {
            content: withCtx(() => [
              renderSlot(_ctx.$slots, "title")
            ]),
            default: withCtx(() => [
              createElementVNode("div", {
                class: normalizeClass(_ctx.nsMenu.be("tooltip", "trigger"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2)
            ]),
            _: 3
          }, 8, ["effect"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            renderSlot(_ctx.$slots, "default"),
            renderSlot(_ctx.$slots, "title")
          ], 64))
        ], 2);
      }
      var MenuItem2 = /* @__PURE__ */ _export_sfc$1(_sfc_main$v, [["render", _sfc_render$9], ["__file", "menu-item.vue"]]);
      const menuItemGroupProps = {
        title: String
      };
      const COMPONENT_NAME$3 = "ElMenuItemGroup";
      const _sfc_main$u = defineComponent({
        name: COMPONENT_NAME$3,
        props: menuItemGroupProps,
        setup() {
          const ns = useNamespace("menu-item-group");
          return {
            ns
          };
        }
      });
      function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("li", {
          class: normalizeClass(_ctx.ns.b())
        }, [
          createElementVNode("div", {
            class: normalizeClass(_ctx.ns.e("title"))
          }, [
            !_ctx.$slots.title ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(toDisplayString(_ctx.title), 1)
            ], 64)) : renderSlot(_ctx.$slots, "title", { key: 1 })
          ], 2),
          createElementVNode("ul", null, [
            renderSlot(_ctx.$slots, "default")
          ])
        ], 2);
      }
      var MenuItemGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$u, [["render", _sfc_render$8], ["__file", "menu-item-group.vue"]]);
      const ElMenu = withInstall(Menu2, {
        MenuItem: MenuItem2,
        MenuItemGroup,
        SubMenu: SubMenu2
      });
      const ElMenuItem = withNoopInstall(MenuItem2);
      withNoopInstall(MenuItemGroup);
      withNoopInstall(SubMenu2);
      const elPaginationKey = Symbol("elPaginationKey");
      const paginationPrevProps = buildProps({
        disabled: Boolean,
        currentPage: {
          type: Number,
          default: 1
        },
        prevText: {
          type: String
        },
        prevIcon: {
          type: iconPropType
        }
      });
      const paginationPrevEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      const _hoisted_1$m = ["disabled", "aria-label", "aria-disabled"];
      const _hoisted_2$h = { key: 0 };
      const __default__$c = defineComponent({
        name: "ElPaginationPrev"
      });
      const _sfc_main$t = /* @__PURE__ */ defineComponent({
        ...__default__$c,
        props: paginationPrevProps,
        emits: paginationPrevEmits,
        setup(__props) {
          const props = __props;
          const { t } = useLocale();
          const internalDisabled = computed(() => props.disabled || props.currentPage <= 1);
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("button", {
              type: "button",
              class: "btn-prev",
              disabled: unref(internalDisabled),
              "aria-label": _ctx.prevText || unref(t)("el.pagination.prev"),
              "aria-disabled": unref(internalDisabled),
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
            }, [
              _ctx.prevText ? (openBlock(), createElementBlock("span", _hoisted_2$h, toDisplayString(_ctx.prevText), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.prevIcon)))
                ]),
                _: 1
              }))
            ], 8, _hoisted_1$m);
          };
        }
      });
      var Prev = /* @__PURE__ */ _export_sfc$1(_sfc_main$t, [["__file", "prev.vue"]]);
      const paginationNextProps = buildProps({
        disabled: Boolean,
        currentPage: {
          type: Number,
          default: 1
        },
        pageCount: {
          type: Number,
          default: 50
        },
        nextText: {
          type: String
        },
        nextIcon: {
          type: iconPropType
        }
      });
      const _hoisted_1$l = ["disabled", "aria-label", "aria-disabled"];
      const _hoisted_2$g = { key: 0 };
      const __default__$b = defineComponent({
        name: "ElPaginationNext"
      });
      const _sfc_main$s = /* @__PURE__ */ defineComponent({
        ...__default__$b,
        props: paginationNextProps,
        emits: ["click"],
        setup(__props) {
          const props = __props;
          const { t } = useLocale();
          const internalDisabled = computed(() => props.disabled || props.currentPage === props.pageCount || props.pageCount === 0);
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("button", {
              type: "button",
              class: "btn-next",
              disabled: unref(internalDisabled),
              "aria-label": _ctx.nextText || unref(t)("el.pagination.next"),
              "aria-disabled": unref(internalDisabled),
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
            }, [
              _ctx.nextText ? (openBlock(), createElementBlock("span", _hoisted_2$g, toDisplayString(_ctx.nextText), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.nextIcon)))
                ]),
                _: 1
              }))
            ], 8, _hoisted_1$l);
          };
        }
      });
      var Next = /* @__PURE__ */ _export_sfc$1(_sfc_main$s, [["__file", "next.vue"]]);
      const selectGroupKey = Symbol("ElSelectGroup");
      const selectKey = Symbol("ElSelect");
      function useOption(props, states) {
        const select = inject(selectKey);
        const selectGroup = inject(selectGroupKey, { disabled: false });
        const itemSelected = computed(() => {
          if (select.props.multiple) {
            return contains(select.props.modelValue, props.value);
          } else {
            return contains([select.props.modelValue], props.value);
          }
        });
        const limitReached = computed(() => {
          if (select.props.multiple) {
            const modelValue = select.props.modelValue || [];
            return !itemSelected.value && modelValue.length >= select.props.multipleLimit && select.props.multipleLimit > 0;
          } else {
            return false;
          }
        });
        const currentLabel = computed(() => {
          return props.label || (isObject$1(props.value) ? "" : props.value);
        });
        const currentValue = computed(() => {
          return props.value || props.label || "";
        });
        const isDisabled = computed(() => {
          return props.disabled || states.groupDisabled || limitReached.value;
        });
        const instance = getCurrentInstance();
        const contains = (arr = [], target) => {
          if (!isObject$1(props.value)) {
            return arr && arr.includes(target);
          } else {
            const valueKey = select.props.valueKey;
            return arr && arr.some((item) => {
              return toRaw(get(item, valueKey)) === get(target, valueKey);
            });
          }
        };
        const hoverItem = () => {
          if (!props.disabled && !selectGroup.disabled) {
            select.states.hoveringIndex = select.optionsArray.indexOf(instance.proxy);
          }
        };
        const updateOption = (query) => {
          const regexp4 = new RegExp(escapeStringRegexp(query), "i");
          states.visible = regexp4.test(currentLabel.value) || props.created;
        };
        watch(() => currentLabel.value, () => {
          if (!props.created && !select.props.remote)
            select.setSelected();
        });
        watch(() => props.value, (val, oldVal) => {
          const { remote, valueKey } = select.props;
          if (!isEqual(val, oldVal)) {
            select.onOptionDestroy(oldVal, instance.proxy);
            select.onOptionCreate(instance.proxy);
          }
          if (!props.created && !remote) {
            if (valueKey && isObject$1(val) && isObject$1(oldVal) && val[valueKey] === oldVal[valueKey]) {
              return;
            }
            select.setSelected();
          }
        });
        watch(() => selectGroup.disabled, () => {
          states.groupDisabled = selectGroup.disabled;
        }, { immediate: true });
        return {
          select,
          currentLabel,
          currentValue,
          itemSelected,
          isDisabled,
          hoverItem,
          updateOption
        };
      }
      const _sfc_main$r = defineComponent({
        name: "ElOption",
        componentName: "ElOption",
        props: {
          value: {
            required: true,
            type: [String, Number, Boolean, Object]
          },
          label: [String, Number],
          created: Boolean,
          disabled: Boolean
        },
        setup(props) {
          const ns = useNamespace("select");
          const id = useId();
          const containerKls = computed(() => [
            ns.be("dropdown", "item"),
            ns.is("disabled", unref(isDisabled)),
            ns.is("selected", unref(itemSelected)),
            ns.is("hovering", unref(hover))
          ]);
          const states = reactive({
            index: -1,
            groupDisabled: false,
            visible: true,
            hover: false
          });
          const {
            currentLabel,
            itemSelected,
            isDisabled,
            select,
            hoverItem,
            updateOption
          } = useOption(props, states);
          const { visible, hover } = toRefs(states);
          const vm = getCurrentInstance().proxy;
          select.onOptionCreate(vm);
          onBeforeUnmount(() => {
            const key = vm.value;
            const { selected } = select.states;
            const selectedOptions = select.props.multiple ? selected : [selected];
            const doesSelected = selectedOptions.some((item) => {
              return item.value === vm.value;
            });
            nextTick(() => {
              if (select.states.cachedOptions.get(key) === vm && !doesSelected) {
                select.states.cachedOptions.delete(key);
              }
            });
            select.onOptionDestroy(key, vm);
          });
          function selectOptionClick() {
            if (props.disabled !== true && states.groupDisabled !== true) {
              select.handleOptionSelect(vm);
            }
          }
          return {
            ns,
            id,
            containerKls,
            currentLabel,
            itemSelected,
            isDisabled,
            select,
            hoverItem,
            updateOption,
            visible,
            hover,
            selectOptionClick,
            states
          };
        }
      });
      const _hoisted_1$k = ["id", "aria-disabled", "aria-selected"];
      function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
        return withDirectives((openBlock(), createElementBlock("li", {
          id: _ctx.id,
          class: normalizeClass(_ctx.containerKls),
          role: "option",
          "aria-disabled": _ctx.isDisabled || void 0,
          "aria-selected": _ctx.itemSelected,
          onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
          onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createElementVNode("span", null, toDisplayString(_ctx.currentLabel), 1)
          ])
        ], 42, _hoisted_1$k)), [
          [vShow, _ctx.visible]
        ]);
      }
      var Option = /* @__PURE__ */ _export_sfc$1(_sfc_main$r, [["render", _sfc_render$7], ["__file", "option.vue"]]);
      const _sfc_main$q = defineComponent({
        name: "ElSelectDropdown",
        componentName: "ElSelectDropdown",
        setup() {
          const select = inject(selectKey);
          const ns = useNamespace("select");
          const popperClass = computed(() => select.props.popperClass);
          const isMultiple = computed(() => select.props.multiple);
          const isFitInputWidth = computed(() => select.props.fitInputWidth);
          const minWidth = ref("");
          function updateMinWidth() {
            var _a;
            minWidth.value = `${(_a = select.selectRef) == null ? void 0 : _a.offsetWidth}px`;
          }
          onMounted(() => {
            updateMinWidth();
            useResizeObserver(select.selectRef, updateMinWidth);
          });
          return {
            ns,
            minWidth,
            popperClass,
            isMultiple,
            isFitInputWidth
          };
        }
      });
      function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass([_ctx.ns.b("dropdown"), _ctx.ns.is("multiple", _ctx.isMultiple), _ctx.popperClass]),
          style: normalizeStyle({ [_ctx.isFitInputWidth ? "width" : "minWidth"]: _ctx.minWidth })
        }, [
          _ctx.$slots.header ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.ns.be("dropdown", "header"))
          }, [
            renderSlot(_ctx.$slots, "header")
          ], 2)) : createCommentVNode("v-if", true),
          renderSlot(_ctx.$slots, "default"),
          _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(_ctx.ns.be("dropdown", "footer"))
          }, [
            renderSlot(_ctx.$slots, "footer")
          ], 2)) : createCommentVNode("v-if", true)
        ], 6);
      }
      var ElSelectMenu = /* @__PURE__ */ _export_sfc$1(_sfc_main$q, [["render", _sfc_render$6], ["__file", "select-dropdown.vue"]]);
      function useInput(handleInput) {
        const isComposing = ref(false);
        const handleCompositionStart = () => {
          isComposing.value = true;
        };
        const handleCompositionUpdate = (event) => {
          const text = event.target.value;
          const lastCharacter = text[text.length - 1] || "";
          isComposing.value = !isKorean(lastCharacter);
        };
        const handleCompositionEnd = (event) => {
          if (isComposing.value) {
            isComposing.value = false;
            if (isFunction$1(handleInput)) {
              handleInput(event);
            }
          }
        };
        return {
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        };
      }
      const MINIMUM_INPUT_WIDTH = 11;
      const useSelect = (props, emit) => {
        const { t } = useLocale();
        const contentId = useId();
        const nsSelect = useNamespace("select");
        const nsInput = useNamespace("input");
        const states = reactive({
          inputValue: "",
          options: /* @__PURE__ */ new Map(),
          cachedOptions: /* @__PURE__ */ new Map(),
          disabledOptions: /* @__PURE__ */ new Map(),
          optionValues: [],
          selected: props.multiple ? [] : {},
          selectionWidth: 0,
          calculatorWidth: 0,
          collapseItemWidth: 0,
          selectedLabel: "",
          hoveringIndex: -1,
          previousQuery: null,
          inputHovering: false,
          menuVisibleOnFocus: false,
          isBeforeHide: false
        });
        const selectRef = ref(null);
        const selectionRef = ref(null);
        const tooltipRef = ref(null);
        const tagTooltipRef = ref(null);
        const inputRef = ref(null);
        const calculatorRef = ref(null);
        const prefixRef = ref(null);
        const suffixRef = ref(null);
        const menuRef = ref(null);
        const tagMenuRef = ref(null);
        const collapseItemRef = ref(null);
        const scrollbarRef = ref(null);
        const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(inputRef, {
          afterFocus() {
            if (props.automaticDropdown && !expanded.value) {
              expanded.value = true;
              states.menuVisibleOnFocus = true;
            }
          },
          beforeBlur(event) {
            var _a, _b;
            return ((_a = tooltipRef.value) == null ? void 0 : _a.isFocusInsideContent(event)) || ((_b = tagTooltipRef.value) == null ? void 0 : _b.isFocusInsideContent(event));
          },
          afterBlur() {
            expanded.value = false;
            states.menuVisibleOnFocus = false;
          }
        });
        const expanded = ref(false);
        const hoverOption = ref();
        const { form, formItem } = useFormItem();
        const { inputId } = useFormItemInputId(props, {
          formItemContext: formItem
        });
        const { valueOnClear, isEmptyValue: isEmptyValue2 } = useEmptyValues(props);
        const selectDisabled = computed(() => props.disabled || (form == null ? void 0 : form.disabled));
        const hasModelValue = computed(() => {
          return props.multiple ? isArray$1(props.modelValue) && props.modelValue.length > 0 : !isEmptyValue2(props.modelValue);
        });
        const showClose = computed(() => {
          return props.clearable && !selectDisabled.value && states.inputHovering && hasModelValue.value;
        });
        const iconComponent = computed(() => props.remote && props.filterable && !props.remoteShowSuffix ? "" : props.suffixIcon);
        const iconReverse = computed(() => nsSelect.is("reverse", iconComponent.value && expanded.value));
        const validateState = computed(() => (formItem == null ? void 0 : formItem.validateState) || "");
        const validateIcon = computed(() => ValidateComponentsMap[validateState.value]);
        const debounce$1 = computed(() => props.remote ? 300 : 0);
        const emptyText = computed(() => {
          if (props.loading) {
            return props.loadingText || t("el.select.loading");
          } else {
            if (props.remote && !states.inputValue && states.options.size === 0)
              return false;
            if (props.filterable && states.inputValue && states.options.size > 0 && filteredOptionsCount.value === 0) {
              return props.noMatchText || t("el.select.noMatch");
            }
            if (states.options.size === 0) {
              return props.noDataText || t("el.select.noData");
            }
          }
          return null;
        });
        const filteredOptionsCount = computed(() => optionsArray.value.filter((option) => option.visible).length);
        const optionsArray = computed(() => {
          const list = Array.from(states.options.values());
          const newList = [];
          states.optionValues.forEach((item) => {
            const index = list.findIndex((i) => i.value === item);
            if (index > -1) {
              newList.push(list[index]);
            }
          });
          return newList.length >= list.length ? newList : list;
        });
        const cachedOptionsArray = computed(() => Array.from(states.cachedOptions.values()));
        const showNewOption = computed(() => {
          const hasExistingOption = optionsArray.value.filter((option) => {
            return !option.created;
          }).some((option) => {
            return option.currentLabel === states.inputValue;
          });
          return props.filterable && props.allowCreate && states.inputValue !== "" && !hasExistingOption;
        });
        const updateOptions2 = () => {
          if (props.filterable && isFunction$1(props.filterMethod))
            return;
          if (props.filterable && props.remote && isFunction$1(props.remoteMethod))
            return;
          optionsArray.value.forEach((option) => {
            var _a;
            (_a = option.updateOption) == null ? void 0 : _a.call(option, states.inputValue);
          });
        };
        const selectSize = useFormSize();
        const collapseTagSize = computed(() => ["small"].includes(selectSize.value) ? "small" : "default");
        const dropdownMenuVisible = computed({
          get() {
            return expanded.value && emptyText.value !== false;
          },
          set(val) {
            expanded.value = val;
          }
        });
        const shouldShowPlaceholder = computed(() => {
          if (isArray$1(props.modelValue)) {
            return props.modelValue.length === 0 && !states.inputValue;
          }
          return props.filterable ? !states.inputValue : true;
        });
        const currentPlaceholder = computed(() => {
          var _a;
          const _placeholder = (_a = props.placeholder) != null ? _a : t("el.select.placeholder");
          return props.multiple || !hasModelValue.value ? _placeholder : states.selectedLabel;
        });
        watch(() => props.modelValue, (val, oldVal) => {
          if (props.multiple) {
            if (props.filterable && !props.reserveKeyword) {
              states.inputValue = "";
              handleQueryChange("");
            }
          }
          setSelected();
          if (!isEqual(val, oldVal) && props.validateEvent) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
        }, {
          flush: "post",
          deep: true
        });
        watch(() => expanded.value, (val) => {
          if (val) {
            handleQueryChange(states.inputValue);
          } else {
            states.inputValue = "";
            states.previousQuery = null;
            states.isBeforeHide = true;
          }
          emit("visible-change", val);
        });
        watch(() => states.options.entries(), () => {
          var _a;
          if (!isClient)
            return;
          const inputs = ((_a = selectRef.value) == null ? void 0 : _a.querySelectorAll("input")) || [];
          if (!props.filterable && !props.defaultFirstOption && !isUndefined(props.modelValue) || !Array.from(inputs).includes(document.activeElement)) {
            setSelected();
          }
          if (props.defaultFirstOption && (props.filterable || props.remote) && filteredOptionsCount.value) {
            checkDefaultFirstOption();
          }
        }, {
          flush: "post"
        });
        watch(() => states.hoveringIndex, (val) => {
          if (isNumber(val) && val > -1) {
            hoverOption.value = optionsArray.value[val] || {};
          } else {
            hoverOption.value = {};
          }
          optionsArray.value.forEach((option) => {
            option.hover = hoverOption.value === option;
          });
        });
        watchEffect(() => {
          if (states.isBeforeHide)
            return;
          updateOptions2();
        });
        const handleQueryChange = (val) => {
          if (states.previousQuery === val) {
            return;
          }
          states.previousQuery = val;
          if (props.filterable && isFunction$1(props.filterMethod)) {
            props.filterMethod(val);
          } else if (props.filterable && props.remote && isFunction$1(props.remoteMethod)) {
            props.remoteMethod(val);
          }
          if (props.defaultFirstOption && (props.filterable || props.remote) && filteredOptionsCount.value) {
            nextTick(checkDefaultFirstOption);
          } else {
            nextTick(updateHoveringIndex);
          }
        };
        const checkDefaultFirstOption = () => {
          const optionsInDropdown = optionsArray.value.filter((n) => n.visible && !n.disabled && !n.states.groupDisabled);
          const userCreatedOption = optionsInDropdown.find((n) => n.created);
          const firstOriginOption = optionsInDropdown[0];
          states.hoveringIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);
        };
        const setSelected = () => {
          if (!props.multiple) {
            const option = getOption(props.modelValue);
            states.selectedLabel = option.currentLabel;
            states.selected = option;
            return;
          } else {
            states.selectedLabel = "";
          }
          const result = [];
          if (isArray$1(props.modelValue)) {
            props.modelValue.forEach((value) => {
              result.push(getOption(value));
            });
          }
          states.selected = result;
        };
        const getOption = (value) => {
          let option;
          const isObjectValue = toRawType(value).toLowerCase() === "object";
          const isNull = toRawType(value).toLowerCase() === "null";
          const isUndefined2 = toRawType(value).toLowerCase() === "undefined";
          for (let i = states.cachedOptions.size - 1; i >= 0; i--) {
            const cachedOption = cachedOptionsArray.value[i];
            const isEqualValue = isObjectValue ? get(cachedOption.value, props.valueKey) === get(value, props.valueKey) : cachedOption.value === value;
            if (isEqualValue) {
              option = {
                value,
                currentLabel: cachedOption.currentLabel,
                isDisabled: cachedOption.isDisabled
              };
              break;
            }
          }
          if (option)
            return option;
          const label = isObjectValue ? value.label : !isNull && !isUndefined2 ? value : "";
          const newOption = {
            value,
            currentLabel: label
          };
          return newOption;
        };
        const updateHoveringIndex = () => {
          if (!props.multiple) {
            states.hoveringIndex = optionsArray.value.findIndex((item) => {
              return getValueKey(item) === getValueKey(states.selected);
            });
          } else {
            states.hoveringIndex = optionsArray.value.findIndex((item) => states.selected.some((selected) => getValueKey(selected) === getValueKey(item)));
          }
        };
        const resetSelectionWidth = () => {
          states.selectionWidth = selectionRef.value.getBoundingClientRect().width;
        };
        const resetCalculatorWidth = () => {
          states.calculatorWidth = calculatorRef.value.getBoundingClientRect().width;
        };
        const resetCollapseItemWidth = () => {
          states.collapseItemWidth = collapseItemRef.value.getBoundingClientRect().width;
        };
        const updateTooltip = () => {
          var _a, _b;
          (_b = (_a = tooltipRef.value) == null ? void 0 : _a.updatePopper) == null ? void 0 : _b.call(_a);
        };
        const updateTagTooltip = () => {
          var _a, _b;
          (_b = (_a = tagTooltipRef.value) == null ? void 0 : _a.updatePopper) == null ? void 0 : _b.call(_a);
        };
        const onInputChange = () => {
          if (states.inputValue.length > 0 && !expanded.value) {
            expanded.value = true;
          }
          handleQueryChange(states.inputValue);
        };
        const onInput = (event) => {
          states.inputValue = event.target.value;
          if (props.remote) {
            debouncedOnInputChange();
          } else {
            return onInputChange();
          }
        };
        const debouncedOnInputChange = debounce(() => {
          onInputChange();
        }, debounce$1.value);
        const emitChange = (val) => {
          if (!isEqual(props.modelValue, val)) {
            emit(CHANGE_EVENT, val);
          }
        };
        const getLastNotDisabledIndex = (value) => findLastIndex(value, (it) => !states.disabledOptions.has(it));
        const deletePrevTag = (e) => {
          if (!props.multiple)
            return;
          if (e.code === EVENT_CODE.delete)
            return;
          if (e.target.value.length <= 0) {
            const value = props.modelValue.slice();
            const lastNotDisabledIndex = getLastNotDisabledIndex(value);
            if (lastNotDisabledIndex < 0)
              return;
            value.splice(lastNotDisabledIndex, 1);
            emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
          }
        };
        const deleteTag = (event, tag) => {
          const index = states.selected.indexOf(tag);
          if (index > -1 && !selectDisabled.value) {
            const value = props.modelValue.slice();
            value.splice(index, 1);
            emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
            emit("remove-tag", tag.value);
          }
          event.stopPropagation();
          focus();
        };
        const deleteSelected = (event) => {
          event.stopPropagation();
          const value = props.multiple ? [] : valueOnClear.value;
          if (props.multiple) {
            for (const item of states.selected) {
              if (item.isDisabled)
                value.push(item.value);
            }
          }
          emit(UPDATE_MODEL_EVENT, value);
          emitChange(value);
          states.hoveringIndex = -1;
          expanded.value = false;
          emit("clear");
          focus();
        };
        const handleOptionSelect = (option) => {
          if (props.multiple) {
            const value = (props.modelValue || []).slice();
            const optionIndex = getValueIndex(value, option.value);
            if (optionIndex > -1) {
              value.splice(optionIndex, 1);
            } else if (props.multipleLimit <= 0 || value.length < props.multipleLimit) {
              value.push(option.value);
            }
            emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
            if (option.created) {
              handleQueryChange("");
            }
            if (props.filterable && !props.reserveKeyword) {
              states.inputValue = "";
            }
          } else {
            emit(UPDATE_MODEL_EVENT, option.value);
            emitChange(option.value);
            expanded.value = false;
          }
          focus();
          if (expanded.value)
            return;
          nextTick(() => {
            scrollToOption(option);
          });
        };
        const getValueIndex = (arr = [], value) => {
          if (!isObject$1(value))
            return arr.indexOf(value);
          const valueKey = props.valueKey;
          let index = -1;
          arr.some((item, i) => {
            if (toRaw(get(item, valueKey)) === get(value, valueKey)) {
              index = i;
              return true;
            }
            return false;
          });
          return index;
        };
        const scrollToOption = (option) => {
          var _a, _b, _c, _d, _e;
          const targetOption = isArray$1(option) ? option[0] : option;
          let target = null;
          if (targetOption == null ? void 0 : targetOption.value) {
            const options = optionsArray.value.filter((item) => item.value === targetOption.value);
            if (options.length > 0) {
              target = options[0].$el;
            }
          }
          if (tooltipRef.value && target) {
            const menu = (_d = (_c = (_b = (_a = tooltipRef.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef) == null ? void 0 : _c.querySelector) == null ? void 0 : _d.call(_c, `.${nsSelect.be("dropdown", "wrap")}`);
            if (menu) {
              scrollIntoView(menu, target);
            }
          }
          (_e = scrollbarRef.value) == null ? void 0 : _e.handleScroll();
        };
        const onOptionCreate = (vm) => {
          states.options.set(vm.value, vm);
          states.cachedOptions.set(vm.value, vm);
          vm.disabled && states.disabledOptions.set(vm.value, vm);
        };
        const onOptionDestroy = (key, vm) => {
          if (states.options.get(key) === vm) {
            states.options.delete(key);
          }
        };
        const {
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        } = useInput((e) => onInput(e));
        const popperRef = computed(() => {
          var _a, _b;
          return (_b = (_a = tooltipRef.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef;
        });
        const handleMenuEnter = () => {
          states.isBeforeHide = false;
          nextTick(() => scrollToOption(states.selected));
        };
        const focus = () => {
          var _a;
          (_a = inputRef.value) == null ? void 0 : _a.focus();
        };
        const blur = () => {
          handleClickOutside();
        };
        const handleClearClick = (event) => {
          deleteSelected(event);
        };
        const handleClickOutside = (event) => {
          expanded.value = false;
          if (isFocused.value) {
            const _event = new FocusEvent("focus", event);
            nextTick(() => handleBlur(_event));
          }
        };
        const handleEsc = () => {
          if (states.inputValue.length > 0) {
            states.inputValue = "";
          } else {
            expanded.value = false;
          }
        };
        const toggleMenu = () => {
          if (selectDisabled.value)
            return;
          if (states.menuVisibleOnFocus) {
            states.menuVisibleOnFocus = false;
          } else {
            expanded.value = !expanded.value;
          }
        };
        const selectOption = () => {
          if (!expanded.value) {
            toggleMenu();
          } else {
            if (optionsArray.value[states.hoveringIndex]) {
              handleOptionSelect(optionsArray.value[states.hoveringIndex]);
            }
          }
        };
        const getValueKey = (item) => {
          return isObject$1(item.value) ? get(item.value, props.valueKey) : item.value;
        };
        const optionsAllDisabled = computed(() => optionsArray.value.filter((option) => option.visible).every((option) => option.disabled));
        const showTagList = computed(() => {
          if (!props.multiple) {
            return [];
          }
          return props.collapseTags ? states.selected.slice(0, props.maxCollapseTags) : states.selected;
        });
        const collapseTagList = computed(() => {
          if (!props.multiple) {
            return [];
          }
          return props.collapseTags ? states.selected.slice(props.maxCollapseTags) : [];
        });
        const navigateOptions = (direction) => {
          if (!expanded.value) {
            expanded.value = true;
            return;
          }
          if (states.options.size === 0 || filteredOptionsCount.value === 0)
            return;
          if (!optionsAllDisabled.value) {
            if (direction === "next") {
              states.hoveringIndex++;
              if (states.hoveringIndex === states.options.size) {
                states.hoveringIndex = 0;
              }
            } else if (direction === "prev") {
              states.hoveringIndex--;
              if (states.hoveringIndex < 0) {
                states.hoveringIndex = states.options.size - 1;
              }
            }
            const option = optionsArray.value[states.hoveringIndex];
            if (option.disabled === true || option.states.groupDisabled === true || !option.visible) {
              navigateOptions(direction);
            }
            nextTick(() => scrollToOption(hoverOption.value));
          }
        };
        const getGapWidth = () => {
          if (!selectionRef.value)
            return 0;
          const style = window.getComputedStyle(selectionRef.value);
          return Number.parseFloat(style.gap || "6px");
        };
        const tagStyle = computed(() => {
          const gapWidth = getGapWidth();
          const maxWidth = collapseItemRef.value && props.maxCollapseTags === 1 ? states.selectionWidth - states.collapseItemWidth - gapWidth : states.selectionWidth;
          return { maxWidth: `${maxWidth}px` };
        });
        const collapseTagStyle = computed(() => {
          return { maxWidth: `${states.selectionWidth}px` };
        });
        const inputStyle = computed(() => ({
          width: `${Math.max(states.calculatorWidth, MINIMUM_INPUT_WIDTH)}px`
        }));
        if (props.multiple && !isArray$1(props.modelValue)) {
          emit(UPDATE_MODEL_EVENT, []);
        }
        if (!props.multiple && isArray$1(props.modelValue)) {
          emit(UPDATE_MODEL_EVENT, "");
        }
        useResizeObserver(selectionRef, resetSelectionWidth);
        useResizeObserver(calculatorRef, resetCalculatorWidth);
        useResizeObserver(menuRef, updateTooltip);
        useResizeObserver(wrapperRef, updateTooltip);
        useResizeObserver(tagMenuRef, updateTagTooltip);
        useResizeObserver(collapseItemRef, resetCollapseItemWidth);
        onMounted(() => {
          setSelected();
        });
        return {
          inputId,
          contentId,
          nsSelect,
          nsInput,
          states,
          isFocused,
          expanded,
          optionsArray,
          hoverOption,
          selectSize,
          filteredOptionsCount,
          resetCalculatorWidth,
          updateTooltip,
          updateTagTooltip,
          debouncedOnInputChange,
          onInput,
          deletePrevTag,
          deleteTag,
          deleteSelected,
          handleOptionSelect,
          scrollToOption,
          hasModelValue,
          shouldShowPlaceholder,
          currentPlaceholder,
          showClose,
          iconComponent,
          iconReverse,
          validateState,
          validateIcon,
          showNewOption,
          updateOptions: updateOptions2,
          collapseTagSize,
          setSelected,
          selectDisabled,
          emptyText,
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd,
          onOptionCreate,
          onOptionDestroy,
          handleMenuEnter,
          handleFocus,
          focus,
          blur,
          handleBlur,
          handleClearClick,
          handleClickOutside,
          handleEsc,
          toggleMenu,
          selectOption,
          getValueKey,
          navigateOptions,
          dropdownMenuVisible,
          showTagList,
          collapseTagList,
          tagStyle,
          collapseTagStyle,
          inputStyle,
          popperRef,
          inputRef,
          tooltipRef,
          tagTooltipRef,
          calculatorRef,
          prefixRef,
          suffixRef,
          selectRef,
          wrapperRef,
          selectionRef,
          scrollbarRef,
          menuRef,
          tagMenuRef,
          collapseItemRef
        };
      };
      var ElOptions = defineComponent({
        name: "ElOptions",
        setup(_, { slots }) {
          const select = inject(selectKey);
          let cachedValueList = [];
          return () => {
            var _a, _b;
            const children = (_a = slots.default) == null ? void 0 : _a.call(slots);
            const valueList = [];
            function filterOptions(children2) {
              if (!isArray$1(children2))
                return;
              children2.forEach((item) => {
                var _a2, _b2, _c, _d;
                const name = (_a2 = (item == null ? void 0 : item.type) || {}) == null ? void 0 : _a2.name;
                if (name === "ElOptionGroup") {
                  filterOptions(!isString(item.children) && !isArray$1(item.children) && isFunction$1((_b2 = item.children) == null ? void 0 : _b2.default) ? (_c = item.children) == null ? void 0 : _c.default() : item.children);
                } else if (name === "ElOption") {
                  valueList.push((_d = item.props) == null ? void 0 : _d.value);
                } else if (isArray$1(item.children)) {
                  filterOptions(item.children);
                }
              });
            }
            if (children.length) {
              filterOptions((_b = children[0]) == null ? void 0 : _b.children);
            }
            if (!isEqual(valueList, cachedValueList)) {
              cachedValueList = valueList;
              if (select) {
                select.states.optionValues = valueList;
              }
            }
            return children;
          };
        }
      });
      const SelectProps = buildProps({
        name: String,
        id: String,
        modelValue: {
          type: [Array, String, Number, Boolean, Object],
          default: void 0
        },
        autocomplete: {
          type: String,
          default: "off"
        },
        automaticDropdown: Boolean,
        size: useSizeProp,
        effect: {
          type: definePropType(String),
          default: "light"
        },
        disabled: Boolean,
        clearable: Boolean,
        filterable: Boolean,
        allowCreate: Boolean,
        loading: Boolean,
        popperClass: {
          type: String,
          default: ""
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        remote: Boolean,
        loadingText: String,
        noMatchText: String,
        noDataText: String,
        remoteMethod: Function,
        filterMethod: Function,
        multiple: Boolean,
        multipleLimit: {
          type: Number,
          default: 0
        },
        placeholder: {
          type: String
        },
        defaultFirstOption: Boolean,
        reserveKeyword: {
          type: Boolean,
          default: true
        },
        valueKey: {
          type: String,
          default: "value"
        },
        collapseTags: Boolean,
        collapseTagsTooltip: Boolean,
        maxCollapseTags: {
          type: Number,
          default: 1
        },
        teleported: useTooltipContentProps.teleported,
        persistent: {
          type: Boolean,
          default: true
        },
        clearIcon: {
          type: iconPropType,
          default: circle_close_default
        },
        fitInputWidth: Boolean,
        suffixIcon: {
          type: iconPropType,
          default: arrow_down_default
        },
        tagType: { ...tagProps.type, default: "info" },
        validateEvent: {
          type: Boolean,
          default: true
        },
        remoteShowSuffix: Boolean,
        placement: {
          type: definePropType(String),
          values: Ee,
          default: "bottom-start"
        },
        fallbackPlacements: {
          type: definePropType(Array),
          default: ["bottom-start", "top-start", "right", "left"]
        },
        ariaLabel: {
          type: String,
          default: void 0
        },
        ...useEmptyValuesProps
      });
      const COMPONENT_NAME$2 = "ElSelect";
      const _sfc_main$p = defineComponent({
        name: COMPONENT_NAME$2,
        componentName: COMPONENT_NAME$2,
        components: {
          ElInput,
          ElSelectMenu,
          ElOption: Option,
          ElOptions,
          ElTag,
          ElScrollbar,
          ElTooltip,
          ElIcon
        },
        directives: { ClickOutside },
        props: SelectProps,
        emits: [
          UPDATE_MODEL_EVENT,
          CHANGE_EVENT,
          "remove-tag",
          "clear",
          "visible-change",
          "focus",
          "blur"
        ],
        setup(props, { emit }) {
          const API = useSelect(props, emit);
          provide(selectKey, reactive({
            props,
            states: API.states,
            optionsArray: API.optionsArray,
            handleOptionSelect: API.handleOptionSelect,
            onOptionCreate: API.onOptionCreate,
            onOptionDestroy: API.onOptionDestroy,
            selectRef: API.selectRef,
            setSelected: API.setSelected
          }));
          return {
            ...API
          };
        }
      });
      const _hoisted_1$j = ["id", "disabled", "autocomplete", "readonly", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label"];
      const _hoisted_2$f = ["textContent"];
      function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_tag = resolveComponent("el-tag");
        const _component_el_tooltip = resolveComponent("el-tooltip");
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_option = resolveComponent("el-option");
        const _component_el_options = resolveComponent("el-options");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _component_el_select_menu = resolveComponent("el-select-menu");
        const _directive_click_outside = resolveDirective("click-outside");
        return withDirectives((openBlock(), createElementBlock("div", {
          ref: "selectRef",
          class: normalizeClass([_ctx.nsSelect.b(), _ctx.nsSelect.m(_ctx.selectSize)]),
          onMouseenter: _cache[16] || (_cache[16] = ($event) => _ctx.states.inputHovering = true),
          onMouseleave: _cache[17] || (_cache[17] = ($event) => _ctx.states.inputHovering = false),
          onClick: _cache[18] || (_cache[18] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["prevent", "stop"]))
        }, [
          createVNode(_component_el_tooltip, {
            ref: "tooltipRef",
            visible: _ctx.dropdownMenuVisible,
            placement: _ctx.placement,
            teleported: _ctx.teleported,
            "popper-class": [_ctx.nsSelect.e("popper"), _ctx.popperClass],
            "popper-options": _ctx.popperOptions,
            "fallback-placements": _ctx.fallbackPlacements,
            effect: _ctx.effect,
            pure: "",
            trigger: "click",
            transition: `${_ctx.nsSelect.namespace.value}-zoom-in-top`,
            "stop-popper-mouse-event": false,
            "gpu-acceleration": false,
            persistent: _ctx.persistent,
            onBeforeShow: _ctx.handleMenuEnter,
            onHide: _cache[15] || (_cache[15] = ($event) => _ctx.states.isBeforeHide = false)
          }, {
            default: withCtx(() => {
              var _a;
              return [
                createElementVNode("div", {
                  ref: "wrapperRef",
                  class: normalizeClass([
                    _ctx.nsSelect.e("wrapper"),
                    _ctx.nsSelect.is("focused", _ctx.isFocused),
                    _ctx.nsSelect.is("hovering", _ctx.states.inputHovering),
                    _ctx.nsSelect.is("filterable", _ctx.filterable),
                    _ctx.nsSelect.is("disabled", _ctx.selectDisabled)
                  ])
                }, [
                  _ctx.$slots.prefix ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    ref: "prefixRef",
                    class: normalizeClass(_ctx.nsSelect.e("prefix"))
                  }, [
                    renderSlot(_ctx.$slots, "prefix")
                  ], 2)) : createCommentVNode("v-if", true),
                  createElementVNode("div", {
                    ref: "selectionRef",
                    class: normalizeClass([
                      _ctx.nsSelect.e("selection"),
                      _ctx.nsSelect.is("near", _ctx.multiple && !_ctx.$slots.prefix && !!_ctx.states.selected.length)
                    ])
                  }, [
                    _ctx.multiple ? renderSlot(_ctx.$slots, "tag", { key: 0 }, () => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.showTagList, (item) => {
                        return openBlock(), createElementBlock("div", {
                          key: _ctx.getValueKey(item),
                          class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                        }, [
                          createVNode(_component_el_tag, {
                            closable: !_ctx.selectDisabled && !item.isDisabled,
                            size: _ctx.collapseTagSize,
                            type: _ctx.tagType,
                            "disable-transitions": "",
                            style: normalizeStyle(_ctx.tagStyle),
                            onClose: ($event) => _ctx.deleteTag($event, item)
                          }, {
                            default: withCtx(() => [
                              createElementVNode("span", {
                                class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                              }, toDisplayString(item.currentLabel), 3)
                            ]),
                            _: 2
                          }, 1032, ["closable", "size", "type", "style", "onClose"])
                        ], 2);
                      }), 128)),
                      _ctx.collapseTags && _ctx.states.selected.length > _ctx.maxCollapseTags ? (openBlock(), createBlock(_component_el_tooltip, {
                        key: 0,
                        ref: "tagTooltipRef",
                        disabled: _ctx.dropdownMenuVisible || !_ctx.collapseTagsTooltip,
                        "fallback-placements": ["bottom", "top", "right", "left"],
                        effect: _ctx.effect,
                        placement: "bottom",
                        teleported: _ctx.teleported
                      }, {
                        default: withCtx(() => [
                          createElementVNode("div", {
                            ref: "collapseItemRef",
                            class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                          }, [
                            createVNode(_component_el_tag, {
                              closable: false,
                              size: _ctx.collapseTagSize,
                              type: _ctx.tagType,
                              "disable-transitions": "",
                              style: normalizeStyle(_ctx.collapseTagStyle)
                            }, {
                              default: withCtx(() => [
                                createElementVNode("span", {
                                  class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                                }, " + " + toDisplayString(_ctx.states.selected.length - _ctx.maxCollapseTags), 3)
                              ]),
                              _: 1
                            }, 8, ["size", "type", "style"])
                          ], 2)
                        ]),
                        content: withCtx(() => [
                          createElementVNode("div", {
                            ref: "tagMenuRef",
                            class: normalizeClass(_ctx.nsSelect.e("selection"))
                          }, [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.collapseTagList, (item) => {
                              return openBlock(), createElementBlock("div", {
                                key: _ctx.getValueKey(item),
                                class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                              }, [
                                createVNode(_component_el_tag, {
                                  class: "in-tooltip",
                                  closable: !_ctx.selectDisabled && !item.isDisabled,
                                  size: _ctx.collapseTagSize,
                                  type: _ctx.tagType,
                                  "disable-transitions": "",
                                  onClose: ($event) => _ctx.deleteTag($event, item)
                                }, {
                                  default: withCtx(() => [
                                    createElementVNode("span", {
                                      class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                                    }, toDisplayString(item.currentLabel), 3)
                                  ]),
                                  _: 2
                                }, 1032, ["closable", "size", "type", "onClose"])
                              ], 2);
                            }), 128))
                          ], 2)
                        ]),
                        _: 1
                      }, 8, ["disabled", "effect", "teleported"])) : createCommentVNode("v-if", true)
                    ]) : createCommentVNode("v-if", true),
                    !_ctx.selectDisabled ? (openBlock(), createElementBlock("div", {
                      key: 1,
                      class: normalizeClass([
                        _ctx.nsSelect.e("selected-item"),
                        _ctx.nsSelect.e("input-wrapper"),
                        _ctx.nsSelect.is("hidden", !_ctx.filterable)
                      ])
                    }, [
                      withDirectives(createElementVNode("input", {
                        id: _ctx.inputId,
                        ref: "inputRef",
                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.states.inputValue = $event),
                        type: "text",
                        class: normalizeClass([_ctx.nsSelect.e("input"), _ctx.nsSelect.is(_ctx.selectSize)]),
                        disabled: _ctx.selectDisabled,
                        autocomplete: _ctx.autocomplete,
                        style: normalizeStyle(_ctx.inputStyle),
                        role: "combobox",
                        readonly: !_ctx.filterable,
                        spellcheck: "false",
                        "aria-activedescendant": ((_a = _ctx.hoverOption) == null ? void 0 : _a.id) || "",
                        "aria-controls": _ctx.contentId,
                        "aria-expanded": _ctx.dropdownMenuVisible,
                        "aria-label": _ctx.ariaLabel,
                        "aria-autocomplete": "none",
                        "aria-haspopup": "listbox",
                        onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                        onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                        onKeydown: [
                          _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
                          _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
                          _cache[5] || (_cache[5] = withKeys(withModifiers((...args) => _ctx.handleEsc && _ctx.handleEsc(...args), ["stop", "prevent"]), ["esc"])),
                          _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => _ctx.selectOption && _ctx.selectOption(...args), ["stop", "prevent"]), ["enter"])),
                          _cache[7] || (_cache[7] = withKeys(withModifiers((...args) => _ctx.deletePrevTag && _ctx.deletePrevTag(...args), ["stop"]), ["delete"]))
                        ],
                        onCompositionstart: _cache[8] || (_cache[8] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
                        onCompositionupdate: _cache[9] || (_cache[9] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
                        onCompositionend: _cache[10] || (_cache[10] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
                        onInput: _cache[11] || (_cache[11] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                        onClick: _cache[12] || (_cache[12] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
                      }, null, 46, _hoisted_1$j), [
                        [vModelText, _ctx.states.inputValue]
                      ]),
                      _ctx.filterable ? (openBlock(), createElementBlock("span", {
                        key: 0,
                        ref: "calculatorRef",
                        "aria-hidden": "true",
                        class: normalizeClass(_ctx.nsSelect.e("input-calculator")),
                        textContent: toDisplayString(_ctx.states.inputValue)
                      }, null, 10, _hoisted_2$f)) : createCommentVNode("v-if", true)
                    ], 2)) : createCommentVNode("v-if", true),
                    _ctx.shouldShowPlaceholder ? (openBlock(), createElementBlock("div", {
                      key: 2,
                      class: normalizeClass([
                        _ctx.nsSelect.e("selected-item"),
                        _ctx.nsSelect.e("placeholder"),
                        _ctx.nsSelect.is("transparent", !_ctx.hasModelValue || _ctx.expanded && !_ctx.states.inputValue)
                      ])
                    }, [
                      createElementVNode("span", null, toDisplayString(_ctx.currentPlaceholder), 1)
                    ], 2)) : createCommentVNode("v-if", true)
                  ], 2),
                  createElementVNode("div", {
                    ref: "suffixRef",
                    class: normalizeClass(_ctx.nsSelect.e("suffix"))
                  }, [
                    _ctx.iconComponent && !_ctx.showClose ? (openBlock(), createBlock(_component_el_icon, {
                      key: 0,
                      class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon"), _ctx.iconReverse])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true),
                    _ctx.showClose && _ctx.clearIcon ? (openBlock(), createBlock(_component_el_icon, {
                      key: 1,
                      class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon")]),
                      onClick: _ctx.handleClearClick
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                      ]),
                      _: 1
                    }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
                    _ctx.validateState && _ctx.validateIcon ? (openBlock(), createBlock(_component_el_icon, {
                      key: 2,
                      class: normalizeClass([_ctx.nsInput.e("icon"), _ctx.nsInput.e("validateIcon")])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.validateIcon)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true)
                  ], 2)
                ], 2)
              ];
            }),
            content: withCtx(() => [
              createVNode(_component_el_select_menu, { ref: "menuRef" }, {
                default: withCtx(() => [
                  _ctx.$slots.header ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass(_ctx.nsSelect.be("dropdown", "header")),
                    onClick: _cache[13] || (_cache[13] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    renderSlot(_ctx.$slots, "header")
                  ], 2)) : createCommentVNode("v-if", true),
                  withDirectives(createVNode(_component_el_scrollbar, {
                    id: _ctx.contentId,
                    ref: "scrollbarRef",
                    tag: "ul",
                    "wrap-class": _ctx.nsSelect.be("dropdown", "wrap"),
                    "view-class": _ctx.nsSelect.be("dropdown", "list"),
                    class: normalizeClass([_ctx.nsSelect.is("empty", _ctx.filteredOptionsCount === 0)]),
                    role: "listbox",
                    "aria-label": _ctx.ariaLabel,
                    "aria-orientation": "vertical"
                  }, {
                    default: withCtx(() => [
                      _ctx.showNewOption ? (openBlock(), createBlock(_component_el_option, {
                        key: 0,
                        value: _ctx.states.inputValue,
                        created: true
                      }, null, 8, ["value"])) : createCommentVNode("v-if", true),
                      createVNode(_component_el_options, null, {
                        default: withCtx(() => [
                          renderSlot(_ctx.$slots, "default")
                        ]),
                        _: 3
                      })
                    ]),
                    _: 3
                  }, 8, ["id", "wrap-class", "view-class", "class", "aria-label"]), [
                    [vShow, _ctx.states.options.size > 0 && !_ctx.loading]
                  ]),
                  _ctx.$slots.loading && _ctx.loading ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: normalizeClass(_ctx.nsSelect.be("dropdown", "loading"))
                  }, [
                    renderSlot(_ctx.$slots, "loading")
                  ], 2)) : _ctx.loading || _ctx.filteredOptionsCount === 0 ? (openBlock(), createElementBlock("div", {
                    key: 2,
                    class: normalizeClass(_ctx.nsSelect.be("dropdown", "empty"))
                  }, [
                    renderSlot(_ctx.$slots, "empty", {}, () => [
                      createElementVNode("span", null, toDisplayString(_ctx.emptyText), 1)
                    ])
                  ], 2)) : createCommentVNode("v-if", true),
                  _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
                    key: 3,
                    class: normalizeClass(_ctx.nsSelect.be("dropdown", "footer")),
                    onClick: _cache[14] || (_cache[14] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    renderSlot(_ctx.$slots, "footer")
                  ], 2)) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 512)
            ]),
            _: 3
          }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "fallback-placements", "effect", "transition", "persistent", "onBeforeShow"])
        ], 34)), [
          [_directive_click_outside, _ctx.handleClickOutside, _ctx.popperRef]
        ]);
      }
      var Select = /* @__PURE__ */ _export_sfc$1(_sfc_main$p, [["render", _sfc_render$5], ["__file", "select.vue"]]);
      const _sfc_main$o = defineComponent({
        name: "ElOptionGroup",
        componentName: "ElOptionGroup",
        props: {
          label: String,
          disabled: Boolean
        },
        setup(props) {
          const ns = useNamespace("select");
          const groupRef = ref(null);
          const instance = getCurrentInstance();
          const children = ref([]);
          provide(selectGroupKey, reactive({
            ...toRefs(props)
          }));
          const visible = computed(() => children.value.some((option) => option.visible === true));
          const flattedChildren2 = (node) => {
            const children2 = [];
            if (isArray$1(node.children)) {
              node.children.forEach((child) => {
                var _a, _b;
                if (child.type && child.type.name === "ElOption" && child.component && child.component.proxy) {
                  children2.push(child.component.proxy);
                } else if ((_a = child.children) == null ? void 0 : _a.length) {
                  children2.push(...flattedChildren2(child));
                } else if ((_b = child.component) == null ? void 0 : _b.subTree) {
                  children2.push(...flattedChildren2(child.component.subTree));
                }
              });
            }
            return children2;
          };
          const updateChildren = () => {
            children.value = flattedChildren2(instance.subTree);
          };
          onMounted(() => {
            updateChildren();
          });
          useMutationObserver(groupRef, updateChildren, {
            attributes: true,
            subtree: true,
            childList: true
          });
          return {
            groupRef,
            visible,
            ns
          };
        }
      });
      function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
        return withDirectives((openBlock(), createElementBlock("ul", {
          ref: "groupRef",
          class: normalizeClass(_ctx.ns.be("group", "wrap"))
        }, [
          createElementVNode("li", {
            class: normalizeClass(_ctx.ns.be("group", "title"))
          }, toDisplayString(_ctx.label), 3),
          createElementVNode("li", null, [
            createElementVNode("ul", {
              class: normalizeClass(_ctx.ns.b("group"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2)
          ])
        ], 2)), [
          [vShow, _ctx.visible]
        ]);
      }
      var OptionGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$o, [["render", _sfc_render$4], ["__file", "option-group.vue"]]);
      const ElSelect = withInstall(Select, {
        Option,
        OptionGroup
      });
      const ElOption = withNoopInstall(Option);
      withNoopInstall(OptionGroup);
      const usePagination = () => inject(elPaginationKey, {});
      const paginationSizesProps = buildProps({
        pageSize: {
          type: Number,
          required: true
        },
        pageSizes: {
          type: definePropType(Array),
          default: () => mutable([10, 20, 30, 40, 50, 100])
        },
        popperClass: {
          type: String
        },
        disabled: Boolean,
        teleported: Boolean,
        size: {
          type: String,
          values: componentSizes
        }
      });
      const __default__$a = defineComponent({
        name: "ElPaginationSizes"
      });
      const _sfc_main$n = /* @__PURE__ */ defineComponent({
        ...__default__$a,
        props: paginationSizesProps,
        emits: ["page-size-change"],
        setup(__props, { emit }) {
          const props = __props;
          const { t } = useLocale();
          const ns = useNamespace("pagination");
          const pagination = usePagination();
          const innerPageSize = ref(props.pageSize);
          watch(() => props.pageSizes, (newVal, oldVal) => {
            if (isEqual(newVal, oldVal))
              return;
            if (Array.isArray(newVal)) {
              const pageSize = newVal.includes(props.pageSize) ? props.pageSize : props.pageSizes[0];
              emit("page-size-change", pageSize);
            }
          });
          watch(() => props.pageSize, (newVal) => {
            innerPageSize.value = newVal;
          });
          const innerPageSizes = computed(() => props.pageSizes);
          function handleChange(val) {
            var _a;
            if (val !== innerPageSize.value) {
              innerPageSize.value = val;
              (_a = pagination.handleSizeChange) == null ? void 0 : _a.call(pagination, Number(val));
            }
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              class: normalizeClass(unref(ns).e("sizes"))
            }, [
              createVNode(unref(ElSelect), {
                "model-value": innerPageSize.value,
                disabled: _ctx.disabled,
                "popper-class": _ctx.popperClass,
                size: _ctx.size,
                teleported: _ctx.teleported,
                "validate-event": false,
                onChange: handleChange
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(innerPageSizes), (item) => {
                    return openBlock(), createBlock(unref(ElOption), {
                      key: item,
                      value: item,
                      label: item + unref(t)("el.pagination.pagesize")
                    }, null, 8, ["value", "label"]);
                  }), 128))
                ]),
                _: 1
              }, 8, ["model-value", "disabled", "popper-class", "size", "teleported"])
            ], 2);
          };
        }
      });
      var Sizes = /* @__PURE__ */ _export_sfc$1(_sfc_main$n, [["__file", "sizes.vue"]]);
      const paginationJumperProps = buildProps({
        size: {
          type: String,
          values: componentSizes
        }
      });
      const _hoisted_1$i = ["disabled"];
      const __default__$9 = defineComponent({
        name: "ElPaginationJumper"
      });
      const _sfc_main$m = /* @__PURE__ */ defineComponent({
        ...__default__$9,
        props: paginationJumperProps,
        setup(__props) {
          const { t } = useLocale();
          const ns = useNamespace("pagination");
          const { pageCount, disabled, currentPage, changeEvent } = usePagination();
          const userInput = ref();
          const innerValue = computed(() => {
            var _a;
            return (_a = userInput.value) != null ? _a : currentPage == null ? void 0 : currentPage.value;
          });
          function handleInput(val) {
            userInput.value = val ? +val : "";
          }
          function handleChange(val) {
            val = Math.trunc(+val);
            changeEvent == null ? void 0 : changeEvent(val);
            userInput.value = void 0;
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              class: normalizeClass(unref(ns).e("jump")),
              disabled: unref(disabled)
            }, [
              createElementVNode("span", {
                class: normalizeClass([unref(ns).e("goto")])
              }, toDisplayString(unref(t)("el.pagination.goto")), 3),
              createVNode(unref(ElInput), {
                size: _ctx.size,
                class: normalizeClass([unref(ns).e("editor"), unref(ns).is("in-pagination")]),
                min: 1,
                max: unref(pageCount),
                disabled: unref(disabled),
                "model-value": unref(innerValue),
                "validate-event": false,
                label: unref(t)("el.pagination.page"),
                type: "number",
                "onUpdate:modelValue": handleInput,
                onChange: handleChange
              }, null, 8, ["size", "class", "max", "disabled", "model-value", "label"]),
              createElementVNode("span", {
                class: normalizeClass([unref(ns).e("classifier")])
              }, toDisplayString(unref(t)("el.pagination.pageClassifier")), 3)
            ], 10, _hoisted_1$i);
          };
        }
      });
      var Jumper = /* @__PURE__ */ _export_sfc$1(_sfc_main$m, [["__file", "jumper.vue"]]);
      const paginationTotalProps = buildProps({
        total: {
          type: Number,
          default: 1e3
        }
      });
      const _hoisted_1$h = ["disabled"];
      const __default__$8 = defineComponent({
        name: "ElPaginationTotal"
      });
      const _sfc_main$l = /* @__PURE__ */ defineComponent({
        ...__default__$8,
        props: paginationTotalProps,
        setup(__props) {
          const { t } = useLocale();
          const ns = useNamespace("pagination");
          const { disabled } = usePagination();
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              class: normalizeClass(unref(ns).e("total")),
              disabled: unref(disabled)
            }, toDisplayString(unref(t)("el.pagination.total", {
              total: _ctx.total
            })), 11, _hoisted_1$h);
          };
        }
      });
      var Total = /* @__PURE__ */ _export_sfc$1(_sfc_main$l, [["__file", "total.vue"]]);
      const paginationPagerProps = buildProps({
        currentPage: {
          type: Number,
          default: 1
        },
        pageCount: {
          type: Number,
          required: true
        },
        pagerCount: {
          type: Number,
          default: 7
        },
        disabled: Boolean
      });
      const _hoisted_1$g = ["onKeyup"];
      const _hoisted_2$e = ["aria-current", "aria-label", "tabindex"];
      const _hoisted_3$b = ["tabindex", "aria-label"];
      const _hoisted_4$8 = ["aria-current", "aria-label", "tabindex"];
      const _hoisted_5$7 = ["tabindex", "aria-label"];
      const _hoisted_6$5 = ["aria-current", "aria-label", "tabindex"];
      const __default__$7 = defineComponent({
        name: "ElPaginationPager"
      });
      const _sfc_main$k = /* @__PURE__ */ defineComponent({
        ...__default__$7,
        props: paginationPagerProps,
        emits: ["change"],
        setup(__props, { emit }) {
          const props = __props;
          const nsPager = useNamespace("pager");
          const nsIcon = useNamespace("icon");
          const { t } = useLocale();
          const showPrevMore = ref(false);
          const showNextMore = ref(false);
          const quickPrevHover = ref(false);
          const quickNextHover = ref(false);
          const quickPrevFocus = ref(false);
          const quickNextFocus = ref(false);
          const pagers = computed(() => {
            const pagerCount = props.pagerCount;
            const halfPagerCount = (pagerCount - 1) / 2;
            const currentPage = Number(props.currentPage);
            const pageCount = Number(props.pageCount);
            let showPrevMore2 = false;
            let showNextMore2 = false;
            if (pageCount > pagerCount) {
              if (currentPage > pagerCount - halfPagerCount) {
                showPrevMore2 = true;
              }
              if (currentPage < pageCount - halfPagerCount) {
                showNextMore2 = true;
              }
            }
            const array4 = [];
            if (showPrevMore2 && !showNextMore2) {
              const startPage = pageCount - (pagerCount - 2);
              for (let i = startPage; i < pageCount; i++) {
                array4.push(i);
              }
            } else if (!showPrevMore2 && showNextMore2) {
              for (let i = 2; i < pagerCount; i++) {
                array4.push(i);
              }
            } else if (showPrevMore2 && showNextMore2) {
              const offset = Math.floor(pagerCount / 2) - 1;
              for (let i = currentPage - offset; i <= currentPage + offset; i++) {
                array4.push(i);
              }
            } else {
              for (let i = 2; i < pageCount; i++) {
                array4.push(i);
              }
            }
            return array4;
          });
          const prevMoreKls = computed(() => [
            "more",
            "btn-quickprev",
            nsIcon.b(),
            nsPager.is("disabled", props.disabled)
          ]);
          const nextMoreKls = computed(() => [
            "more",
            "btn-quicknext",
            nsIcon.b(),
            nsPager.is("disabled", props.disabled)
          ]);
          const tabindex = computed(() => props.disabled ? -1 : 0);
          watchEffect(() => {
            const halfPagerCount = (props.pagerCount - 1) / 2;
            showPrevMore.value = false;
            showNextMore.value = false;
            if (props.pageCount > props.pagerCount) {
              if (props.currentPage > props.pagerCount - halfPagerCount) {
                showPrevMore.value = true;
              }
              if (props.currentPage < props.pageCount - halfPagerCount) {
                showNextMore.value = true;
              }
            }
          });
          function onMouseEnter(forward = false) {
            if (props.disabled)
              return;
            if (forward) {
              quickPrevHover.value = true;
            } else {
              quickNextHover.value = true;
            }
          }
          function onFocus(forward = false) {
            if (forward) {
              quickPrevFocus.value = true;
            } else {
              quickNextFocus.value = true;
            }
          }
          function onEnter(e) {
            const target = e.target;
            if (target.tagName.toLowerCase() === "li" && Array.from(target.classList).includes("number")) {
              const newPage = Number(target.textContent);
              if (newPage !== props.currentPage) {
                emit("change", newPage);
              }
            } else if (target.tagName.toLowerCase() === "li" && Array.from(target.classList).includes("more")) {
              onPagerClick(e);
            }
          }
          function onPagerClick(event) {
            const target = event.target;
            if (target.tagName.toLowerCase() === "ul" || props.disabled) {
              return;
            }
            let newPage = Number(target.textContent);
            const pageCount = props.pageCount;
            const currentPage = props.currentPage;
            const pagerCountOffset = props.pagerCount - 2;
            if (target.className.includes("more")) {
              if (target.className.includes("quickprev")) {
                newPage = currentPage - pagerCountOffset;
              } else if (target.className.includes("quicknext")) {
                newPage = currentPage + pagerCountOffset;
              }
            }
            if (!Number.isNaN(+newPage)) {
              if (newPage < 1) {
                newPage = 1;
              }
              if (newPage > pageCount) {
                newPage = pageCount;
              }
            }
            if (newPage !== currentPage) {
              emit("change", newPage);
            }
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("ul", {
              class: normalizeClass(unref(nsPager).b()),
              onClick: onPagerClick,
              onKeyup: withKeys(onEnter, ["enter"])
            }, [
              _ctx.pageCount > 0 ? (openBlock(), createElementBlock("li", {
                key: 0,
                class: normalizeClass([[
                  unref(nsPager).is("active", _ctx.currentPage === 1),
                  unref(nsPager).is("disabled", _ctx.disabled)
                ], "number"]),
                "aria-current": _ctx.currentPage === 1,
                "aria-label": unref(t)("el.pagination.currentPage", { pager: 1 }),
                tabindex: unref(tabindex)
              }, " 1 ", 10, _hoisted_2$e)) : createCommentVNode("v-if", true),
              showPrevMore.value ? (openBlock(), createElementBlock("li", {
                key: 1,
                class: normalizeClass(unref(prevMoreKls)),
                tabindex: unref(tabindex),
                "aria-label": unref(t)("el.pagination.prevPages", { pager: _ctx.pagerCount - 2 }),
                onMouseenter: _cache[0] || (_cache[0] = ($event) => onMouseEnter(true)),
                onMouseleave: _cache[1] || (_cache[1] = ($event) => quickPrevHover.value = false),
                onFocus: _cache[2] || (_cache[2] = ($event) => onFocus(true)),
                onBlur: _cache[3] || (_cache[3] = ($event) => quickPrevFocus.value = false)
              }, [
                (quickPrevHover.value || quickPrevFocus.value) && !_ctx.disabled ? (openBlock(), createBlock(unref(d_arrow_left_default), { key: 0 })) : (openBlock(), createBlock(unref(more_filled_default), { key: 1 }))
              ], 42, _hoisted_3$b)) : createCommentVNode("v-if", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(pagers), (pager) => {
                return openBlock(), createElementBlock("li", {
                  key: pager,
                  class: normalizeClass([[
                    unref(nsPager).is("active", _ctx.currentPage === pager),
                    unref(nsPager).is("disabled", _ctx.disabled)
                  ], "number"]),
                  "aria-current": _ctx.currentPage === pager,
                  "aria-label": unref(t)("el.pagination.currentPage", { pager }),
                  tabindex: unref(tabindex)
                }, toDisplayString(pager), 11, _hoisted_4$8);
              }), 128)),
              showNextMore.value ? (openBlock(), createElementBlock("li", {
                key: 2,
                class: normalizeClass(unref(nextMoreKls)),
                tabindex: unref(tabindex),
                "aria-label": unref(t)("el.pagination.nextPages", { pager: _ctx.pagerCount - 2 }),
                onMouseenter: _cache[4] || (_cache[4] = ($event) => onMouseEnter()),
                onMouseleave: _cache[5] || (_cache[5] = ($event) => quickNextHover.value = false),
                onFocus: _cache[6] || (_cache[6] = ($event) => onFocus()),
                onBlur: _cache[7] || (_cache[7] = ($event) => quickNextFocus.value = false)
              }, [
                (quickNextHover.value || quickNextFocus.value) && !_ctx.disabled ? (openBlock(), createBlock(unref(d_arrow_right_default), { key: 0 })) : (openBlock(), createBlock(unref(more_filled_default), { key: 1 }))
              ], 42, _hoisted_5$7)) : createCommentVNode("v-if", true),
              _ctx.pageCount > 1 ? (openBlock(), createElementBlock("li", {
                key: 3,
                class: normalizeClass([[
                  unref(nsPager).is("active", _ctx.currentPage === _ctx.pageCount),
                  unref(nsPager).is("disabled", _ctx.disabled)
                ], "number"]),
                "aria-current": _ctx.currentPage === _ctx.pageCount,
                "aria-label": unref(t)("el.pagination.currentPage", { pager: _ctx.pageCount }),
                tabindex: unref(tabindex)
              }, toDisplayString(_ctx.pageCount), 11, _hoisted_6$5)) : createCommentVNode("v-if", true)
            ], 42, _hoisted_1$g);
          };
        }
      });
      var Pager = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["__file", "pager.vue"]]);
      const isAbsent = (v) => typeof v !== "number";
      const paginationProps = buildProps({
        pageSize: Number,
        defaultPageSize: Number,
        total: Number,
        pageCount: Number,
        pagerCount: {
          type: Number,
          validator: (value) => {
            return isNumber(value) && Math.trunc(value) === value && value > 4 && value < 22 && value % 2 === 1;
          },
          default: 7
        },
        currentPage: Number,
        defaultCurrentPage: Number,
        layout: {
          type: String,
          default: ["prev", "pager", "next", "jumper", "->", "total"].join(", ")
        },
        pageSizes: {
          type: definePropType(Array),
          default: () => mutable([10, 20, 30, 40, 50, 100])
        },
        popperClass: {
          type: String,
          default: ""
        },
        prevText: {
          type: String,
          default: ""
        },
        prevIcon: {
          type: iconPropType,
          default: () => arrow_left_default
        },
        nextText: {
          type: String,
          default: ""
        },
        nextIcon: {
          type: iconPropType,
          default: () => arrow_right_default
        },
        teleported: {
          type: Boolean,
          default: true
        },
        small: Boolean,
        background: Boolean,
        disabled: Boolean,
        hideOnSinglePage: Boolean
      });
      const paginationEmits = {
        "update:current-page": (val) => isNumber(val),
        "update:page-size": (val) => isNumber(val),
        "size-change": (val) => isNumber(val),
        change: (currentPage, pageSize) => isNumber(currentPage) && isNumber(pageSize),
        "current-change": (val) => isNumber(val),
        "prev-click": (val) => isNumber(val),
        "next-click": (val) => isNumber(val)
      };
      const componentName = "ElPagination";
      var Pagination = defineComponent({
        name: componentName,
        props: paginationProps,
        emits: paginationEmits,
        setup(props, { emit, slots }) {
          const { t } = useLocale();
          const ns = useNamespace("pagination");
          const vnodeProps = getCurrentInstance().vnode.props || {};
          const hasCurrentPageListener = "onUpdate:currentPage" in vnodeProps || "onUpdate:current-page" in vnodeProps || "onCurrentChange" in vnodeProps;
          const hasPageSizeListener = "onUpdate:pageSize" in vnodeProps || "onUpdate:page-size" in vnodeProps || "onSizeChange" in vnodeProps;
          const assertValidUsage = computed(() => {
            if (isAbsent(props.total) && isAbsent(props.pageCount))
              return false;
            if (!isAbsent(props.currentPage) && !hasCurrentPageListener)
              return false;
            if (props.layout.includes("sizes")) {
              if (!isAbsent(props.pageCount)) {
                if (!hasPageSizeListener)
                  return false;
              } else if (!isAbsent(props.total)) {
                if (!isAbsent(props.pageSize)) {
                  if (!hasPageSizeListener) {
                    return false;
                  }
                }
              }
            }
            return true;
          });
          const innerPageSize = ref(isAbsent(props.defaultPageSize) ? 10 : props.defaultPageSize);
          const innerCurrentPage = ref(isAbsent(props.defaultCurrentPage) ? 1 : props.defaultCurrentPage);
          const pageSizeBridge = computed({
            get() {
              return isAbsent(props.pageSize) ? innerPageSize.value : props.pageSize;
            },
            set(v) {
              if (isAbsent(props.pageSize)) {
                innerPageSize.value = v;
              }
              if (hasPageSizeListener) {
                emit("update:page-size", v);
                emit("size-change", v);
              }
            }
          });
          const pageCountBridge = computed(() => {
            let pageCount = 0;
            if (!isAbsent(props.pageCount)) {
              pageCount = props.pageCount;
            } else if (!isAbsent(props.total)) {
              pageCount = Math.max(1, Math.ceil(props.total / pageSizeBridge.value));
            }
            return pageCount;
          });
          const currentPageBridge = computed({
            get() {
              return isAbsent(props.currentPage) ? innerCurrentPage.value : props.currentPage;
            },
            set(v) {
              let newCurrentPage = v;
              if (v < 1) {
                newCurrentPage = 1;
              } else if (v > pageCountBridge.value) {
                newCurrentPage = pageCountBridge.value;
              }
              if (isAbsent(props.currentPage)) {
                innerCurrentPage.value = newCurrentPage;
              }
              if (hasCurrentPageListener) {
                emit("update:current-page", newCurrentPage);
                emit("current-change", newCurrentPage);
              }
            }
          });
          watch(pageCountBridge, (val) => {
            if (currentPageBridge.value > val)
              currentPageBridge.value = val;
          });
          watch([currentPageBridge, pageSizeBridge], (value) => {
            emit("change", ...value);
          }, { flush: "post" });
          function handleCurrentChange(val) {
            currentPageBridge.value = val;
          }
          function handleSizeChange(val) {
            pageSizeBridge.value = val;
            const newPageCount = pageCountBridge.value;
            if (currentPageBridge.value > newPageCount) {
              currentPageBridge.value = newPageCount;
            }
          }
          function prev() {
            if (props.disabled)
              return;
            currentPageBridge.value -= 1;
            emit("prev-click", currentPageBridge.value);
          }
          function next() {
            if (props.disabled)
              return;
            currentPageBridge.value += 1;
            emit("next-click", currentPageBridge.value);
          }
          function addClass2(element, cls) {
            if (element) {
              if (!element.props) {
                element.props = {};
              }
              element.props.class = [element.props.class, cls].join(" ");
            }
          }
          provide(elPaginationKey, {
            pageCount: pageCountBridge,
            disabled: computed(() => props.disabled),
            currentPage: currentPageBridge,
            changeEvent: handleCurrentChange,
            handleSizeChange
          });
          return () => {
            var _a, _b;
            if (!assertValidUsage.value) {
              debugWarn(componentName, t("el.pagination.deprecationWarning"));
              return null;
            }
            if (!props.layout)
              return null;
            if (props.hideOnSinglePage && pageCountBridge.value <= 1)
              return null;
            const rootChildren = [];
            const rightWrapperChildren = [];
            const rightWrapperRoot = h("div", { class: ns.e("rightwrapper") }, rightWrapperChildren);
            const TEMPLATE_MAP = {
              prev: h(Prev, {
                disabled: props.disabled,
                currentPage: currentPageBridge.value,
                prevText: props.prevText,
                prevIcon: props.prevIcon,
                onClick: prev
              }),
              jumper: h(Jumper, {
                size: props.small ? "small" : "default"
              }),
              pager: h(Pager, {
                currentPage: currentPageBridge.value,
                pageCount: pageCountBridge.value,
                pagerCount: props.pagerCount,
                onChange: handleCurrentChange,
                disabled: props.disabled
              }),
              next: h(Next, {
                disabled: props.disabled,
                currentPage: currentPageBridge.value,
                pageCount: pageCountBridge.value,
                nextText: props.nextText,
                nextIcon: props.nextIcon,
                onClick: next
              }),
              sizes: h(Sizes, {
                pageSize: pageSizeBridge.value,
                pageSizes: props.pageSizes,
                popperClass: props.popperClass,
                disabled: props.disabled,
                teleported: props.teleported,
                size: props.small ? "small" : "default"
              }),
              slot: (_b = (_a = slots == null ? void 0 : slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : null,
              total: h(Total, { total: isAbsent(props.total) ? 0 : props.total })
            };
            const components = props.layout.split(",").map((item) => item.trim());
            let haveRightWrapper = false;
            components.forEach((c) => {
              if (c === "->") {
                haveRightWrapper = true;
                return;
              }
              if (!haveRightWrapper) {
                rootChildren.push(TEMPLATE_MAP[c]);
              } else {
                rightWrapperChildren.push(TEMPLATE_MAP[c]);
              }
            });
            addClass2(rootChildren[0], ns.is("first"));
            addClass2(rootChildren[rootChildren.length - 1], ns.is("last"));
            if (haveRightWrapper && rightWrapperChildren.length > 0) {
              addClass2(rightWrapperChildren[0], ns.is("first"));
              addClass2(rightWrapperChildren[rightWrapperChildren.length - 1], ns.is("last"));
              rootChildren.push(rightWrapperRoot);
            }
            return h("div", {
              class: [
                ns.b(),
                ns.is("background", props.background),
                {
                  [ns.m("small")]: props.small
                }
              ]
            }, rootChildren);
          };
        }
      });
      const ElPagination = withInstall(Pagination);
      const popconfirmProps = buildProps({
        title: String,
        confirmButtonText: String,
        cancelButtonText: String,
        confirmButtonType: {
          type: String,
          values: buttonTypes,
          default: "primary"
        },
        cancelButtonType: {
          type: String,
          values: buttonTypes,
          default: "text"
        },
        icon: {
          type: iconPropType,
          default: () => question_filled_default
        },
        iconColor: {
          type: String,
          default: "#f90"
        },
        hideIcon: {
          type: Boolean,
          default: false
        },
        hideAfter: {
          type: Number,
          default: 200
        },
        teleported: useTooltipContentProps.teleported,
        persistent: useTooltipContentProps.persistent,
        width: {
          type: [String, Number],
          default: 150
        }
      });
      const popconfirmEmits = {
        confirm: (e) => e instanceof MouseEvent,
        cancel: (e) => e instanceof MouseEvent
      };
      const __default__$6 = defineComponent({
        name: "ElPopconfirm"
      });
      const _sfc_main$j = /* @__PURE__ */ defineComponent({
        ...__default__$6,
        props: popconfirmProps,
        emits: popconfirmEmits,
        setup(__props, { emit }) {
          const props = __props;
          const { t } = useLocale();
          const ns = useNamespace("popconfirm");
          const tooltipRef = ref();
          const hidePopper = () => {
            var _a, _b;
            (_b = (_a = tooltipRef.value) == null ? void 0 : _a.onClose) == null ? void 0 : _b.call(_a);
          };
          const style = computed(() => {
            return {
              width: addUnit(props.width)
            };
          });
          const confirm = (e) => {
            emit("confirm", e);
            hidePopper();
          };
          const cancel = (e) => {
            emit("cancel", e);
            hidePopper();
          };
          const finalConfirmButtonText = computed(() => props.confirmButtonText || t("el.popconfirm.confirmButtonText"));
          const finalCancelButtonText = computed(() => props.cancelButtonText || t("el.popconfirm.cancelButtonText"));
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElTooltip), mergeProps({
              ref_key: "tooltipRef",
              ref: tooltipRef,
              trigger: "click",
              effect: "light"
            }, _ctx.$attrs, {
              "popper-class": `${unref(ns).namespace.value}-popover`,
              "popper-style": unref(style),
              teleported: _ctx.teleported,
              "fallback-placements": ["bottom", "top", "right", "left"],
              "hide-after": _ctx.hideAfter,
              persistent: _ctx.persistent
            }), {
              content: withCtx(() => [
                createElementVNode("div", {
                  class: normalizeClass(unref(ns).b())
                }, [
                  createElementVNode("div", {
                    class: normalizeClass(unref(ns).e("main"))
                  }, [
                    !_ctx.hideIcon && _ctx.icon ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass(unref(ns).e("icon")),
                      style: normalizeStyle({ color: _ctx.iconColor })
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
                      ]),
                      _: 1
                    }, 8, ["class", "style"])) : createCommentVNode("v-if", true),
                    createTextVNode(" " + toDisplayString(_ctx.title), 1)
                  ], 2),
                  createElementVNode("div", {
                    class: normalizeClass(unref(ns).e("action"))
                  }, [
                    createVNode(unref(ElButton), {
                      size: "small",
                      type: _ctx.cancelButtonType === "text" ? "" : _ctx.cancelButtonType,
                      text: _ctx.cancelButtonType === "text",
                      onClick: cancel
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(unref(finalCancelButtonText)), 1)
                      ]),
                      _: 1
                    }, 8, ["type", "text"]),
                    createVNode(unref(ElButton), {
                      size: "small",
                      type: _ctx.confirmButtonType === "text" ? "" : _ctx.confirmButtonType,
                      text: _ctx.confirmButtonType === "text",
                      onClick: confirm
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(unref(finalConfirmButtonText)), 1)
                      ]),
                      _: 1
                    }, 8, ["type", "text"])
                  ], 2)
                ], 2)
              ]),
              default: withCtx(() => [
                _ctx.$slots.reference ? renderSlot(_ctx.$slots, "reference", { key: 0 }) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16, ["popper-class", "popper-style", "teleported", "hide-after", "persistent"]);
          };
        }
      });
      var Popconfirm = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["__file", "popconfirm.vue"]]);
      const ElPopconfirm = withInstall(Popconfirm);
      const progressProps = buildProps({
        type: {
          type: String,
          default: "line",
          values: ["line", "circle", "dashboard"]
        },
        percentage: {
          type: Number,
          default: 0,
          validator: (val) => val >= 0 && val <= 100
        },
        status: {
          type: String,
          default: "",
          values: ["", "success", "exception", "warning"]
        },
        indeterminate: {
          type: Boolean,
          default: false
        },
        duration: {
          type: Number,
          default: 3
        },
        strokeWidth: {
          type: Number,
          default: 6
        },
        strokeLinecap: {
          type: definePropType(String),
          default: "round"
        },
        textInside: {
          type: Boolean,
          default: false
        },
        width: {
          type: Number,
          default: 126
        },
        showText: {
          type: Boolean,
          default: true
        },
        color: {
          type: definePropType([
            String,
            Array,
            Function
          ]),
          default: ""
        },
        striped: Boolean,
        stripedFlow: Boolean,
        format: {
          type: definePropType(Function),
          default: (percentage) => `${percentage}%`
        }
      });
      const _hoisted_1$f = ["aria-valuenow"];
      const _hoisted_2$d = { viewBox: "0 0 100 100" };
      const _hoisted_3$a = ["d", "stroke", "stroke-linecap", "stroke-width"];
      const _hoisted_4$7 = ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"];
      const _hoisted_5$6 = { key: 0 };
      const __default__$5 = defineComponent({
        name: "ElProgress"
      });
      const _sfc_main$i = /* @__PURE__ */ defineComponent({
        ...__default__$5,
        props: progressProps,
        setup(__props) {
          const props = __props;
          const STATUS_COLOR_MAP = {
            success: "#13ce66",
            exception: "#ff4949",
            warning: "#e6a23c",
            default: "#20a0ff"
          };
          const ns = useNamespace("progress");
          const barStyle = computed(() => ({
            width: `${props.percentage}%`,
            animationDuration: `${props.duration}s`,
            backgroundColor: getCurrentColor(props.percentage)
          }));
          const relativeStrokeWidth = computed(() => (props.strokeWidth / props.width * 100).toFixed(1));
          const radius = computed(() => {
            if (["circle", "dashboard"].includes(props.type)) {
              return Number.parseInt(`${50 - Number.parseFloat(relativeStrokeWidth.value) / 2}`, 10);
            }
            return 0;
          });
          const trackPath = computed(() => {
            const r = radius.value;
            const isDashboard = props.type === "dashboard";
            return `
          M 50 50
          m 0 ${isDashboard ? "" : "-"}${r}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "-" : ""}${r * 2}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "" : "-"}${r * 2}
          `;
          });
          const perimeter = computed(() => 2 * Math.PI * radius.value);
          const rate = computed(() => props.type === "dashboard" ? 0.75 : 1);
          const strokeDashoffset = computed(() => {
            const offset = -1 * perimeter.value * (1 - rate.value) / 2;
            return `${offset}px`;
          });
          const trailPathStyle = computed(() => ({
            strokeDasharray: `${perimeter.value * rate.value}px, ${perimeter.value}px`,
            strokeDashoffset: strokeDashoffset.value
          }));
          const circlePathStyle = computed(() => ({
            strokeDasharray: `${perimeter.value * rate.value * (props.percentage / 100)}px, ${perimeter.value}px`,
            strokeDashoffset: strokeDashoffset.value,
            transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
          }));
          const stroke = computed(() => {
            let ret;
            if (props.color) {
              ret = getCurrentColor(props.percentage);
            } else {
              ret = STATUS_COLOR_MAP[props.status] || STATUS_COLOR_MAP.default;
            }
            return ret;
          });
          const statusIcon = computed(() => {
            if (props.status === "warning") {
              return warning_filled_default;
            }
            if (props.type === "line") {
              return props.status === "success" ? circle_check_default : circle_close_default;
            } else {
              return props.status === "success" ? check_default : close_default;
            }
          });
          const progressTextSize = computed(() => {
            return props.type === "line" ? 12 + props.strokeWidth * 0.4 : props.width * 0.111111 + 2;
          });
          const content = computed(() => props.format(props.percentage));
          function getColors(color) {
            const span = 100 / color.length;
            const seriesColors = color.map((seriesColor, index) => {
              if (isString(seriesColor)) {
                return {
                  color: seriesColor,
                  percentage: (index + 1) * span
                };
              }
              return seriesColor;
            });
            return seriesColors.sort((a, b) => a.percentage - b.percentage);
          }
          const getCurrentColor = (percentage) => {
            var _a;
            const { color } = props;
            if (isFunction$1(color)) {
              return color(percentage);
            } else if (isString(color)) {
              return color;
            } else {
              const colors = getColors(color);
              for (const color2 of colors) {
                if (color2.percentage > percentage)
                  return color2.color;
              }
              return (_a = colors[colors.length - 1]) == null ? void 0 : _a.color;
            }
          };
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).m(_ctx.type),
                unref(ns).is(_ctx.status),
                {
                  [unref(ns).m("without-text")]: !_ctx.showText,
                  [unref(ns).m("text-inside")]: _ctx.textInside
                }
              ]),
              role: "progressbar",
              "aria-valuenow": _ctx.percentage,
              "aria-valuemin": "0",
              "aria-valuemax": "100"
            }, [
              _ctx.type === "line" ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).b("bar"))
              }, [
                createElementVNode("div", {
                  class: normalizeClass(unref(ns).be("bar", "outer")),
                  style: normalizeStyle({ height: `${_ctx.strokeWidth}px` })
                }, [
                  createElementVNode("div", {
                    class: normalizeClass([
                      unref(ns).be("bar", "inner"),
                      { [unref(ns).bem("bar", "inner", "indeterminate")]: _ctx.indeterminate },
                      { [unref(ns).bem("bar", "inner", "striped")]: _ctx.striped },
                      { [unref(ns).bem("bar", "inner", "striped-flow")]: _ctx.stripedFlow }
                    ]),
                    style: normalizeStyle(unref(barStyle))
                  }, [
                    (_ctx.showText || _ctx.$slots.default) && _ctx.textInside ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: normalizeClass(unref(ns).be("bar", "innerText"))
                    }, [
                      renderSlot(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
                        createElementVNode("span", null, toDisplayString(unref(content)), 1)
                      ])
                    ], 2)) : createCommentVNode("v-if", true)
                  ], 6)
                ], 6)
              ], 2)) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(ns).b("circle")),
                style: normalizeStyle({ height: `${_ctx.width}px`, width: `${_ctx.width}px` })
              }, [
                (openBlock(), createElementBlock("svg", _hoisted_2$d, [
                  createElementVNode("path", {
                    class: normalizeClass(unref(ns).be("circle", "track")),
                    d: unref(trackPath),
                    stroke: `var(${unref(ns).cssVarName("fill-color-light")}, #e5e9f2)`,
                    "stroke-linecap": _ctx.strokeLinecap,
                    "stroke-width": unref(relativeStrokeWidth),
                    fill: "none",
                    style: normalizeStyle(unref(trailPathStyle))
                  }, null, 14, _hoisted_3$a),
                  createElementVNode("path", {
                    class: normalizeClass(unref(ns).be("circle", "path")),
                    d: unref(trackPath),
                    stroke: unref(stroke),
                    fill: "none",
                    opacity: _ctx.percentage ? 1 : 0,
                    "stroke-linecap": _ctx.strokeLinecap,
                    "stroke-width": unref(relativeStrokeWidth),
                    style: normalizeStyle(unref(circlePathStyle))
                  }, null, 14, _hoisted_4$7)
                ]))
              ], 6)),
              (_ctx.showText || _ctx.$slots.default) && !_ctx.textInside ? (openBlock(), createElementBlock("div", {
                key: 2,
                class: normalizeClass(unref(ns).e("text")),
                style: normalizeStyle({ fontSize: `${unref(progressTextSize)}px` })
              }, [
                renderSlot(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
                  !_ctx.status ? (openBlock(), createElementBlock("span", _hoisted_5$6, toDisplayString(unref(content)), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(statusIcon))))
                    ]),
                    _: 1
                  }))
                ])
              ], 6)) : createCommentVNode("v-if", true)
            ], 10, _hoisted_1$f);
          };
        }
      });
      var Progress = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["__file", "progress.vue"]]);
      const ElProgress = withInstall(Progress);
      const switchProps = buildProps({
        modelValue: {
          type: [Boolean, String, Number],
          default: false
        },
        disabled: {
          type: Boolean,
          default: false
        },
        loading: {
          type: Boolean,
          default: false
        },
        size: {
          type: String,
          validator: isValidComponentSize
        },
        width: {
          type: [String, Number],
          default: ""
        },
        inlinePrompt: {
          type: Boolean,
          default: false
        },
        inactiveActionIcon: {
          type: iconPropType
        },
        activeActionIcon: {
          type: iconPropType
        },
        activeIcon: {
          type: iconPropType
        },
        inactiveIcon: {
          type: iconPropType
        },
        activeText: {
          type: String,
          default: ""
        },
        inactiveText: {
          type: String,
          default: ""
        },
        activeValue: {
          type: [Boolean, String, Number],
          default: true
        },
        inactiveValue: {
          type: [Boolean, String, Number],
          default: false
        },
        name: {
          type: String,
          default: ""
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        beforeChange: {
          type: definePropType(Function)
        },
        id: String,
        tabindex: {
          type: [String, Number]
        },
        label: {
          type: String,
          default: void 0
        }
      });
      const switchEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isBoolean(val) || isString(val) || isNumber(val),
        [CHANGE_EVENT]: (val) => isBoolean(val) || isString(val) || isNumber(val),
        [INPUT_EVENT]: (val) => isBoolean(val) || isString(val) || isNumber(val)
      };
      const _hoisted_1$e = ["onClick"];
      const _hoisted_2$c = ["id", "aria-checked", "aria-disabled", "aria-label", "name", "true-value", "false-value", "disabled", "tabindex", "onKeydown"];
      const _hoisted_3$9 = ["aria-hidden"];
      const _hoisted_4$6 = ["aria-hidden"];
      const _hoisted_5$5 = ["aria-hidden"];
      const COMPONENT_NAME$1 = "ElSwitch";
      const __default__$4 = defineComponent({
        name: COMPONENT_NAME$1
      });
      const _sfc_main$h = /* @__PURE__ */ defineComponent({
        ...__default__$4,
        props: switchProps,
        emits: switchEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const { formItem } = useFormItem();
          const switchSize = useFormSize();
          const ns = useNamespace("switch");
          const { inputId } = useFormItemInputId(props, {
            formItemContext: formItem
          });
          const switchDisabled = useFormDisabled(computed(() => props.loading));
          const isControlled = ref(props.modelValue !== false);
          const input = ref();
          const core = ref();
          const switchKls = computed(() => [
            ns.b(),
            ns.m(switchSize.value),
            ns.is("disabled", switchDisabled.value),
            ns.is("checked", checked.value)
          ]);
          const labelLeftKls = computed(() => [
            ns.e("label"),
            ns.em("label", "left"),
            ns.is("active", !checked.value)
          ]);
          const labelRightKls = computed(() => [
            ns.e("label"),
            ns.em("label", "right"),
            ns.is("active", checked.value)
          ]);
          const coreStyle = computed(() => ({
            width: addUnit(props.width)
          }));
          watch(() => props.modelValue, () => {
            isControlled.value = true;
          });
          const actualValue = computed(() => {
            return isControlled.value ? props.modelValue : false;
          });
          const checked = computed(() => actualValue.value === props.activeValue);
          if (![props.activeValue, props.inactiveValue].includes(actualValue.value)) {
            emit(UPDATE_MODEL_EVENT, props.inactiveValue);
            emit(CHANGE_EVENT, props.inactiveValue);
            emit(INPUT_EVENT, props.inactiveValue);
          }
          watch(checked, (val) => {
            var _a;
            input.value.checked = val;
            if (props.validateEvent) {
              (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "change").catch((err) => debugWarn());
            }
          });
          const handleChange = () => {
            const val = checked.value ? props.inactiveValue : props.activeValue;
            emit(UPDATE_MODEL_EVENT, val);
            emit(CHANGE_EVENT, val);
            emit(INPUT_EVENT, val);
            nextTick(() => {
              input.value.checked = checked.value;
            });
          };
          const switchValue = () => {
            if (switchDisabled.value)
              return;
            const { beforeChange } = props;
            if (!beforeChange) {
              handleChange();
              return;
            }
            const shouldChange = beforeChange();
            const isPromiseOrBool = [
              isPromise(shouldChange),
              isBoolean(shouldChange)
            ].includes(true);
            if (!isPromiseOrBool) {
              throwError(COMPONENT_NAME$1, "beforeChange must return type `Promise<boolean>` or `boolean`");
            }
            if (isPromise(shouldChange)) {
              shouldChange.then((result) => {
                if (result) {
                  handleChange();
                }
              }).catch((e) => {
              });
            } else if (shouldChange) {
              handleChange();
            }
          };
          const focus = () => {
            var _a, _b;
            (_b = (_a = input.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
          };
          onMounted(() => {
            input.value.checked = checked.value;
          });
          expose({
            focus,
            checked
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(switchKls)),
              onClick: withModifiers(switchValue, ["prevent"])
            }, [
              createElementVNode("input", {
                id: unref(inputId),
                ref_key: "input",
                ref: input,
                class: normalizeClass(unref(ns).e("input")),
                type: "checkbox",
                role: "switch",
                "aria-checked": unref(checked),
                "aria-disabled": unref(switchDisabled),
                "aria-label": _ctx.label,
                name: _ctx.name,
                "true-value": _ctx.activeValue,
                "false-value": _ctx.inactiveValue,
                disabled: unref(switchDisabled),
                tabindex: _ctx.tabindex,
                onChange: handleChange,
                onKeydown: withKeys(switchValue, ["enter"])
              }, null, 42, _hoisted_2$c),
              !_ctx.inlinePrompt && (_ctx.inactiveIcon || _ctx.inactiveText) ? (openBlock(), createElementBlock("span", {
                key: 0,
                class: normalizeClass(unref(labelLeftKls))
              }, [
                _ctx.inactiveIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.inactiveIcon)))
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                !_ctx.inactiveIcon && _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  "aria-hidden": unref(checked)
                }, toDisplayString(_ctx.inactiveText), 9, _hoisted_3$9)) : createCommentVNode("v-if", true)
              ], 2)) : createCommentVNode("v-if", true),
              createElementVNode("span", {
                ref_key: "core",
                ref: core,
                class: normalizeClass(unref(ns).e("core")),
                style: normalizeStyle(unref(coreStyle))
              }, [
                _ctx.inlinePrompt ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ns).e("inner"))
                }, [
                  _ctx.activeIcon || _ctx.inactiveIcon ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(ns).is("icon"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(checked) ? _ctx.activeIcon : _ctx.inactiveIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : _ctx.activeText || _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
                    key: 1,
                    class: normalizeClass(unref(ns).is("text")),
                    "aria-hidden": !unref(checked)
                  }, toDisplayString(unref(checked) ? _ctx.activeText : _ctx.inactiveText), 11, _hoisted_4$6)) : createCommentVNode("v-if", true)
                ], 2)) : createCommentVNode("v-if", true),
                createElementVNode("div", {
                  class: normalizeClass(unref(ns).e("action"))
                }, [
                  _ctx.loading ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(ns).is("loading"))
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(loading_default))
                    ]),
                    _: 1
                  }, 8, ["class"])) : unref(checked) ? renderSlot(_ctx.$slots, "active-action", { key: 1 }, () => [
                    _ctx.activeActionIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.activeActionIcon)))
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true)
                  ]) : !unref(checked) ? renderSlot(_ctx.$slots, "inactive-action", { key: 2 }, () => [
                    _ctx.inactiveActionIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.inactiveActionIcon)))
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true)
                  ]) : createCommentVNode("v-if", true)
                ], 2)
              ], 6),
              !_ctx.inlinePrompt && (_ctx.activeIcon || _ctx.activeText) ? (openBlock(), createElementBlock("span", {
                key: 1,
                class: normalizeClass(unref(labelRightKls))
              }, [
                _ctx.activeIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.activeIcon)))
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                !_ctx.activeIcon && _ctx.activeText ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  "aria-hidden": !unref(checked)
                }, toDisplayString(_ctx.activeText), 9, _hoisted_5$5)) : createCommentVNode("v-if", true)
              ], 2)) : createCommentVNode("v-if", true)
            ], 10, _hoisted_1$e);
          };
        }
      });
      var Switch = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["__file", "switch.vue"]]);
      const ElSwitch = withInstall(Switch);
      const uploadContextKey = Symbol("uploadContextKey");
      const SCOPE$1 = "ElUpload";
      class UploadAjaxError extends Error {
        constructor(message, status, method4, url2) {
          super(message);
          this.name = "UploadAjaxError";
          this.status = status;
          this.method = method4;
          this.url = url2;
        }
      }
      function getError(action, option, xhr) {
        let msg;
        if (xhr.response) {
          msg = `${xhr.response.error || xhr.response}`;
        } else if (xhr.responseText) {
          msg = `${xhr.responseText}`;
        } else {
          msg = `fail to ${option.method} ${action} ${xhr.status}`;
        }
        return new UploadAjaxError(msg, xhr.status, option.method, action);
      }
      function getBody(xhr) {
        const text = xhr.responseText || xhr.response;
        if (!text) {
          return text;
        }
        try {
          return JSON.parse(text);
        } catch (e) {
          return text;
        }
      }
      const ajaxUpload = (option) => {
        if (typeof XMLHttpRequest === "undefined")
          throwError(SCOPE$1, "XMLHttpRequest is undefined");
        const xhr = new XMLHttpRequest();
        const action = option.action;
        if (xhr.upload) {
          xhr.upload.addEventListener("progress", (evt) => {
            const progressEvt = evt;
            progressEvt.percent = evt.total > 0 ? evt.loaded / evt.total * 100 : 0;
            option.onProgress(progressEvt);
          });
        }
        const formData = new FormData();
        if (option.data) {
          for (const [key, value] of Object.entries(option.data)) {
            if (isArray$1(value) && value.length)
              formData.append(key, ...value);
            else
              formData.append(key, value);
          }
        }
        formData.append(option.filename, option.file, option.file.name);
        xhr.addEventListener("error", () => {
          option.onError(getError(action, option, xhr));
        });
        xhr.addEventListener("load", () => {
          if (xhr.status < 200 || xhr.status >= 300) {
            return option.onError(getError(action, option, xhr));
          }
          option.onSuccess(getBody(xhr));
        });
        xhr.open(option.method, action, true);
        if (option.withCredentials && "withCredentials" in xhr) {
          xhr.withCredentials = true;
        }
        const headers = option.headers || {};
        if (headers instanceof Headers) {
          headers.forEach((value, key) => xhr.setRequestHeader(key, value));
        } else {
          for (const [key, value] of Object.entries(headers)) {
            if (isNil(value))
              continue;
            xhr.setRequestHeader(key, String(value));
          }
        }
        xhr.send(formData);
        return xhr;
      };
      const uploadListTypes = ["text", "picture", "picture-card"];
      let fileId = 1;
      const genFileId = () => Date.now() + fileId++;
      const uploadBaseProps = buildProps({
        action: {
          type: String,
          default: "#"
        },
        headers: {
          type: definePropType(Object)
        },
        method: {
          type: String,
          default: "post"
        },
        data: {
          type: definePropType([Object, Function, Promise]),
          default: () => mutable({})
        },
        multiple: {
          type: Boolean,
          default: false
        },
        name: {
          type: String,
          default: "file"
        },
        drag: {
          type: Boolean,
          default: false
        },
        withCredentials: Boolean,
        showFileList: {
          type: Boolean,
          default: true
        },
        accept: {
          type: String,
          default: ""
        },
        fileList: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        autoUpload: {
          type: Boolean,
          default: true
        },
        listType: {
          type: String,
          values: uploadListTypes,
          default: "text"
        },
        httpRequest: {
          type: definePropType(Function),
          default: ajaxUpload
        },
        disabled: Boolean,
        limit: Number
      });
      const uploadProps = buildProps({
        ...uploadBaseProps,
        beforeUpload: {
          type: definePropType(Function),
          default: NOOP
        },
        beforeRemove: {
          type: definePropType(Function)
        },
        onRemove: {
          type: definePropType(Function),
          default: NOOP
        },
        onChange: {
          type: definePropType(Function),
          default: NOOP
        },
        onPreview: {
          type: definePropType(Function),
          default: NOOP
        },
        onSuccess: {
          type: definePropType(Function),
          default: NOOP
        },
        onProgress: {
          type: definePropType(Function),
          default: NOOP
        },
        onError: {
          type: definePropType(Function),
          default: NOOP
        },
        onExceed: {
          type: definePropType(Function),
          default: NOOP
        },
        crossorigin: {
          type: definePropType(String)
        }
      });
      const uploadListProps = buildProps({
        files: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        disabled: {
          type: Boolean,
          default: false
        },
        handlePreview: {
          type: definePropType(Function),
          default: NOOP
        },
        listType: {
          type: String,
          values: uploadListTypes,
          default: "text"
        },
        crossorigin: {
          type: definePropType(String)
        }
      });
      const uploadListEmits = {
        remove: (file) => !!file
      };
      const _hoisted_1$d = ["onKeydown"];
      const _hoisted_2$b = ["src", "crossorigin"];
      const _hoisted_3$8 = ["onClick"];
      const _hoisted_4$5 = ["title"];
      const _hoisted_5$4 = ["onClick"];
      const _hoisted_6$4 = ["onClick"];
      const __default__$3 = defineComponent({
        name: "ElUploadList"
      });
      const _sfc_main$g = /* @__PURE__ */ defineComponent({
        ...__default__$3,
        props: uploadListProps,
        emits: uploadListEmits,
        setup(__props, { emit }) {
          const props = __props;
          const { t } = useLocale();
          const nsUpload = useNamespace("upload");
          const nsIcon = useNamespace("icon");
          const nsList = useNamespace("list");
          const disabled = useFormDisabled();
          const focusing = ref(false);
          const containerKls = computed(() => [
            nsUpload.b("list"),
            nsUpload.bm("list", props.listType),
            nsUpload.is("disabled", props.disabled)
          ]);
          const handleRemove = (file) => {
            emit("remove", file);
          };
          return (_ctx, _cache) => {
            return openBlock(), createBlock(TransitionGroup, {
              tag: "ul",
              class: normalizeClass(unref(containerKls)),
              name: unref(nsList).b()
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.files, (file) => {
                  return openBlock(), createElementBlock("li", {
                    key: file.uid || file.name,
                    class: normalizeClass([
                      unref(nsUpload).be("list", "item"),
                      unref(nsUpload).is(file.status),
                      { focusing: focusing.value }
                    ]),
                    tabindex: "0",
                    onKeydown: withKeys(($event) => !unref(disabled) && handleRemove(file), ["delete"]),
                    onFocus: _cache[0] || (_cache[0] = ($event) => focusing.value = true),
                    onBlur: _cache[1] || (_cache[1] = ($event) => focusing.value = false),
                    onClick: _cache[2] || (_cache[2] = ($event) => focusing.value = false)
                  }, [
                    renderSlot(_ctx.$slots, "default", { file }, () => [
                      _ctx.listType === "picture" || file.status !== "uploading" && _ctx.listType === "picture-card" ? (openBlock(), createElementBlock("img", {
                        key: 0,
                        class: normalizeClass(unref(nsUpload).be("list", "item-thumbnail")),
                        src: file.url,
                        crossorigin: _ctx.crossorigin,
                        alt: ""
                      }, null, 10, _hoisted_2$b)) : createCommentVNode("v-if", true),
                      file.status === "uploading" || _ctx.listType !== "picture-card" ? (openBlock(), createElementBlock("div", {
                        key: 1,
                        class: normalizeClass(unref(nsUpload).be("list", "item-info"))
                      }, [
                        createElementVNode("a", {
                          class: normalizeClass(unref(nsUpload).be("list", "item-name")),
                          onClick: withModifiers(($event) => _ctx.handlePreview(file), ["prevent"])
                        }, [
                          createVNode(unref(ElIcon), {
                            class: normalizeClass(unref(nsIcon).m("document"))
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(document_default))
                            ]),
                            _: 1
                          }, 8, ["class"]),
                          createElementVNode("span", {
                            class: normalizeClass(unref(nsUpload).be("list", "item-file-name")),
                            title: file.name
                          }, toDisplayString(file.name), 11, _hoisted_4$5)
                        ], 10, _hoisted_3$8),
                        file.status === "uploading" ? (openBlock(), createBlock(unref(ElProgress), {
                          key: 0,
                          type: _ctx.listType === "picture-card" ? "circle" : "line",
                          "stroke-width": _ctx.listType === "picture-card" ? 6 : 2,
                          percentage: Number(file.percentage),
                          style: normalizeStyle(_ctx.listType === "picture-card" ? "" : "margin-top: 0.5rem")
                        }, null, 8, ["type", "stroke-width", "percentage", "style"])) : createCommentVNode("v-if", true)
                      ], 2)) : createCommentVNode("v-if", true),
                      createElementVNode("label", {
                        class: normalizeClass(unref(nsUpload).be("list", "item-status-label"))
                      }, [
                        _ctx.listType === "text" ? (openBlock(), createBlock(unref(ElIcon), {
                          key: 0,
                          class: normalizeClass([unref(nsIcon).m("upload-success"), unref(nsIcon).m("circle-check")])
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(circle_check_default))
                          ]),
                          _: 1
                        }, 8, ["class"])) : ["picture-card", "picture"].includes(_ctx.listType) ? (openBlock(), createBlock(unref(ElIcon), {
                          key: 1,
                          class: normalizeClass([unref(nsIcon).m("upload-success"), unref(nsIcon).m("check")])
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(check_default))
                          ]),
                          _: 1
                        }, 8, ["class"])) : createCommentVNode("v-if", true)
                      ], 2),
                      !unref(disabled) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 2,
                        class: normalizeClass(unref(nsIcon).m("close")),
                        onClick: ($event) => handleRemove(file)
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(close_default))
                        ]),
                        _: 2
                      }, 1032, ["class", "onClick"])) : createCommentVNode("v-if", true),
                      createCommentVNode(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
                      createCommentVNode(" This is a bug which needs to be fixed "),
                      createCommentVNode(" TODO: Fix the incorrect navigation interaction "),
                      !unref(disabled) ? (openBlock(), createElementBlock("i", {
                        key: 3,
                        class: normalizeClass(unref(nsIcon).m("close-tip"))
                      }, toDisplayString(unref(t)("el.upload.deleteTip")), 3)) : createCommentVNode("v-if", true),
                      _ctx.listType === "picture-card" ? (openBlock(), createElementBlock("span", {
                        key: 4,
                        class: normalizeClass(unref(nsUpload).be("list", "item-actions"))
                      }, [
                        createElementVNode("span", {
                          class: normalizeClass(unref(nsUpload).be("list", "item-preview")),
                          onClick: ($event) => _ctx.handlePreview(file)
                        }, [
                          createVNode(unref(ElIcon), {
                            class: normalizeClass(unref(nsIcon).m("zoom-in"))
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(zoom_in_default))
                            ]),
                            _: 1
                          }, 8, ["class"])
                        ], 10, _hoisted_5$4),
                        !unref(disabled) ? (openBlock(), createElementBlock("span", {
                          key: 0,
                          class: normalizeClass(unref(nsUpload).be("list", "item-delete")),
                          onClick: ($event) => handleRemove(file)
                        }, [
                          createVNode(unref(ElIcon), {
                            class: normalizeClass(unref(nsIcon).m("delete"))
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(delete_default))
                            ]),
                            _: 1
                          }, 8, ["class"])
                        ], 10, _hoisted_6$4)) : createCommentVNode("v-if", true)
                      ], 2)) : createCommentVNode("v-if", true)
                    ])
                  ], 42, _hoisted_1$d);
                }), 128)),
                renderSlot(_ctx.$slots, "append")
              ]),
              _: 3
            }, 8, ["class", "name"]);
          };
        }
      });
      var UploadList = /* @__PURE__ */ _export_sfc$1(_sfc_main$g, [["__file", "upload-list.vue"]]);
      const uploadDraggerProps = buildProps({
        disabled: {
          type: Boolean,
          default: false
        }
      });
      const uploadDraggerEmits = {
        file: (file) => isArray$1(file)
      };
      const _hoisted_1$c = ["onDrop", "onDragover"];
      const COMPONENT_NAME = "ElUploadDrag";
      const __default__$2 = defineComponent({
        name: COMPONENT_NAME
      });
      const _sfc_main$f = /* @__PURE__ */ defineComponent({
        ...__default__$2,
        props: uploadDraggerProps,
        emits: uploadDraggerEmits,
        setup(__props, { emit }) {
          const uploaderContext = inject(uploadContextKey);
          if (!uploaderContext) {
            throwError(COMPONENT_NAME, "usage: <el-upload><el-upload-dragger /></el-upload>");
          }
          const ns = useNamespace("upload");
          const dragover = ref(false);
          const disabled = useFormDisabled();
          const onDrop = (e) => {
            if (disabled.value)
              return;
            dragover.value = false;
            e.stopPropagation();
            const files = Array.from(e.dataTransfer.files);
            emit("file", files);
          };
          const onDragover = () => {
            if (!disabled.value)
              dragover.value = true;
          };
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([unref(ns).b("dragger"), unref(ns).is("dragover", dragover.value)]),
              onDrop: withModifiers(onDrop, ["prevent"]),
              onDragover: withModifiers(onDragover, ["prevent"]),
              onDragleave: _cache[0] || (_cache[0] = withModifiers(($event) => dragover.value = false, ["prevent"]))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 42, _hoisted_1$c);
          };
        }
      });
      var UploadDragger = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["__file", "upload-dragger.vue"]]);
      const uploadContentProps = buildProps({
        ...uploadBaseProps,
        beforeUpload: {
          type: definePropType(Function),
          default: NOOP
        },
        onRemove: {
          type: definePropType(Function),
          default: NOOP
        },
        onStart: {
          type: definePropType(Function),
          default: NOOP
        },
        onSuccess: {
          type: definePropType(Function),
          default: NOOP
        },
        onProgress: {
          type: definePropType(Function),
          default: NOOP
        },
        onError: {
          type: definePropType(Function),
          default: NOOP
        },
        onExceed: {
          type: definePropType(Function),
          default: NOOP
        }
      });
      const _hoisted_1$b = ["onKeydown"];
      const _hoisted_2$a = ["name", "multiple", "accept"];
      const __default__$1 = defineComponent({
        name: "ElUploadContent",
        inheritAttrs: false
      });
      const _sfc_main$e = /* @__PURE__ */ defineComponent({
        ...__default__$1,
        props: uploadContentProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("upload");
          const disabled = useFormDisabled();
          const requests = shallowRef({});
          const inputRef = shallowRef();
          const uploadFiles = (files) => {
            if (files.length === 0)
              return;
            const { autoUpload, limit, fileList, multiple, onStart, onExceed } = props;
            if (limit && fileList.length + files.length > limit) {
              onExceed(files, fileList);
              return;
            }
            if (!multiple) {
              files = files.slice(0, 1);
            }
            for (const file of files) {
              const rawFile = file;
              rawFile.uid = genFileId();
              onStart(rawFile);
              if (autoUpload)
                upload(rawFile);
            }
          };
          const upload = async (rawFile) => {
            inputRef.value.value = "";
            if (!props.beforeUpload) {
              return doUpload(rawFile);
            }
            let hookResult;
            let beforeData = {};
            try {
              const originData = props.data;
              const beforeUploadPromise = props.beforeUpload(rawFile);
              beforeData = isPlainObject$1(props.data) ? cloneDeep(props.data) : props.data;
              hookResult = await beforeUploadPromise;
              if (isPlainObject$1(props.data) && isEqual(originData, beforeData)) {
                beforeData = cloneDeep(props.data);
              }
            } catch (e) {
              hookResult = false;
            }
            if (hookResult === false) {
              props.onRemove(rawFile);
              return;
            }
            let file = rawFile;
            if (hookResult instanceof Blob) {
              if (hookResult instanceof File) {
                file = hookResult;
              } else {
                file = new File([hookResult], rawFile.name, {
                  type: rawFile.type
                });
              }
            }
            doUpload(Object.assign(file, {
              uid: rawFile.uid
            }), beforeData);
          };
          const resolveData = async (data, rawFile) => {
            if (isFunction$1(data)) {
              return data(rawFile);
            }
            return data;
          };
          const doUpload = async (rawFile, beforeData) => {
            const {
              headers,
              data,
              method: method4,
              withCredentials,
              name: filename,
              action,
              onProgress,
              onSuccess,
              onError,
              httpRequest
            } = props;
            try {
              beforeData = await resolveData(beforeData != null ? beforeData : data, rawFile);
            } catch (e) {
              props.onRemove(rawFile);
              return;
            }
            const { uid } = rawFile;
            const options = {
              headers: headers || {},
              withCredentials,
              file: rawFile,
              data: beforeData,
              method: method4,
              filename,
              action,
              onProgress: (evt) => {
                onProgress(evt, rawFile);
              },
              onSuccess: (res) => {
                onSuccess(res, rawFile);
                delete requests.value[uid];
              },
              onError: (err) => {
                onError(err, rawFile);
                delete requests.value[uid];
              }
            };
            const request2 = httpRequest(options);
            requests.value[uid] = request2;
            if (request2 instanceof Promise) {
              request2.then(options.onSuccess, options.onError);
            }
          };
          const handleChange = (e) => {
            const files = e.target.files;
            if (!files)
              return;
            uploadFiles(Array.from(files));
          };
          const handleClick = () => {
            if (!disabled.value) {
              inputRef.value.value = "";
              inputRef.value.click();
            }
          };
          const handleKeydown = () => {
            handleClick();
          };
          const abort = (file) => {
            const _reqs = entriesOf(requests.value).filter(file ? ([uid]) => String(file.uid) === uid : () => true);
            _reqs.forEach(([uid, req]) => {
              if (req instanceof XMLHttpRequest)
                req.abort();
              delete requests.value[uid];
            });
          };
          expose({
            abort,
            upload
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([unref(ns).b(), unref(ns).m(_ctx.listType), unref(ns).is("drag", _ctx.drag)]),
              tabindex: "0",
              onClick: handleClick,
              onKeydown: withKeys(withModifiers(handleKeydown, ["self"]), ["enter", "space"])
            }, [
              _ctx.drag ? (openBlock(), createBlock(UploadDragger, {
                key: 0,
                disabled: unref(disabled),
                onFile: uploadFiles
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["disabled"])) : renderSlot(_ctx.$slots, "default", { key: 1 }),
              createElementVNode("input", {
                ref_key: "inputRef",
                ref: inputRef,
                class: normalizeClass(unref(ns).e("input")),
                name: _ctx.name,
                multiple: _ctx.multiple,
                accept: _ctx.accept,
                type: "file",
                onChange: handleChange,
                onClick: _cache[0] || (_cache[0] = withModifiers(() => {
                }, ["stop"]))
              }, null, 42, _hoisted_2$a)
            ], 42, _hoisted_1$b);
          };
        }
      });
      var UploadContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["__file", "upload-content.vue"]]);
      const SCOPE = "ElUpload";
      const revokeFileObjectURL = (file) => {
        var _a;
        if ((_a = file.url) == null ? void 0 : _a.startsWith("blob:")) {
          URL.revokeObjectURL(file.url);
        }
      };
      const useHandlers = (props, uploadRef) => {
        const uploadFiles = useVModel(props, "fileList", void 0, { passive: true });
        const getFile = (rawFile) => uploadFiles.value.find((file) => file.uid === rawFile.uid);
        function abort(file) {
          var _a;
          (_a = uploadRef.value) == null ? void 0 : _a.abort(file);
        }
        function clearFiles(states = ["ready", "uploading", "success", "fail"]) {
          uploadFiles.value = uploadFiles.value.filter((row) => !states.includes(row.status));
        }
        const handleError = (err, rawFile) => {
          const file = getFile(rawFile);
          if (!file)
            return;
          console.error(err);
          file.status = "fail";
          uploadFiles.value.splice(uploadFiles.value.indexOf(file), 1);
          props.onError(err, file, uploadFiles.value);
          props.onChange(file, uploadFiles.value);
        };
        const handleProgress = (evt, rawFile) => {
          const file = getFile(rawFile);
          if (!file)
            return;
          props.onProgress(evt, file, uploadFiles.value);
          file.status = "uploading";
          file.percentage = Math.round(evt.percent);
        };
        const handleSuccess = (response, rawFile) => {
          const file = getFile(rawFile);
          if (!file)
            return;
          file.status = "success";
          file.response = response;
          props.onSuccess(response, file, uploadFiles.value);
          props.onChange(file, uploadFiles.value);
        };
        const handleStart = (file) => {
          if (isNil(file.uid))
            file.uid = genFileId();
          const uploadFile = {
            name: file.name,
            percentage: 0,
            status: "ready",
            size: file.size,
            raw: file,
            uid: file.uid
          };
          if (props.listType === "picture-card" || props.listType === "picture") {
            try {
              uploadFile.url = URL.createObjectURL(file);
            } catch (err) {
              debugWarn(SCOPE, err.message);
              props.onError(err, uploadFile, uploadFiles.value);
            }
          }
          uploadFiles.value = [...uploadFiles.value, uploadFile];
          props.onChange(uploadFile, uploadFiles.value);
        };
        const handleRemove = async (file) => {
          const uploadFile = file instanceof File ? getFile(file) : file;
          if (!uploadFile)
            throwError(SCOPE, "file to be removed not found");
          const doRemove = (file2) => {
            abort(file2);
            const fileList = uploadFiles.value;
            fileList.splice(fileList.indexOf(file2), 1);
            props.onRemove(file2, fileList);
            revokeFileObjectURL(file2);
          };
          if (props.beforeRemove) {
            const before = await props.beforeRemove(uploadFile, uploadFiles.value);
            if (before !== false)
              doRemove(uploadFile);
          } else {
            doRemove(uploadFile);
          }
        };
        function submit() {
          uploadFiles.value.filter(({ status }) => status === "ready").forEach(({ raw }) => {
            var _a;
            return raw && ((_a = uploadRef.value) == null ? void 0 : _a.upload(raw));
          });
        }
        watch(() => props.listType, (val) => {
          if (val !== "picture-card" && val !== "picture") {
            return;
          }
          uploadFiles.value = uploadFiles.value.map((file) => {
            const { raw, url: url2 } = file;
            if (!url2 && raw) {
              try {
                file.url = URL.createObjectURL(raw);
              } catch (err) {
                props.onError(err, file, uploadFiles.value);
              }
            }
            return file;
          });
        });
        watch(uploadFiles, (files) => {
          for (const file of files) {
            file.uid || (file.uid = genFileId());
            file.status || (file.status = "success");
          }
        }, { immediate: true, deep: true });
        return {
          uploadFiles,
          abort,
          clearFiles,
          handleError,
          handleProgress,
          handleStart,
          handleSuccess,
          handleRemove,
          submit,
          revokeFileObjectURL
        };
      };
      const __default__ = defineComponent({
        name: "ElUpload"
      });
      const _sfc_main$d = /* @__PURE__ */ defineComponent({
        ...__default__,
        props: uploadProps,
        setup(__props, { expose }) {
          const props = __props;
          const disabled = useFormDisabled();
          const uploadRef = shallowRef();
          const {
            abort,
            submit,
            clearFiles,
            uploadFiles,
            handleStart,
            handleError,
            handleRemove,
            handleSuccess,
            handleProgress,
            revokeFileObjectURL: revokeFileObjectURL2
          } = useHandlers(props, uploadRef);
          const isPictureCard = computed(() => props.listType === "picture-card");
          const uploadContentProps2 = computed(() => ({
            ...props,
            fileList: uploadFiles.value,
            onStart: handleStart,
            onProgress: handleProgress,
            onSuccess: handleSuccess,
            onError: handleError,
            onRemove: handleRemove
          }));
          onBeforeUnmount(() => {
            uploadFiles.value.forEach(revokeFileObjectURL2);
          });
          provide(uploadContextKey, {
            accept: toRef(props, "accept")
          });
          expose({
            abort,
            submit,
            clearFiles,
            handleStart,
            handleRemove
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", null, [
              unref(isPictureCard) && _ctx.showFileList ? (openBlock(), createBlock(UploadList, {
                key: 0,
                disabled: unref(disabled),
                "list-type": _ctx.listType,
                files: unref(uploadFiles),
                crossorigin: _ctx.crossorigin,
                "handle-preview": _ctx.onPreview,
                onRemove: unref(handleRemove)
              }, createSlots({
                append: withCtx(() => [
                  createVNode(UploadContent, mergeProps({
                    ref_key: "uploadRef",
                    ref: uploadRef
                  }, unref(uploadContentProps2)), {
                    default: withCtx(() => [
                      _ctx.$slots.trigger ? renderSlot(_ctx.$slots, "trigger", { key: 0 }) : createCommentVNode("v-if", true),
                      !_ctx.$slots.trigger && _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 1 }) : createCommentVNode("v-if", true)
                    ]),
                    _: 3
                  }, 16)
                ]),
                _: 2
              }, [
                _ctx.$slots.file ? {
                  name: "default",
                  fn: withCtx(({ file }) => [
                    renderSlot(_ctx.$slots, "file", { file })
                  ])
                } : void 0
              ]), 1032, ["disabled", "list-type", "files", "crossorigin", "handle-preview", "onRemove"])) : createCommentVNode("v-if", true),
              !unref(isPictureCard) || unref(isPictureCard) && !_ctx.showFileList ? (openBlock(), createBlock(UploadContent, mergeProps({
                key: 1,
                ref_key: "uploadRef",
                ref: uploadRef
              }, unref(uploadContentProps2)), {
                default: withCtx(() => [
                  _ctx.$slots.trigger ? renderSlot(_ctx.$slots, "trigger", { key: 0 }) : createCommentVNode("v-if", true),
                  !_ctx.$slots.trigger && _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 1 }) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 16)) : createCommentVNode("v-if", true),
              _ctx.$slots.trigger ? renderSlot(_ctx.$slots, "default", { key: 2 }) : createCommentVNode("v-if", true),
              renderSlot(_ctx.$slots, "tip"),
              !unref(isPictureCard) && _ctx.showFileList ? (openBlock(), createBlock(UploadList, {
                key: 3,
                disabled: unref(disabled),
                "list-type": _ctx.listType,
                files: unref(uploadFiles),
                crossorigin: _ctx.crossorigin,
                "handle-preview": _ctx.onPreview,
                onRemove: unref(handleRemove)
              }, createSlots({ _: 2 }, [
                _ctx.$slots.file ? {
                  name: "default",
                  fn: withCtx(({ file }) => [
                    renderSlot(_ctx.$slots, "file", { file })
                  ])
                } : void 0
              ]), 1032, ["disabled", "list-type", "files", "crossorigin", "handle-preview", "onRemove"])) : createCommentVNode("v-if", true)
            ]);
          };
        }
      });
      var Upload$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$d, [["__file", "upload.vue"]]);
      const ElUpload = withInstall(Upload$1);
      function createLoadingComponent(options) {
        let afterLeaveTimer;
        const afterLeaveFlag = ref(false);
        const data = reactive({
          ...options,
          originalPosition: "",
          originalOverflow: "",
          visible: false
        });
        function setText(text) {
          data.text = text;
        }
        function destroySelf() {
          const target = data.parent;
          const ns = vm.ns;
          if (!target.vLoadingAddClassList) {
            let loadingNumber = target.getAttribute("loading-number");
            loadingNumber = Number.parseInt(loadingNumber) - 1;
            if (!loadingNumber) {
              removeClass(target, ns.bm("parent", "relative"));
              target.removeAttribute("loading-number");
            } else {
              target.setAttribute("loading-number", loadingNumber.toString());
            }
            removeClass(target, ns.bm("parent", "hidden"));
          }
          removeElLoadingChild();
          loadingInstance.unmount();
        }
        function removeElLoadingChild() {
          var _a, _b;
          (_b = (_a = vm.$el) == null ? void 0 : _a.parentNode) == null ? void 0 : _b.removeChild(vm.$el);
        }
        function close() {
          var _a;
          if (options.beforeClose && !options.beforeClose())
            return;
          afterLeaveFlag.value = true;
          clearTimeout(afterLeaveTimer);
          afterLeaveTimer = window.setTimeout(handleAfterLeave, 400);
          data.visible = false;
          (_a = options.closed) == null ? void 0 : _a.call(options);
        }
        function handleAfterLeave() {
          if (!afterLeaveFlag.value)
            return;
          const target = data.parent;
          afterLeaveFlag.value = false;
          target.vLoadingAddClassList = void 0;
          destroySelf();
        }
        const elLoadingComponent = defineComponent({
          name: "ElLoading",
          setup(_, { expose }) {
            const { ns, zIndex } = useGlobalComponentSettings("loading");
            expose({
              ns,
              zIndex
            });
            return () => {
              const svg = data.spinner || data.svg;
              const spinner = h("svg", {
                class: "circular",
                viewBox: data.svgViewBox ? data.svgViewBox : "0 0 50 50",
                ...svg ? { innerHTML: svg } : {}
              }, [
                h("circle", {
                  class: "path",
                  cx: "25",
                  cy: "25",
                  r: "20",
                  fill: "none"
                })
              ]);
              const spinnerText = data.text ? h("p", { class: ns.b("text") }, [data.text]) : void 0;
              return h(Transition, {
                name: ns.b("fade"),
                onAfterLeave: handleAfterLeave
              }, {
                default: withCtx(() => [
                  withDirectives(createVNode("div", {
                    style: {
                      backgroundColor: data.background || ""
                    },
                    class: [
                      ns.b("mask"),
                      data.customClass,
                      data.fullscreen ? "is-fullscreen" : ""
                    ]
                  }, [
                    h("div", {
                      class: ns.b("spinner")
                    }, [spinner, spinnerText])
                  ]), [[vShow, data.visible]])
                ])
              });
            };
          }
        });
        const loadingInstance = createApp(elLoadingComponent);
        const vm = loadingInstance.mount(document.createElement("div"));
        return {
          ...toRefs(data),
          setText,
          removeElLoadingChild,
          close,
          handleAfterLeave,
          vm,
          get $el() {
            return vm.$el;
          }
        };
      }
      let fullscreenInstance = void 0;
      const Loading = function(options = {}) {
        if (!isClient)
          return void 0;
        const resolved = resolveOptions(options);
        if (resolved.fullscreen && fullscreenInstance) {
          return fullscreenInstance;
        }
        const instance = createLoadingComponent({
          ...resolved,
          closed: () => {
            var _a;
            (_a = resolved.closed) == null ? void 0 : _a.call(resolved);
            if (resolved.fullscreen)
              fullscreenInstance = void 0;
          }
        });
        addStyle(resolved, resolved.parent, instance);
        addClassList(resolved, resolved.parent, instance);
        resolved.parent.vLoadingAddClassList = () => addClassList(resolved, resolved.parent, instance);
        let loadingNumber = resolved.parent.getAttribute("loading-number");
        if (!loadingNumber) {
          loadingNumber = "1";
        } else {
          loadingNumber = `${Number.parseInt(loadingNumber) + 1}`;
        }
        resolved.parent.setAttribute("loading-number", loadingNumber);
        resolved.parent.appendChild(instance.$el);
        nextTick(() => instance.visible.value = resolved.visible);
        if (resolved.fullscreen) {
          fullscreenInstance = instance;
        }
        return instance;
      };
      const resolveOptions = (options) => {
        var _a, _b, _c, _d;
        let target;
        if (isString(options.target)) {
          target = (_a = document.querySelector(options.target)) != null ? _a : document.body;
        } else {
          target = options.target || document.body;
        }
        return {
          parent: target === document.body || options.body ? document.body : target,
          background: options.background || "",
          svg: options.svg || "",
          svgViewBox: options.svgViewBox || "",
          spinner: options.spinner || false,
          text: options.text || "",
          fullscreen: target === document.body && ((_b = options.fullscreen) != null ? _b : true),
          lock: (_c = options.lock) != null ? _c : false,
          customClass: options.customClass || "",
          visible: (_d = options.visible) != null ? _d : true,
          target
        };
      };
      const addStyle = async (options, parent, instance) => {
        const { nextZIndex } = instance.vm.zIndex || instance.vm._.exposed.zIndex;
        const maskStyle = {};
        if (options.fullscreen) {
          instance.originalPosition.value = getStyle(document.body, "position");
          instance.originalOverflow.value = getStyle(document.body, "overflow");
          maskStyle.zIndex = nextZIndex();
        } else if (options.parent === document.body) {
          instance.originalPosition.value = getStyle(document.body, "position");
          await nextTick();
          for (const property of ["top", "left"]) {
            const scroll = property === "top" ? "scrollTop" : "scrollLeft";
            maskStyle[property] = `${options.target.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll] - Number.parseInt(getStyle(document.body, `margin-${property}`), 10)}px`;
          }
          for (const property of ["height", "width"]) {
            maskStyle[property] = `${options.target.getBoundingClientRect()[property]}px`;
          }
        } else {
          instance.originalPosition.value = getStyle(parent, "position");
        }
        for (const [key, value] of Object.entries(maskStyle)) {
          instance.$el.style[key] = value;
        }
      };
      const addClassList = (options, parent, instance) => {
        const ns = instance.vm.ns || instance.vm._.exposed.ns;
        if (!["absolute", "fixed", "sticky"].includes(instance.originalPosition.value)) {
          addClass(parent, ns.bm("parent", "relative"));
        } else {
          removeClass(parent, ns.bm("parent", "relative"));
        }
        if (options.fullscreen && options.lock) {
          addClass(parent, ns.bm("parent", "hidden"));
        } else {
          removeClass(parent, ns.bm("parent", "hidden"));
        }
      };
      const INSTANCE_KEY = Symbol("ElLoading");
      const createInstance = (el, binding) => {
        var _a, _b, _c, _d;
        const vm = binding.instance;
        const getBindingProp = (key) => isObject$1(binding.value) ? binding.value[key] : void 0;
        const resolveExpression = (key) => {
          const data = isString(key) && (vm == null ? void 0 : vm[key]) || key;
          if (data)
            return ref(data);
          else
            return data;
        };
        const getProp2 = (name) => resolveExpression(getBindingProp(name) || el.getAttribute(`element-loading-${hyphenate(name)}`));
        const fullscreen = (_a = getBindingProp("fullscreen")) != null ? _a : binding.modifiers.fullscreen;
        const options = {
          text: getProp2("text"),
          svg: getProp2("svg"),
          svgViewBox: getProp2("svgViewBox"),
          spinner: getProp2("spinner"),
          background: getProp2("background"),
          customClass: getProp2("customClass"),
          fullscreen,
          target: (_b = getBindingProp("target")) != null ? _b : fullscreen ? void 0 : el,
          body: (_c = getBindingProp("body")) != null ? _c : binding.modifiers.body,
          lock: (_d = getBindingProp("lock")) != null ? _d : binding.modifiers.lock
        };
        el[INSTANCE_KEY] = {
          options,
          instance: Loading(options)
        };
      };
      const updateOptions = (newOptions, originalOptions) => {
        for (const key of Object.keys(originalOptions)) {
          if (isRef(originalOptions[key]))
            originalOptions[key].value = newOptions[key];
        }
      };
      const vLoading = {
        mounted(el, binding) {
          if (binding.value) {
            createInstance(el, binding);
          }
        },
        updated(el, binding) {
          const instance = el[INSTANCE_KEY];
          if (binding.oldValue !== binding.value) {
            if (binding.value && !binding.oldValue) {
              createInstance(el, binding);
            } else if (binding.value && binding.oldValue) {
              if (isObject$1(binding.value))
                updateOptions(binding.value, instance.options);
            } else {
              instance == null ? void 0 : instance.instance.close();
            }
          }
        },
        unmounted(el) {
          var _a;
          (_a = el[INSTANCE_KEY]) == null ? void 0 : _a.instance.close();
          el[INSTANCE_KEY] = null;
        }
      };
      const _sfc_main$c = {};
      const _hoisted_1$a = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      };
      const _hoisted_2$9 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "m64 448 832-320-128 704-446.08-243.328L832 192 242.816 545.472zm256 512V657.024L512 768z"
      }, null, -1);
      const _hoisted_3$7 = [
        _hoisted_2$9
      ];
      function _sfc_render$3(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$a, _hoisted_3$7);
      }
      const Promotion = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$3]]);
      const _sfc_main$b = {};
      const _hoisted_1$9 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      };
      const _hoisted_2$8 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64m384-578.304V704h-64V247.296L237.248 490.048 192 444.8 508.8 128l316.8 316.8-45.312 45.248z"
      }, null, -1);
      const _hoisted_3$6 = [
        _hoisted_2$8
      ];
      function _sfc_render$2(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$9, _hoisted_3$6);
      }
      const Upload = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$2]]);
      const _sfc_main$a = {};
      const _hoisted_1$8 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      };
      const _hoisted_2$7 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M864 409.6a192 192 0 0 1-37.888 349.44A256.064 256.064 0 0 1 576 960h-96a32 32 0 1 1 0-64h96a192.064 192.064 0 0 0 181.12-128H736a32 32 0 0 1-32-32V416a32 32 0 0 1 32-32h32c10.368 0 20.544.832 30.528 2.432a288 288 0 0 0-573.056 0A193.235 193.235 0 0 1 256 384h32a32 32 0 0 1 32 32v320a32 32 0 0 1-32 32h-32a192 192 0 0 1-96-358.4 352 352 0 0 1 704 0M256 448a128 128 0 1 0 0 256zm640 128a128 128 0 0 0-128-128v256a128 128 0 0 0 128-128"
      }, null, -1);
      const _hoisted_3$5 = [
        _hoisted_2$7
      ];
      function _sfc_render$1(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$8, _hoisted_3$5);
      }
      const Service = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$1]]);
      const _sfc_main$9 = {};
      const _hoisted_1$7 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      };
      const _hoisted_2$6 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M192 736h640V128H256a64 64 0 0 0-64 64zm64-672h608a32 32 0 0 1 32 32v672a32 32 0 0 1-32 32H160l-32 57.536V192A128 128 0 0 1 256 64"
      }, null, -1);
      const _hoisted_3$4 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M240 800a48 48 0 1 0 0 96h592v-96zm0-64h656v160a64 64 0 0 1-64 64H240a112 112 0 0 1 0-224m144-608v250.88l96-76.8 96 76.8V128zm-64-64h320v381.44a32 32 0 0 1-51.968 24.96L480 384l-108.032 86.4A32 32 0 0 1 320 445.44z"
      }, null, -1);
      const _hoisted_4$4 = [
        _hoisted_2$6,
        _hoisted_3$4
      ];
      function _sfc_render(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$7, _hoisted_4$4);
      }
      const Collection = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render]]);
      const _withScopeId$3 = (n) => (pushScopeId("data-v-13350d57"), n = n(), popScopeId(), n);
      const _hoisted_1$6 = { key: 0 };
      const _hoisted_2$5 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
      const _hoisted_3$3 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
      const _hoisted_4$3 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("p", { style: { "font-size": "15px" } }, "导入简历", -1));
      const _hoisted_5$3 = { style: { "font-size": "15px" } };
      const _hoisted_6$3 = { style: { "font-size": "15px" } };
      const _hoisted_7$3 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("span", null, "AI坐席 ", -1));
      const _hoisted_8$3 = { class: "fixed-stop-button" };
      const _hoisted_9$3 = { class: "push-records-container" };
      const _hoisted_10$3 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("div", { class: "push-records-header" }, [
        /* @__PURE__ */ createElementVNode("span", null, "实时投递记录")
      ], -1));
      const _hoisted_11$3 = { class: "push-records-content" };
      const _hoisted_12$1 = { class: "record-time" };
      const _hoisted_13$1 = {
        key: 0,
        class: "no-records"
      };
      const _hoisted_14$1 = { class: "my-header" };
      const _hoisted_15$1 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
      const _hoisted_16$1 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("h3", null, "我的功能列表", -1));
      const _hoisted_17 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
      const _hoisted_18 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
      const _hoisted_19 = {
        type: "info",
        style: { "margin-top": "10px" }
      };
      const _hoisted_20 = { key: 0 };
      const _hoisted_21 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
      const _hoisted_22 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
      const _hoisted_23 = { style: { "padding-top": "10px", "min-width": "8%" } };
      const _hoisted_24 = { class: "demonstration" };
      const _hoisted_25$1 = { class: "demonstration" };
      const _hoisted_26 = { class: "demonstration" };
      const _hoisted_27 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("div", { class: "image-slot" }, "加载订单二维码失败；请稍后刷新重试", -1));
      const _hoisted_28 = { style: { "width": "80%" } };
      const _hoisted_29 = { class: "demonstration" };
      const _sfc_main$8 = /* @__PURE__ */ defineComponent({
        __name: "AiJob",
        setup(__props) {
          const platform = inject("$platform");
          const axios$1 = inject("$axios");
          const pushStatus = ref(PushStatus.NOT_START);
          const pushBtnType = ref("primary");
          const pushBtnText = ref("开始投递");
          const aiSeatBuyVisible = ref(false);
          const importResumeLoading = ref(false);
          // const productListLoading = ref(false);
          const logRecorder = new LogRecorder();
          const latestPushRecords = ref([]);
          let recordsUpdateTimer = null;
          const buyProductList = ref([]);
          const showOtherProduct = ref(true);
          const orderGroup = ref([]);
          const payStatus = ref(false);
          const promotionCode = ref("");
          const lastPromotionCode = ref("");
          let loginStore = LoginStore();
          let pushResultCounter = pushResultCount();
          const userStore = UserStore();
          const updateLatestPushRecords = () => {
            const allLogs = logRecorder.getLogs(1, logRecorder.getLogCount());
            const pushLogs = allLogs.filter(
              (log) => log.message.toLowerCase().includes("投递") || log.message.toLowerCase().includes("下一页") || log.message.toLowerCase().includes("工作")
            );
            latestPushRecords.value = pushLogs.slice(-10);
          };
          const getRecordLevelClass = (level) => {
            switch (level.toLowerCase()) {
              case "error":
                return "record-error";
              case "warn":
                return "record-warn";
              case "info":
                return "record-info";
              case "debug":
                return "record-debug";
              case "trace":
                return "record-trace";
              default:
                return "record-info";
            }
          };
          const startRecordsUpdate = () => {
            if (recordsUpdateTimer) {
              clearInterval(recordsUpdateTimer);
            }
            updateLatestPushRecords();
            recordsUpdateTimer = setInterval(updateLatestPushRecords, 500);
          };
          const stopRecordsUpdate = () => {
            if (recordsUpdateTimer) {
              clearInterval(recordsUpdateTimer);
              recordsUpdateTimer = null;
            }
          };
          const isExpired = (row) => {
            const currentTime = /* @__PURE__ */ new Date();
            const endTime = new Date(row.periodOfValidityEndTime);
            return currentTime > endTime;
          };
          const randomStyle = () => {
            const tagStyleArr = ["primary", "warning", "success", "danger"];
            let number4 = Math.floor(Math.random() * 4);
            return tagStyleArr[number4];
          };
          const scrollToTop = () => {
            window.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          };
          const handlerImport = async () => {
            var _a, _b, _c, _d;
            if (!loginInterceptor()) {
              return;
            }
            const token = (_b = (_a = Tools.window) == null ? void 0 : _a._PAGE) == null ? void 0 : _b.token;
            let bossUserId = (_d = (_c = Tools.window) == null ? void 0 : _c._PAGE) == null ? void 0 : _d.uid;
            if (!bossUserId) {
              ElMessage({
                message: "未获取到Boss userId 请刷新页面重试",
                type: "error",
                duration: 3e3
              });
              return;
            }
            importResumeLoading.value = true;
            let resumeInfoResp = await axios.get("https://www.zhipin.com/wapi/zpgeek/resume/sidebar.json", { headers: { "Zp_token": token } });
            let zpData = resumeInfoResp.data.zpData;
            if (!zpData.attachmentList || zpData.attachmentList.length == 0) {
              importResumeLoading.value = false;
              ElMessage({
                message: "请先在BOSS个人中心上传附件简历；作为ai坐席定制化回复的基础",
                type: "error",
                duration: 3e3
              });
              return;
            }
            let resumeId = zpData.attachmentList[0].resumeId;
            let resumeFileResp = await fetchWithGM_request(
              "https://docdownload.zhipin.com/wflow/zpgeek/download/download4geek?resumeId=" + resumeId,
              { headers: { "Zp_token": token }, responseType: "arraybuffer" }
            );
            let fileBlob = new Blob([resumeFileResp.response], { type: "application/pdf" });
            let formData = new FormData();
            formData.append("file", fileBlob);
            formData.append("resumeId", resumeId);
            formData.append("uniqueId", bossUserId);
            let importResp = await axios$1.post("/api/user/import/resume", formData, { headers: { "Content-Type": "multipart/form-data" } });
            if (importResp.data.code != 200) {
              ElMessage({
                message: "导入简历失败" + importResp.data.data.msg,
                type: "error",
                duration: 3e3
              });
              importResumeLoading.value = false;
              return;
            }
            let loginResp = await axios$1.post("/api/user/silently/login?uniqueId=" + bossUserId);
            localStorage.setItem("Authorization", loginResp.data.data);
            if (!importResp.data.data.email) {
              ElMessage({
                message: "导入简历成功；但未识别到邮箱，请在偏好设置中完善[通知邮箱]",
                type: "warning",
                duration: 3e3
              });
              importResumeLoading.value = false;
              return;
            }
            ElMessage({
              message: "导入简历成功",
              type: "success",
              duration: 3e3
            });
            importResumeLoading.value = false;
          };
          const handlerPush = () => {
            switch (pushStatus.value) {
              case PushStatus.NOT_START:
                startPush();
                break;
              case PushStatus.PUSHING:
                pausePush();
                break;
              case PushStatus.PAUSE:
                startPush();
                break;
            }
          };
          const handlerFixedStopPush = () => {
            pausePush();
            scrollToTop();
          };
          const selfDefPushCountLimit = ref(platform.selfDefPushCountLimit);
          const selfDefPushCountLimitChange = (val) => {
            platform.selfDefPushCountLimit = val;
          };
          const mockPush = ref(false);
          const startPush = () => {
            if (!loginInterceptor()) {
              return;
            }
            platform.pushMock = mockPush.value;
            pushStatus.value = PushStatus.PUSHING;
            pushBtnType.value = "warning";
            pushBtnText.value = "停止投递";
            startRecordsUpdate();
            let pushResultPromise = platform.startPush();
            pushResultPromise.then(() => {
              ElMessage({
                message: "批量投递完成",
                type: "success",
                duration: 3e3
              });
              setTimeout(() => {
                pushStatus.value = PushStatus.PAUSE;
                pushBtnType.value = "primary";
                pushBtnText.value = "开始投递";
                stopRecordsUpdate();
              }, 200);
            });
          };
          const pausePush = () => {
            platform.pausePush();
            pushStatus.value = PushStatus.PAUSE;
            pushBtnType.value = "primary";
            pushBtnText.value = "开始投递";
            stopRecordsUpdate();
          };
          const handlerAISeatClick = async () => {
            aiSeatBuyVisible.value = true;
            if (buyProductList.value.length <= 0) {
              await queryBuyProductList();
            }
            showOtherProduct.value = false;
          };
          const queryBuyProductList = async () => {
            let productResp = await axios$1.post("/api/product/user/product/list");
            buyProductList.value = productResp.data.data;
          };
          const showOrderGroup = async () => {
            if (!loginInterceptor()) {
              return;
            }
            productListLoading.value = true;
            let promotionCodeVar = promotionCode.value.trim();
            promotionCode.value = "";
            setTimeout(() => {
              showOtherProduct.value = true;
            }, 100);
            if (orderGroup.value.length < 1 || promotionCodeVar !== lastPromotionCode.value) {
              let orderGroupResp = await axios$1.post("/api/pay/generate/order/group", { promotionCode: promotionCodeVar });
              if (orderGroupResp.data.code != 200) {
                ElMessage({
                  message: orderGroupResp.data.message,
                  type: "warning",
                  duration: 3e3
                });
                setTimeout(() => {
                  showOtherProduct.value = false;
                }, 100);
                productListLoading.value = false;
                return;
              }
              orderGroup.value = orderGroupResp.data.data;
              lastPromotionCode.value = promotionCodeVar;
              productListLoading.value = false;
            }
            productListLoading.value = false;
            waitUsePay();
          };
          const waitUsePay = () => {
            const sseClient = new SSEClient(axios$1.defaults.baseURL + "api/sse/connect");
            sseClient.addOnMsgCallback((event) => {
              let data = event.data;
              if (data === "支付成功") {
                payStatus.value = true;
                orderGroup.value = [];
                queryBuyProductList();
                showOtherProduct.value = false;
                firstAiSeatStatus.value = 0;
              }
            });
            sseClient.start();
            let count = 0;
            let interval = setInterval(() => {
              if (payStatus.value) {
                clearInterval(interval);
              }
              orderGroup.value.forEach((orderItem) => {
                axios$1.get("/api/pay/searchOrder?outTradeNo=" + orderItem.orderId).then((resp) => {
                  if (resp.data.data === "TRADE_SUCCESS") {
                    payStatus.value = true;
                    orderGroup.value = [];
                    clearInterval(interval);
                  }
                  if (resp.data.data === "WAIT_BUYER_PAY") {
                    logger$1.debug("等待支付");
                  }
                  count++;
                  if (count >= 10) {
                    logger$1.warn("订单超时未支付");
                    clearInterval(interval);
                  }
                });
              });
            }, 3e4);
          };
          const firstAiSeatStatus = ref(userStore.user.aiSeatStatus);
          setTimeout(() => {
            firstAiSeatStatus.value = userStore.user.aiSeatStatus;
            logger$1.info("firstAiSeatStatus", firstAiSeatStatus.value);
          }, 1500);
          const handlerAISeatStatusChange = async (val) => {
            if (firstAiSeatStatus.value == null) {
              return;
            }
            if (!loginInterceptor()) {
              return;
            }
            return axios$1.post("/api/user/save/preference", {
              aiSeatStatus: val ? 1 : 0
            }).then((resp) => {
              if (val && resp.data.message && resp.data.message !== "成功") {
                ElNotification({
                  message: resp.data.message,
                  type: "success",
                  duration: 2e3
                });
              }
            }).catch((_) => {
              userStore.user.aiSeatStatus = firstAiSeatStatus.value;
            });
          };
          if (!loginStore.login && !loginStore.loginFailStatus) {
            logger$1.info("页面静默登录");
            silentlyLogin("").catch((_) => {
            });
          }
          onUnmounted(() => {
            stopRecordsUpdate();
          });
          return (_ctx, _cache) => {
            const _component_el_text = ElText;
            const _component_el_input_number = ElInputNumber;
            const _component_el_switch = ElSwitch;
            const _component_el_button = ElButton;
            const _component_el_tooltip = ElTooltip;
            const _component_el_link = ElLink;
            const _component_el_icon = ElIcon;
            const _component_el_table_column = ElTableColumn;
            const _component_el_tag = ElTag;
            const _component_el_table = ElTable;
            const _component_el_input = ElInput;
            const _component_el_empty = ElEmpty;
            const _component_el_image = ElImage;
            const _component_el_dialog = ElDialog;
            const _directive_loading = vLoading;
            return openBlock(), createElementBlock(Fragment, null, [
              createVNode(_component_el_text, {
                size: "large",
                class: "mx-1",
                type: "primary"
              }, {
                default: withCtx(() => [
                  createTextVNode("投递成功：" + toDisplayString(unref(pushResultCounter).successCount) + "    ", 1)
                ]),
                _: 1
              }),
              createVNode(_component_el_text, {
                size: "large",
                class: "mx-1",
                type: "danger"
              }, {
                default: withCtx(() => [
                  createTextVNode(" 投递失败：" + toDisplayString(unref(pushResultCounter).failCount) + "    ", 1)
                ]),
                _: 1
              }),
              createVNode(_component_el_text, {
                size: "large",
                class: "mx-1"
              }, {
                default: withCtx(() => [
                  createTextVNode(" 单次投递限制数量：")
                ]),
                _: 1
              }),
              createVNode(_component_el_input_number, {
                modelValue: selfDefPushCountLimit.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selfDefPushCountLimit.value = $event),
                min: -1,
                max: 100,
                onChange: selfDefPushCountLimitChange
              }, null, 8, ["modelValue"]),
              !unref(isProdEnv)() ? (openBlock(), createElementBlock("span", _hoisted_1$6, [
                createTextVNode("    MOCK投递  "),
                createVNode(_component_el_switch, {
                  modelValue: mockPush.value,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => mockPush.value = $event)
                }, null, 8, ["modelValue"])
              ])) : createCommentVNode("", true),
              _hoisted_2$5,
              _hoisted_3$3,
              createVNode(_component_el_tooltip, {
                effect: "dark",
                "raw-content": "",
                content: "\r\n    在Boss中更新了附件简历后请重新导入<p/>\r\n    - 仅用于AI坐席定制化回复\r\n    ",
                placement: "bottom"
              }, {
                default: withCtx(() => [
                  createVNode(_component_el_button, {
                    icon: unref(Upload),
                    type: "primary",
                    onClick: handlerImport,
                    loading: importResumeLoading.value
                  }, {
                    default: withCtx(() => [
                      _hoisted_4$3
                    ]),
                    _: 1
                  }, 8, ["icon", "loading"])
                ]),
                _: 1
              }),
              createVNode(_component_el_tooltip, {
                effect: "dark",
                "raw-content": "",
                content: "\r\n    先通过Boss的筛选功能圈选你的意向岗位<p/><span style='color:red;'>在【偏好设置-投递设置】中选择</span><br/>您的投递偏好，用于精准投递岗位\r\n    ",
                placement: "bottom"
              }, {
                default: withCtx(() => [
                  createVNode(_component_el_button, {
                    icon: unref(Promotion),
                    type: pushBtnType.value,
                    onClick: handlerPush
                  }, {
                    default: withCtx(() => [
                      createElementVNode("p", _hoisted_5$3, toDisplayString(pushBtnText.value), 1)
                    ]),
                    _: 1
                  }, 8, ["icon", "type"])
                ]),
                _: 1
              }),
              createVNode(_component_el_button, {
                type: "warning",
                icon: unref(Collection),
                color: "#626aef",
                onClick: withModifiers(handlerAISeatClick, ["stop"])
              }, {
                default: withCtx(() => [
                  // createTextVNode("产品列表")
                ]),
                _: 1
              }, 8, ["icon"]),
              createVNode(_component_el_tooltip, {
                effect: "dark",
                "raw-content": "",
                content: "\r\n    AI坐席：<span style='color:red;'>支持试用，点击开关开启试用</span><br/>\r\n    - 自动响应hr的消息,根据您的简历信息进行定制化回答。<br/>\r\n    - 高意向职位邮件通知，快速筛选出最合适的职位。<br/>\r\n    - 快捷发送简历，交换 wx、联系方式。<br/>\r\n    - hr拒绝挽留，不放过每一个机会。<br/>\r\n    ",
                placement: "bottom"
              }, {
                default: withCtx(() => [
                  createVNode(_component_el_button, {
                    icon: unref(Service),
                    color: "#626aef"
                  }, {
                    default: withCtx(() => [
                      createElementVNode("p", _hoisted_6$3, [
                        _hoisted_7$3,
                        createVNode(_component_el_switch, {
                          "active-text": "开",
                          "inactive-text": "关",
                          "inline-prompt": "",
                          style: { "--el-switch-on-color": "#13ce66", "--el-switch-off-color": "#ff4949" },
                          modelValue: unref(userStore).user.aiSeatStatus,
                          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(userStore).user.aiSeatStatus = $event),
                          onChange: handlerAISeatStatusChange
                        }, null, 8, ["modelValue"])
                      ])
                    ]),
                    _: 1
                  }, 8, ["icon"])
                ]),
                _: 1
              }),
              createVNode(_component_el_link, {
                type: "primary",
                href: "https://www.bilibili.com/video/BV1y6PjesEvi",
                target: "_blank",
                style: { "margin-left": "10px", "margin-top": "10px" }
              }, {
                default: withCtx(() => [
                  createTextVNode("点击查看AI坐席效果演示")
                ]),
                _: 1
              }),
              withDirectives(createElementVNode("div", _hoisted_8$3, [
                createElementVNode("div", _hoisted_9$3, [
                  _hoisted_10$3,
                  createElementVNode("div", _hoisted_11$3, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(latestPushRecords.value, (record, index) => {
                      return openBlock(), createElementBlock("div", {
                        key: index,
                        class: "push-record-item"
                      }, [
                        createElementVNode("span", _hoisted_12$1, toDisplayString(record.timestamp), 1),
                        createElementVNode("span", {
                          class: normalizeClass(["record-message", getRecordLevelClass(record.level)])
                        }, toDisplayString(record.message), 3)
                      ]);
                    }), 128)),
                    latestPushRecords.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_13$1, " 暂无投递记录 ")) : createCommentVNode("", true)
                  ])
                ]),
                createVNode(_component_el_button, {
                  type: "warning",
                  size: "large",
                  onClick: handlerFixedStopPush
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_icon, null, {
                      default: withCtx(() => [
                        createVNode(unref(CircleCloseFilled))
                      ]),
                      _: 1
                    }),
                    createTextVNode(" 停止投递 ")
                  ]),
                  _: 1
                })
              ], 512), [
                [vShow, pushStatus.value === unref(PushStatus).PUSHING]
              ]),
              createVNode(_component_el_dialog, {
                modelValue: aiSeatBuyVisible.value,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => aiSeatBuyVisible.value = $event),
                "show-close": false,
                width: "800"
              }, {
                header: withCtx(({ close, titleId, titleClass }) => {
                  var _a;
                  return [
                    createElementVNode("div", _hoisted_14$1, [
                      createVNode(_component_el_text, {
                        size: "large",
                        style: { "font-size": "20px" },
                        type: "info"
                      }, {
                        default: withCtx(() => [
                          // createTextVNode("产品列表")
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_button, {
                        type: "warning",
                        onClick: close
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_icon, { class: "el-icon--left" }, {
                            default: withCtx(() => [
                              createVNode(unref(CircleCloseFilled))
                            ]),
                            _: 1
                          }),
                          createTextVNode(" 关闭 ")
                        ]),
                        _: 2
                      }, 1032, ["onClick"])
                    ]),
                    withDirectives(createElementVNode("div", null, [
                      _hoisted_15$1,
                      _hoisted_16$1,
                      _hoisted_17,
                      withDirectives(createVNode(_component_el_table, {
                        data: buyProductList.value,
                        stripe: "",
                        style: { "width": "100%" }
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_table_column, {
                            prop: "productName",
                            label: "产品",
                            width: "180"
                          }, {
                            default: withCtx(({ row }) => [
                              createElementVNode("span", {
                                style: normalizeStyle({ textDecoration: isExpired(row) ? "line-through" : "none" })
                              }, toDisplayString(row.productName), 5)
                            ]),
                            _: 1
                          }),
                          createVNode(_component_el_table_column, {
                            label: "状态",
                            width: "100"
                          }, {
                            default: withCtx(({ row }) => [
                              createElementVNode("span", {
                                style: normalizeStyle({ color: isExpired(row) ? "red" : "green" })
                              }, toDisplayString(isExpired(row) ? "过期" : "正常"), 5)
                            ]),
                            _: 1
                          }),
                          createVNode(_component_el_table_column, {
                            prop: "powerList",
                            label: "能力",
                            width: "180"
                          }, {
                            default: withCtx(({ row }) => [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(row.powerList, (power) => {
                                return openBlock(), createElementBlock("div", { key: power }, [
                                  createVNode(_component_el_tag, {
                                    effect: "dark",
                                    type: randomStyle(),
                                    size: "small"
                                  }, {
                                    default: withCtx(() => [
                                      createTextVNode(toDisplayString(power), 1)
                                    ]),
                                    _: 2
                                  }, 1032, ["type"])
                                ]);
                              }), 128))
                            ]),
                            _: 1
                          }),
                          createVNode(_component_el_table_column, {
                            prop: "periodOfValidityStartTime",
                            label: "有效期开始时间"
                          }),
                          createVNode(_component_el_table_column, {
                            prop: "periodOfValidityEndTime",
                            label: "有效期结束时间"
                          })
                        ]),
                        _: 1
                      }, 8, ["data"]), [
                        [vShow, buyProductList.value.length > 0]
                      ]),
                      _hoisted_18
                    ], 512), [
                      [vShow, buyProductList.value.length > 0]
                    ]),
                    createElementVNode("div", _hoisted_19, [
                      createVNode(_component_el_button, {
                        type: "danger",
                        icon: unref(Shop),
                        onClick: showOrderGroup
                      }, {
                        default: withCtx(() => [
                          // createTextVNode(" 更多产品 ")
                        ]),
                        _: 1
                      }, 8, ["icon"]),
                      createVNode(_component_el_input, {
                        "suffix-icon": unref(Wallet),
                        modelValue: promotionCode.value,
                        "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => promotionCode.value = $event),
                        style: { "margin-left": "10px", "width": "240px" },
                        placeholder: "请输入您的优惠码"
                      }, null, 8, ["suffix-icon", "modelValue"]),
                      createVNode(_component_el_link, {
                        icon: unref(PriceTag),
                        type: "primary",
                        style: { "margin-left": "30px" },
                        target: "_blank",
                        href: "https://www.bilibili.com/video/BV1HKAyebESp"
                      }, {
                        default: withCtx(() => [
                          createTextVNode("点击获取优惠码(评论区)")
                        ]),
                        _: 1
                      }, 8, ["icon"])
                    ]),
                    withDirectives(createVNode(_component_el_empty, {
                      "image-size": 50,
                      // description: "购买产品为空，请点击更多产品查看"
                    }, null, 512), [
                      [vShow, !((_a = buyProductList.value) == null ? void 0 : _a.length) && !showOtherProduct.value]
                    ]),
                    showOtherProduct.value ? withDirectives((openBlock(), createElementBlock("div", _hoisted_20, [
                      _hoisted_21,
                      createElementVNode("p", null, [
                        createVNode(_component_el_text, {
                          class: "mx-1",
                          type: "danger"
                        }, {
                          default: withCtx(() => [
                            createTextVNode("定价说明：")
                          ]),
                          _: 1
                        }),
                        createTextVNode(" 使用R1深度思考大模型时：首先，R1的价格更贵，深度思考的内容也会被记录token消耗。token消耗量巨大。同时由于boss的会话聊天机制，需要携带消息上下文调用。这也就意味着对话轮数越多，token消耗越多。按乘方的趋势增长。 ")
                      ]),
                      _hoisted_22,
                      (openBlock(true), createElementBlock(Fragment, null, renderList(orderGroup.value, (order) => {
                        return openBlock(), createElementBlock("div", {
                          key: order,
                          style: normalizeStyle([{ "display": "flex" }, "width: " + 1 / orderGroup.value.length]),
                          class: "block"
                        }, [
                          createElementVNode("div", _hoisted_23, [
                            createElementVNode("p", _hoisted_24, [
                              createVNode(_component_el_text, {
                                size: "large",
                                type: "primary"
                              }, {
                                default: withCtx(() => [
                                  createTextVNode(toDisplayString(order.title), 1)
                                ]),
                                _: 2
                              }, 1024)
                            ]),
                            createElementVNode("p", _hoisted_25$1, [
                              createVNode(_component_el_text, {
                                size: "large",
                                type: "success"
                              }, {
                                default: withCtx(() => [
                                  createTextVNode(toDisplayString(order.validDays) + "天", 1)
                                ]),
                                _: 2
                              }, 1024)
                            ]),
                            createElementVNode("p", _hoisted_26, [
                              createVNode(_component_el_text, {
                                size: "large",
                                type: "danger"
                              }, {
                                default: withCtx(() => [
                                  createTextVNode("￥ " + toDisplayString(order.totalAmount), 1)
                                ]),
                                _: 2
                              }, 1024)
                            ])
                          ]),
                          createVNode(_component_el_image, {
                            style: { "width": "100px", "height": "100px" },
                            src: "data:image/png;base64," + order.qrCodeBase64,
                            fit: "fill"
                          }, {
                            error: withCtx(() => [
                              _hoisted_27
                            ]),
                            _: 2
                          }, 1032, ["src"]),
                          createElementVNode("div", _hoisted_28, [
                            createElementVNode("div", null, [
                              createTextVNode(" 提供能力: "),
                              (openBlock(true), createElementBlock(Fragment, null, renderList(order.tags, (tag) => {
                                return openBlock(), createBlock(_component_el_tag, {
                                  style: { "margin": "10px" },
                                  key: tag,
                                  type: randomStyle(),
                                  size: "large",
                                  effect: "light"
                                }, {
                                  default: withCtx(() => [
                                    createTextVNode(toDisplayString(tag), 1)
                                  ]),
                                  _: 2
                                }, 1032, ["type"]);
                              }), 128))
                            ]),
                            createElementVNode("div", null, [
                              createElementVNode("span", _hoisted_29, toDisplayString(order.desc), 1)
                            ])
                          ])
                        ], 4);
                      }), 128))
                    ])), [
                      [_directive_loading, productListLoading.value]
                    ]) : createCommentVNode("", true)
                  ];
                }),
                _: 1
              }, 8, ["modelValue"])
            ], 64);
          };
        }
      });
      const AiJob = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__scopeId", "data-v-13350d57"]]);
      const _withScopeId$2 = (n) => (pushScopeId("data-v-b36666e5"), n = n(), popScopeId(), n);
      const _hoisted_1$5 = { key: 0 };
      const _hoisted_2$4 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
      const _hoisted_3$2 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
      const _hoisted_4$2 = { style: { "display": "flex", "margin-top": "10px" } };
      const _hoisted_5$2 = { style: { "display": "flex", "margin-top": "10px" } };
      const _hoisted_6$2 = { style: { "display": "flex" } };
      const _hoisted_7$2 = { style: { "display": "flex" } };
      const _hoisted_8$2 = { style: { "display": "flex" } };
      const _hoisted_9$2 = { style: { "display": "flex", "height": "40px" } };
      const _hoisted_10$2 = { style: { "display": "flex", "margin-bottom": "10px" } };
      const _hoisted_11$2 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createElementVNode("p", { class: "time-interval" }, "投递间隔", -1));
      const _hoisted_12 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createElementVNode("p", { class: "time-interval" }, "秒", -1));
      const _hoisted_13 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createElementVNode("p", { class: "time-interval" }, "翻页间隔", -1));
      const _hoisted_14 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createElementVNode("p", { class: "time-interval" }, "秒", -1));
      const _hoisted_15 = { style: { "display": "flex" } };
      const _hoisted_16 = { style: { "display": "flex", "margin-top": "10px" } };
      const _sfc_main$7 = /* @__PURE__ */ defineComponent({
        __name: "Preference",
        setup(__props) {
          const axios2 = inject("$axios");
          const platform = inject("$platform");
          const userStore = UserStore();
          const ruleFormRef = ref();
          const validateEmail = (rule, value, callback) => {
            if (value === "") {
              callback(new Error("请输入邮箱"));
            } else if (!/^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(value)) {
              callback(new Error("请输入正确的邮箱"));
            } else {
              callback();
            }
          };
          const rules2 = reactive({
            phone: [{ required: true, message: "请输入手机号；作为偏好设置唯一键", trigger: "blur" }],
            email: [{
              required: true,
              message: "请输入邮件地址；将通过邮件通知您投递进度",
              validator: validateEmail,
              trigger: "blur"
            }]
          });
          const exportSetting = async () => {
            const preference = { ...userStore.user.preference };
            const exportData = JSON.stringify(preference, null, 2);
            try {
              await navigator.clipboard.writeText(exportData);
              ElNotification({
                title: "导出成功",
                message: "偏好设置已复制到剪贴板",
                type: "success",
                duration: 2e3
              });
            } catch (error) {
              ElNotification({
                title: "导出失败",
                message: "复制到剪贴板时出错",
                type: "error",
                duration: 2e3
              });
            }
          };
          const importSetting = async () => {
            ElMessageBox.prompt("请粘贴导出的偏好设置配置", "导入偏好设置", {
              confirmButtonText: "确认",
              cancelButtonText: "取消",
              inputType: "textarea",
              inputPlaceholder: "在此粘贴配置内容"
            }).then(({ value }) => {
              try {
                const importedPreference = JSON.parse(value);
                userStore.user.preference = { ...importedPreference };
                ElNotification({
                  title: "导入成功",
                  message: "偏好设置已导入，请点击保存偏好设置以持久化保存",
                  type: "success",
                  duration: 3e3
                });
              } catch (error) {
                ElNotification({
                  title: "导入失败",
                  message: "配置格式错误，请检查后重试",
                  type: "error",
                  duration: 2e3
                });
              }
            }).catch(() => {
            });
          };
          const submitForm = async (formEl) => {
            if (!formEl) return;
            formEl.validate(async (valid) => {
                if (valid) {
                    // 直接存入 Tampermonkey 存储
                    TampermonkeyApi.GmSetValue(TampermonkeyApi.LOCAL_CONFIG, userStore.user);
                    // 同时在 localStorage 存一份备份
                    localStorage.setItem('ai-job-user-local-backup', JSON.stringify(userStore.user));
                    
                    ElMessage({
                        message: "【本地模式】偏好设置已成功保存到脚本存储",
                        type: "success",
                        duration: 2000
                    });
                }
            });
          };
          const resetForm = (formEl) => {
            if (!formEl)
              return;
            userStore.user.email = "";
            userStore.user.preference = {};
          };
          const firstFile = ref(null);
          let jobDetail = platform.getFistJobDetail();
          const uploadData = {
            securityId: jobDetail == null ? void 0 : jobDetail.securityId,
            // securityId: BossOption.bossUserInfoMap?.values()?.next()?.value.securityId,
            source: "chat_file"
          };
          const beforeUpload = (file) => {
            firstFile.value = file;
            return true;
          };
          const handleUploadSuccess = async (response) => {
            userStore.user.preference.cI = response.zpData.url + "===" + response.zpData.tinyUrl;
            ElMessage({
              message: "图片简历上传成功；点击下方保存偏好设置可持久保存",
              type: "success",
              duration: 3e3
            });
          };
          const isGenerating = ref(false);
          function debounceImmediate(func, wait) {
            let timeout = null;
            return (...args) => {
              if (!timeout) {
                func(...args);
              }
              if (timeout !== null) {
                clearTimeout(timeout);
                ElNotification({
                  message: "请勿频繁点击，请等待",
                  type: "warning",
                  duration: 1e3
                });
              }
              timeout = window.setTimeout(() => {
                timeout = null;
              }, wait);
            };
          }
          const generateGreet = debounceImmediate(async () => {
            if (isGenerating.value)
              return;
            isGenerating.value = true;
            try {
              const response = await axios2.post("/api/job/ai/assistant/generate/greeting", {}, { timeout: 3e4 });
              userStore.user.preference.cg = response.data.data;
              ElNotification({
                message: "招呼语生成成功，请点击下方保存偏好设置",
                type: "success",
                duration: 2e3
              });
            } catch (error) {
              ElNotification({
                title: "AI问候语生成失败",
                message: error,
                type: "error",
                duration: 3e3
              });
            } finally {
              isGenerating.value = false;
            }
          }, 15e3);
          const preferenceDefaultValueHandler = () => {
            if (!userStore.user.preference.dr) {
              userStore.user.preference.dr = 0;
            }
          };
          preferenceDefaultValueHandler();
          return (_ctx, _cache) => {
            const _component_el_text = ElText;
            const _component_el_input = ElInput;
            const _component_el_form_item = ElFormItem;
            const _component_el_checkbox = ElCheckbox;
            const _component_el_option = ElOption;
            const _component_el_select = ElSelect;
            const _component_el_tooltip = ElTooltip;
            const _component_el_button = ElButton;
            const _component_el_upload = ElUpload;
            const _component_el_tag = ElTag;
            const _component_el_input_number = ElInputNumber;
            const _component_el_form = ElForm;
            return openBlock(), createBlock(_component_el_form, {
              ref_key: "ruleFormRef",
              ref: ruleFormRef,
              model: unref(userStore).user,
              rules: rules2,
              "label-position": "right",
              "label-width": "auto",
              class: "form-preference",
              size: "large",
              "status-icon": ""
            }, {
              default: withCtx(() => [
                createElementVNode("div", null, [
                  unref(Tools).window.location.href.includes("job-recommend") ? (openBlock(), createElementBlock("div", _hoisted_1$5, [
                    createVNode(_component_el_text, {
                      class: "mx-1 top-title",
                      type: "danger"
                    }, {
                      default: withCtx(() => [
                        createTextVNode("!!!请前往顶部【搜索】按钮所在页面保存偏好设置!!!")
                      ]),
                      _: 1
                    }),
                    _hoisted_2$4,
                    _hoisted_3$2
                  ])) : createCommentVNode("", true),
                  createVNode(_component_el_text, {
                    class: "mx-1 top-title",
                    type: "warning"
                  }, {
                    default: withCtx(() => [
                      createTextVNode("账号信息")
                    ]),
                    _: 1
                  }),
                  createElementVNode("div", _hoisted_4$2, [
                    createVNode(_component_el_form_item, {
                      label: "手机号",
                      prop: "phone",
                      style: { "margin-left": "-6px" }
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_input, {
                          modelValue: unref(userStore).user.phone,
                          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(userStore).user.phone = $event)
                        }, null, 8, ["modelValue"])
                      ]),
                      _: 1
                    }),
                    createVNode(_component_el_form_item, {
                      label: "通知邮箱",
                      prop: "email"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_input, {
                          modelValue: unref(userStore).user.email,
                          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(userStore).user.email = $event)
                        }, null, 8, ["modelValue"])
                      ]),
                      _: 1
                    })
                  ]),
                  createVNode(_component_el_text, {
                    class: "mx-1 top-title",
                    type: "warning"
                  }, {
                    default: withCtx(() => [
                      createTextVNode("投递设置")
                    ]),
                    _: 1
                  }),
                  createElementVNode("div", _hoisted_5$2, [
                    createVNode(_component_el_form_item, {
                      prop: "companyInclude",
                      style: { "margin-left": "-40px" }
                    }, {
                      label: withCtx(() => [
                        createVNode(_component_el_checkbox, {
                          modelValue: unref(userStore).user.preference.cniE,
                          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(userStore).user.preference.cniE = $event),
                          label: "",
                          size: "large"
                        }, null, 8, ["modelValue"]),
                        createTextVNode(" 公司名包含 ")
                      ]),
                      default: withCtx(() => [
                        createVNode(_component_el_select, {
                          modelValue: unref(userStore).user.preference.cni,
                          "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(userStore).user.preference.cni = $event),
                          multiple: "",
                          filterable: "",
                          remote: "",
                          "allow-create": "",
                          "default-first-option": "",
                          "reserve-keyword": false,
                          placeholder: "公司名包含",
                          style: { "width": "240px" }
                        }, {
                          default: withCtx(() => [
                            (openBlock(), createElementBlock(Fragment, null, renderList(["请输入公司名"], (item, inx) => {
                              return createVNode(_component_el_option, {
                                key: inx,
                                label: item,
                                value: item
                              }, null, 8, ["label", "value"]);
                            }), 64))
                          ]),
                          _: 1
                        }, 8, ["modelValue"])
                      ]),
                      _: 1
                    }),
                    createVNode(_component_el_form_item, {
                      label: "公司名排除",
                      prop: "companyExclude"
                    }, {
                      label: withCtx(() => [
                        createVNode(_component_el_checkbox, {
                          modelValue: unref(userStore).user.preference.cneE,
                          "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(userStore).user.preference.cneE = $event),
                          label: "",
                          size: "large"
                        }, null, 8, ["modelValue"]),
                        createTextVNode(" 公司名排除    ")
                      ]),
                      default: withCtx(() => [
                        createVNode(_component_el_select, {
                          modelValue: unref(userStore).user.preference.cne,
                          "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => unref(userStore).user.preference.cne = $event),
                          multiple: "",
                          filterable: "",
                          remote: "",
                          "allow-create": "",
                          "default-first-option": "",
                          "reserve-keyword": false,
                          placeholder: "公司名排除",
                          style: { "width": "240px" }
                        }, {
                          default: withCtx(() => [
                            (openBlock(), createElementBlock(Fragment, null, renderList(["请输入公司名"], (item, inx) => {
                              return createVNode(_component_el_option, {
                                key: inx,
                                label: item,
                                value: item
                              }, null, 8, ["label", "value"]);
                            }), 64))
                          ]),
                          _: 1
                        }, 8, ["modelValue"])
                      ]),
                      _: 1
                    })
                  ]),
                  createElementVNode("div", _hoisted_6$2, [
                    createVNode(_component_el_form_item, {
                      label: "工作名包含",
                      style: { "margin-left": "-40px" },
                      prop: "jobNameInclude"
                    }, {
                      label: withCtx(() => [
                        createVNode(_component_el_checkbox, {
                          modelValue: unref(userStore).user.preference.jniE,
                          "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => unref(userStore).user.preference.jniE = $event),
                          label: "",
                          size: "large"
                        }, null, 8, ["modelValue"]),
                        createTextVNode(" 工作名包含 ")
                      ]),
                      default: withCtx(() => [
                        createVNode(_component_el_select, {
                          modelValue: unref(userStore).user.preference.jni,
                          "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => unref(userStore).user.preference.jni = $event),
                          multiple: "",
                          filterable: "",
                          remote: "",
                          "allow-create": "",
                          "default-first-option": "",
                          "reserve-keyword": false,
                          placeholder: "工作名包含",
                          style: { "width": "240px" }
                        }, {
                          default: withCtx(() => [
                            (openBlock(), createElementBlock(Fragment, null, renderList(["请输入工作名"], (item, inx) => {
                              return createVNode(_component_el_option, {
                                key: inx,
                                label: item,
                                value: item
                              }, null, 8, ["label", "value"]);
                            }), 64))
                          ]),
                          _: 1
                        }, 8, ["modelValue"])
                      ]),
                      _: 1
                    }),
                    createVNode(_component_el_form_item, {
                      label: "工作名排除",
                      prop: "jobContentExclude"
                    }, {
                      label: withCtx(() => [
                        createVNode(_component_el_checkbox, {
                          modelValue: unref(userStore).user.preference.jneE,
                          "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => unref(userStore).user.preference.jneE = $event),
                          label: "",
                          size: "large"
                        }, null, 8, ["modelValue"]),
                        createTextVNode(" 工作名排除    ")
                      ]),
                      default: withCtx(() => [
                        createVNode(_component_el_select, {
                          modelValue: unref(userStore).user.preference.jne,
                          "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => unref(userStore).user.preference.jne = $event),
                          multiple: "",
                          filterable: "",
                          remote: "",
                          "allow-create": "",
                          "default-first-option": "",
                          "reserve-keyword": false,
                          placeholder: "工作名排除",
                          style: { "width": "240px" }
                        }, {
                          default: withCtx(() => [
                            (openBlock(), createElementBlock(Fragment, null, renderList(["请输入岗位名称"], (item, inx) => {
                              return createVNode(_component_el_option, {
                                key: inx,
                                label: item,
                                value: item
                              }, null, 8, ["label", "value"]);
                            }), 64))
                          ]),
                          _: 1
                        }, 8, ["modelValue"])
                      ]),
                      _: 1
                    })
                  ]),
                  createElementVNode("div", _hoisted_7$2, [
                    createVNode(_component_el_form_item, {
                      label: "工作内容包含",
                      style: { "margin-left": "-40px" },
                      prop: "jobContentInclude"
                    }, {
                      label: withCtx(() => [
                        createVNode(_component_el_checkbox, {
                          modelValue: unref(userStore).user.preference.jciE,
                          "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => unref(userStore).user.preference.jciE = $event),
                          label: "",
                          size: "large"
                        }, null, 8, ["modelValue"]),
                        createTextVNode("     内容包含 ")
                      ]),
                      default: withCtx(() => [
                        createVNode(_component_el_select, {
                          modelValue: unref(userStore).user.preference.jci,
                          "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => unref(userStore).user.preference.jci = $event),
                          multiple: "",
                          filterable: "",
                          remote: "",
                          "allow-create": "",
                          "default-first-option": "",
                          "reserve-keyword": false,
                          placeholder: "工作内容包含",
                          style: { "width": "240px" }
                        }, {
                          default: withCtx(() => [
                            (openBlock(), createElementBlock(Fragment, null, renderList(["请输入工作内容"], (item, inx) => {
                              return createVNode(_component_el_option, {
                                key: inx,
                                label: item,
                                value: item
                              }, null, 8, ["label", "value"]);
                            }), 64))
                          ]),
                          _: 1
                        }, 8, ["modelValue"])
                      ]),
                      _: 1
                    }),
                    createVNode(_component_el_form_item, {
                      label: "工作内容排除",
                      prop: "jobContentExclude"
                    }, {
                      label: withCtx(() => [
                        createVNode(_component_el_checkbox, {
                          modelValue: unref(userStore).user.preference.jceE,
                          "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => unref(userStore).user.preference.jceE = $event),
                          label: "",
                          size: "large"
                        }, null, 8, ["modelValue"]),
                        createTextVNode(" 工作内容排除 ")
                      ]),
                      default: withCtx(() => [
                        createVNode(_component_el_select, {
                          modelValue: unref(userStore).user.preference.jce,
                          "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => unref(userStore).user.preference.jce = $event),
                          multiple: "",
                          filterable: "",
                          remote: "",
                          "allow-create": "",
                          "default-first-option": "",
                          "reserve-keyword": false,
                          placeholder: "工作内容排除",
                          style: { "width": "240px" }
                        }, {
                          default: withCtx(() => [
                            (openBlock(), createElementBlock(Fragment, null, renderList(["请输入工作内容字符串"], (item, inx) => {
                              return createVNode(_component_el_option, {
                                key: inx,
                                label: item,
                                value: item
                              }, null, 8, ["label", "value"]);
                            }), 64))
                          ]),
                          _: 1
                        }, 8, ["modelValue"])
                      ]),
                      _: 1
                    })
                  ]),
                  createElementVNode("div", _hoisted_8$2, [
                    createElementVNode("div", _hoisted_9$2, [
                      createVNode(_component_el_checkbox, {
                        modelValue: unref(userStore).user.preference.srE,
                        "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => unref(userStore).user.preference.srE = $event),
                        label: "",
                        size: "large"
                      }, null, 8, ["modelValue"]),
                      createVNode(_component_el_input, {
                        class: "input-opt",
                        modelValue: unref(userStore).user.preference.sr,
                        "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => unref(userStore).user.preference.sr = $event),
                        style: { "width": "324px" },
                        placeholder: "薪资范围 例:9-15"
                      }, {
                        prepend: withCtx(() => [
                          createVNode(_component_el_select, {
                            modelValue: unref(userStore).user.preference.srT,
                            "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => unref(userStore).user.preference.srT = $event),
                            placeholder: "月薪(k)",
                            style: { "width": "100px" }
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_el_option, {
                                label: "月薪(k)",
                                value: "1"
                              }),
                              createVNode(_component_el_option, {
                                label: "日薪",
                                value: "2"
                              })
                            ]),
                            _: 1
                          }, 8, ["modelValue"])
                        ]),
                        _: 1
                      }, 8, ["modelValue"])
                    ]),
                    createVNode(_component_el_form_item, {
                      label: "公司规模范围",
                      prop: "jobContentExclude",
                      style: { "margin-left": "0" }
                    }, {
                      label: withCtx(() => [
                        createVNode(_component_el_checkbox, {
                          modelValue: unref(userStore).user.preference.csrE,
                          "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => unref(userStore).user.preference.csrE = $event),
                          label: "",
                          size: "large"
                        }, null, 8, ["modelValue"]),
                        createTextVNode(" 公司规模范围 ")
                      ]),
                      default: withCtx(() => [
                        createVNode(_component_el_input, {
                          modelValue: unref(userStore).user.preference.csr,
                          "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => unref(userStore).user.preference.csr = $event),
                          placeholder: "公司规模范围 例:10-5000",
                          style: { "width": "242px" }
                        }, null, 8, ["modelValue"])
                      ]),
                      _: 1
                    })
                  ]),
                  createVNode(_component_el_form_item, {
                    label: "AI过滤(语义匹配)",
                    prop: "aiFilter"
                  }, {
                    label: withCtx(() => [
                      createVNode(_component_el_checkbox, {
                        modelValue: unref(userStore).user.preference.afE,
                        "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => unref(userStore).user.preference.afE = $event),
                        label: "",
                        size: "large"
                      }, null, 8, ["modelValue"]),
                      createVNode(_component_el_tooltip, {
                        effect: "dark",
                        "raw-content": "",
                        content: "\r\n    批量投递时AI会通过你的提示词过滤筛选相应岗位<p/><span style='color:red;'>\r\n    </span><br/>过滤提示词举例：我希望找到武汉的java岗位，薪资至少20K，不考虑学历要求为本科及以下、或者需要超过10年工作经验的职位。\r\n    </span><br/>与简历信息不互通，如果依赖您的某些信息，请通过提示词告知AI\r\n    ",
                        placement: "bottom"
                      }, {
                        default: withCtx(() => [
                          createTextVNode(" AI 过滤(语义匹配) ")
                        ]),
                        _: 1
                      })
                    ]),
                    default: withCtx(() => [
                      createVNode(_component_el_input, {
                        type: "textarea",
                        modelValue: unref(userStore).user.preference.af,
                        "onUpdate:modelValue": _cache[20] || (_cache[20] = ($event) => unref(userStore).user.preference.af = $event)
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_form_item, {
                    label: "发送自定义招呼语",
                    prop: "jobContentExclude"
                  }, {
                    label: withCtx(() => [
                      createVNode(_component_el_checkbox, {
                        modelValue: unref(userStore).user.preference.cgE,
                        "onUpdate:modelValue": _cache[21] || (_cache[21] = ($event) => unref(userStore).user.preference.cgE = $event),
                        label: "",
                        size: "large"
                      }, null, 8, ["modelValue"]),
                      createTextVNode(" 发送自定义招呼语 ")
                    ]),
                    default: withCtx(() => [
                      createVNode(_component_el_input, {
                        type: "textarea",
                        modelValue: unref(userStore).user.preference.cg,
                        "onUpdate:modelValue": _cache[22] || (_cache[22] = ($event) => unref(userStore).user.preference.cg = $event)
                      }, null, 8, ["modelValue"]),
                      createVNode(_component_el_button, {
                        size: "small",
                        type: "primary",
                        onClick: unref(generateGreet),
                        disabled: isGenerating.value
                      }, {
                        default: withCtx(() => [
                          createTextVNode("AI生成招呼语")
                        ]),
                        _: 1
                      }, 8, ["onClick", "disabled"])
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_form_item, {
                    label: "发送图片简历",
                    prop: "jobContentExclude",
                    class: "form-item-upload",
                    style: { "margin-left": "0" }
                  }, {
                    label: withCtx(() => [
                      createVNode(_component_el_checkbox, {
                        modelValue: unref(userStore).user.preference.cIE,
                        "onUpdate:modelValue": _cache[23] || (_cache[23] = ($event) => unref(userStore).user.preference.cIE = $event),
                        label: "",
                        size: "large"
                      }, null, 8, ["modelValue"]),
                      createTextVNode(" 发送图片简历        ")
                    ]),
                    default: withCtx(() => [
                      createVNode(_component_el_upload, {
                        action: "https://www.zhipin.com/wapi/zpupload/image/uploadSingle",
                        "before-upload": beforeUpload,
                        "on-success": handleUploadSuccess,
                        "show-file-list": false,
                        data: uploadData,
                        headers: { "Zp_token": unref(Tools).getCookieValue("bst") }
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_button, {
                            size: "small",
                            type: "primary"
                          }, {
                            default: withCtx(() => [
                              createTextVNode("选择图片简历")
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }, 8, ["headers"]),
                      unref(userStore).user.preference.cI ? (openBlock(), createBlock(_component_el_tag, {
                        key: 0,
                        type: "success",
                        size: "small",
                        style: { "margin-left": "5px" }
                      }, {
                        default: withCtx(() => [
                          createTextVNode("已上传")
                        ]),
                        _: 1
                      })) : createCommentVNode("", true)
                    ]),
                    _: 1
                  }),
                  createElementVNode("div", _hoisted_10$2, [
                    createVNode(_component_el_checkbox, {
                      modelValue: unref(userStore).user.preference.fhE,
                      "onUpdate:modelValue": _cache[24] || (_cache[24] = ($event) => unref(userStore).user.preference.fhE = $event),
                      label: "",
                      size: "large"
                    }, {
                      default: withCtx(() => [
                        createTextVNode("过滤猎头")
                      ]),
                      _: 1
                    }, 8, ["modelValue"]),
                    createVNode(_component_el_checkbox, {
                      modelValue: unref(userStore).user.preference.polE,
                      "onUpdate:modelValue": _cache[25] || (_cache[25] = ($event) => unref(userStore).user.preference.polE = $event),
                      label: "",
                      size: "large"
                    }, {
                      default: withCtx(() => [
                        createTextVNode("仅投递boss在线岗位 ")
                      ]),
                      _: 1
                    }, 8, ["modelValue"]),
                    createTextVNode("         "),
                    _hoisted_11$2,
                    createVNode(_component_el_input_number, {
                      modelValue: unref(userStore).user.preference.pi,
                      "onUpdate:modelValue": _cache[26] || (_cache[26] = ($event) => unref(userStore).user.preference.pi = $event),
                      min: 3,
                      max: 60,
                      size: "small"
                    }, null, 8, ["modelValue"]),
                    _hoisted_12,
                    createTextVNode("         "),
                    _hoisted_13,
                    createVNode(_component_el_input_number, {
                      modelValue: unref(userStore).user.preference.npi,
                      "onUpdate:modelValue": _cache[27] || (_cache[27] = ($event) => unref(userStore).user.preference.npi = $event),
                      min: 6,
                      max: 60,
                      size: "small"
                    }, null, 8, ["modelValue"]),
                    _hoisted_14
                  ]),
                  createVNode(_component_el_text, {
                    class: "mx-1 top-title",
                    type: "warning"
                  }, {
                    default: withCtx(() => [
                      createTextVNode("交互设置")
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_form_item, {
                    label: "预测问题",
                    prop: "jobContentExclude",
                    style: { "margin-top": "10px" }
                  }, {
                    label: withCtx(() => [
                      createVNode(_component_el_checkbox, {
                        modelValue: unref(userStore).user.preference.ppE,
                        "onUpdate:modelValue": _cache[28] || (_cache[28] = ($event) => unref(userStore).user.preference.ppE = $event),
                        label: "",
                        size: "large"
                      }, null, 8, ["modelValue"]),
                      createTextVNode(" 预设问题               ")
                    ]),
                    default: withCtx(() => [
                      createVNode(_component_el_input, {
                        type: "textarea",
                        modelValue: unref(userStore).user.preference.pp,
                        "onUpdate:modelValue": _cache[29] || (_cache[29] = ($event) => unref(userStore).user.preference.pp = $event)
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_form_item, {
                    label: "拒绝挽留",
                    prop: "jobContentExclude"
                  }, {
                    label: withCtx(() => [
                      createVNode(_component_el_checkbox, {
                        modelValue: unref(userStore).user.preference.rfE,
                        "onUpdate:modelValue": _cache[30] || (_cache[30] = ($event) => unref(userStore).user.preference.rfE = $event),
                        label: "",
                        size: "large"
                      }, null, 8, ["modelValue"]),
                      createTextVNode(" 拒绝挽留               ")
                    ]),
                    default: withCtx(() => [
                      createVNode(_component_el_input, {
                        type: "textarea",
                        modelValue: unref(userStore).user.preference.rf,
                        "onUpdate:modelValue": _cache[31] || (_cache[31] = ($event) => unref(userStore).user.preference.rf = $event)
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  }),
                  createElementVNode("div", _hoisted_15, [
                    createVNode(_component_el_checkbox, {
                      style: { "padding-top": "6px" },
                      modelValue: unref(userStore).user.preference.hiaE,
                      "onUpdate:modelValue": _cache[32] || (_cache[32] = ($event) => unref(userStore).user.preference.hiaE = $event),
                      label: "",
                      size: "large"
                    }, {
                      default: withCtx(() => [
                        createTextVNode("高意向停止AI坐席 ")
                      ]),
                      _: 1
                    }, 8, ["modelValue"]),
                    createVNode(_component_el_text, {
                      type: "primary",
                      style: { "margin-top": "-20px" }
                    }, {
                      default: withCtx(() => [
                        createTextVNode("  高意向条件:")
                      ]),
                      _: 1
                    }),
                    createVNode(_component_el_form_item, {
                      label: "对话聊天轮数",
                      prop: "crC",
                      style: { "margin-left": "-30px" }
                    }, {
                      label: withCtx(() => [
                        createVNode(_component_el_text, {
                          class: "mx-1",
                          type: "primary",
                          style: { "margin-top": "5px" }
                        }, {
                          default: withCtx(() => [
                            createTextVNode("对话轮数 >=")
                          ]),
                          _: 1
                        })
                      ]),
                      default: withCtx(() => [
                        createVNode(_component_el_text, {
                          class: "mx-1",
                          type: "primary",
                          style: { "margin-top": "5px" }
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_el_input, {
                              type: "number",
                              style: { "width": "50px" },
                              size: "small",
                              modelValue: unref(userStore).user.preference.crC,
                              "onUpdate:modelValue": _cache[33] || (_cache[33] = ($event) => unref(userStore).user.preference.crC = $event)
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_form_item, {
                          label: "对话聊天轮数关键字",
                          prop: "crC",
                          style: { "margin-left": "0", "margin-top": "3px" }
                        }, {
                          label: withCtx(() => [
                            createVNode(_component_el_text, {
                              class: "mx-1",
                              type: "primary"
                            }, {
                              default: withCtx(() => [
                                createTextVNode("OR   包含关键字")
                              ]),
                              _: 1
                            })
                          ]),
                          default: withCtx(() => [
                            createVNode(_component_el_select, {
                              modelValue: unref(userStore).user.preference.crK,
                              "onUpdate:modelValue": _cache[34] || (_cache[34] = ($event) => unref(userStore).user.preference.crK = $event),
                              multiple: "",
                              filterable: "",
                              remote: "",
                              "allow-create": "",
                              "default-first-option": "",
                              "reserve-keyword": false,
                              placeholder: "包含关键字",
                              style: { "min-width": "200px", "width": "100%" }
                            }, {
                              default: withCtx(() => [
                                (openBlock(), createElementBlock(Fragment, null, renderList(["请输入包含关键字"], (item, inx) => {
                                  return createVNode(_component_el_option, {
                                    key: inx,
                                    label: item,
                                    value: item
                                  }, null, 8, ["label", "value"]);
                                }), 64))
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  createVNode(_component_el_form_item, null, {
                    default: withCtx(() => [
                      createVNode(_component_el_checkbox, {
                        modelValue: unref(userStore).user.preference.drE,
                        "onUpdate:modelValue": _cache[35] || (_cache[35] = ($event) => unref(userStore).user.preference.drE = $event),
                        label: "",
                        size: "large"
                      }, {
                        default: withCtx(() => [
                          createTextVNode("AI坐席延迟回复 ")
                        ]),
                        _: 1
                      }, 8, ["modelValue"]),
                      createTextVNode("         "),
                      createVNode(_component_el_input_number, {
                        modelValue: unref(userStore).user.preference.dr,
                        "onUpdate:modelValue": _cache[36] || (_cache[36] = ($event) => unref(userStore).user.preference.dr = $event),
                        min: 0,
                        max: 30,
                        size: "small"
                      }, null, 8, ["modelValue"]),
                      createTextVNode("  秒 ")
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_text, {
                    class: "mx-1 top-title",
                    type: "warning"
                  }, {
                    default: withCtx(() => [
                      createTextVNode("邮件通知")
                    ]),
                    _: 1
                  }),
                  createElementVNode("div", _hoisted_16, [
                    createVNode(_component_el_checkbox, {
                      modelValue: unref(userStore).user.preference.ermE,
                      "onUpdate:modelValue": _cache[37] || (_cache[37] = ($event) => unref(userStore).user.preference.ermE = $event),
                      label: "",
                      size: "large"
                    }, {
                      default: withCtx(() => [
                        createTextVNode("每轮交流邮件通知 ")
                      ]),
                      _: 1
                    }, 8, ["modelValue"]),
                    createVNode(_component_el_checkbox, {
                      modelValue: unref(userStore).user.preference.crE,
                      "onUpdate:modelValue": _cache[38] || (_cache[38] = ($event) => unref(userStore).user.preference.crE = $event),
                      label: "",
                      size: "large"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_text, {
                          class: "mx-1",
                          type: "danger"
                        }, {
                          default: withCtx(() => [
                            createTextVNode("高意向邮件通知")
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }, 8, ["modelValue"])
                  ]),
                  createVNode(_component_el_form_item, null, {
                    default: withCtx(() => [
                      createVNode(_component_el_button, {
                        type: "primary",
                        onClick: _cache[39] || (_cache[39] = ($event) => submitForm(ruleFormRef.value))
                      }, {
                        default: withCtx(() => [
                          createTextVNode("保存偏好设置")
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_button, {
                        onClick: _cache[40] || (_cache[40] = ($event) => resetForm(ruleFormRef.value))
                      }, {
                        default: withCtx(() => [
                          createTextVNode("清除偏好设置")
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_button, { onClick: exportSetting }, {
                        default: withCtx(() => [
                          createTextVNode("导出偏好设置")
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_button, { onClick: importSetting }, {
                        default: withCtx(() => [
                          createTextVNode("导入偏好设置")
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ])
              ]),
              _: 1
            }, 8, ["model", "rules"]);
          };
        }
      });
      const Preference = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-b36666e5"]]);
      const _sfc_main$6 = /* @__PURE__ */ defineComponent({
        __name: "RunRecord",
        setup(__props) {
          const logRecorder = new LogRecorder();
          const logs = ref([]);
          const currentPage = ref(1);
          const pageSize = ref(10);
          const totalLogs = ref(0);
          const filter = ref({
            timeRange: [],
            // 时间范围，数组：[开始时间, 结束时间]
            level: "",
            // 日志级别
            keyword: ""
            // 日志内容关键字
          });
          const fetchLogs = () => {
            var _a;
            let allLogs = logRecorder.getLogs(1, logRecorder.getLogCount());
            if (((_a = filter.value.timeRange) == null ? void 0 : _a.length) === 2) {
              const [start, end] = filter.value.timeRange.map(
                (time) => time.toTimeString().slice(0, 6) + "00"
                // 转为 'HH:mm' 格式字符串
              );
              allLogs = allLogs.filter((log) => {
                const logTime = log.timestamp;
                return logTime >= start && logTime <= end;
              });
            }
            if (filter.value.level) {
              allLogs = allLogs.filter((log) => log.level === filter.value.level);
            }
            if (filter.value.keyword) {
              const keyword = filter.value.keyword.toLowerCase();
              allLogs = allLogs.filter((log) => log.message.toLowerCase().includes(keyword));
            }
            totalLogs.value = allLogs.length;
            const startIndex = (currentPage.value - 1) * pageSize.value;
            logs.value = allLogs.slice(startIndex, startIndex + pageSize.value);
          };
          const handlePageChange = (page) => {
            currentPage.value = page;
            fetchLogs();
          };
          watch(filter, () => {
            currentPage.value = 1;
            fetchLogs();
          }, { deep: true });
          const clearLogs = () => {
            logRecorder.clearLogs();
            fetchLogs();
          };
          onMounted(() => {
            fetchLogs();
          });
          return (_ctx, _cache) => {
            const _component_el_button = ElButton;
            const _component_el_col = ElCol;
            const _component_el_time_picker = ElTimePicker;
            const _component_el_option = ElOption;
            const _component_el_select = ElSelect;
            const _component_el_input = ElInput;
            const _component_el_row = ElRow;
            const _component_el_table_column = ElTableColumn;
            const _component_el_empty = ElEmpty;
            const _component_el_table = ElTable;
            const _component_el_pagination = ElPagination;
            return openBlock(), createElementBlock("div", null, [
              createVNode(_component_el_row, {
                gutter: 20,
                class: "filter-bar"
              }, {
                default: withCtx(() => [
                  createVNode(_component_el_col, { span: 2 }, {
                    default: withCtx(() => [
                      createVNode(_component_el_button, {
                        type: "warning",
                        onClick: clearLogs
                      }, {
                        default: withCtx(() => [
                          createTextVNode("清空日志")
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_col, { span: 8 }, {
                    default: withCtx(() => [
                      createVNode(_component_el_time_picker, {
                        modelValue: filter.value.timeRange,
                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => filter.value.timeRange = $event),
                        "is-range": "",
                        "start-placeholder": "开始时间",
                        "end-placeholder": "结束时间",
                        format: "HH:mm",
                        clearable: "",
                        style: { "width": "100%" }
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_col, { span: 6 }, {
                    default: withCtx(() => [
                      createVNode(_component_el_select, {
                        modelValue: filter.value.level,
                        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => filter.value.level = $event),
                        placeholder: "请选择日志级别",
                        style: { "width": "100%" }
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_option, {
                            label: "全部",
                            value: ""
                          }),
                          createVNode(_component_el_option, {
                            label: "Error",
                            value: "error"
                          }),
                          createVNode(_component_el_option, {
                            label: "Warn",
                            value: "warn"
                          }),
                          createVNode(_component_el_option, {
                            label: "Info",
                            value: "info"
                          }),
                          createVNode(_component_el_option, {
                            label: "Debug",
                            value: "debug"
                          }),
                          createVNode(_component_el_option, {
                            label: "Trace",
                            value: "trace"
                          })
                        ]),
                        _: 1
                      }, 8, ["modelValue"])
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_col, { span: 8 }, {
                    default: withCtx(() => [
                      createVNode(_component_el_input, {
                        modelValue: filter.value.keyword,
                        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => filter.value.keyword = $event),
                        placeholder: "请输入日志内容",
                        clearable: "",
                        style: { "width": "100%" }
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              createVNode(_component_el_table, {
                data: logs.value,
                style: { "width": "100%", "min-height": "440px" }
              }, {
                empty: withCtx(() => [
                  createVNode(_component_el_empty, { description: "暂无日志数据" })
                ]),
                default: withCtx(() => [
                  createVNode(_component_el_table_column, {
                    prop: "timestamp",
                    label: "时间",
                    width: "120"
                  }),
                  createVNode(_component_el_table_column, {
                    prop: "level",
                    label: "级别",
                    width: "100"
                  }),
                  createVNode(_component_el_table_column, {
                    prop: "message",
                    label: "内容"
                  })
                ]),
                _: 1
              }, 8, ["data"]),
              createVNode(_component_el_pagination, {
                onCurrentChange: handlePageChange,
                "current-page": currentPage.value,
                "page-size": pageSize.value,
                total: totalLogs.value,
                background: "",
                layout: "prev, pager, next"
              }, null, 8, ["current-page", "page-size", "total"])
            ]);
          };
        }
      });
      const RunRecord = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-de025004"]]);
      const _hoisted_1$4 = { class: "markdown-body" };
      const _hoisted_2$3 = /* @__PURE__ */ createStaticVNode('<h2>AI工作猎手</h2><br><ul><li><strong><code class="">找工作，用AI工作猎手！让AI帮您找工作！</code></strong> AI坐席：【DeepSeek+ChatGpt】赋能，ai助理作为您的求职者分身24小时 * 7在线找工作，并结合您的简历信息定制化回复。批量投递，自动发送简历，交换联系方式。hr拒绝挽留。高意向邮件通知，让您不错过每一份工作机会。 <br></li></ul><hr><br><h3>AI坐席</h3><ul><li>- 让AI作为您的求职者分身，帮助您快速找到工作。</li><li>- 智能回复HR的消息,结合您的简历信息进行定制化回答。</li><li>- 预设问题支持，根据场景只能匹配您的预设问题，进行智能回答。</li><li>- AI快捷回复发送简历，交换 wx、联系方式。</li><li>- HR拒绝挽留，当hr拒绝您时，可触发拒绝挽留。主动发送简历，并发送自定义的挽留语。</li></ul><br><h3>工作通知</h3><ul><li>- 支持AI坐席与HR的每轮沟通，发送邮件通知。</li><li>- 高意向职位邮件通知，通过设置的关键字或者对话轮数，发送高意向职位的通知。</li></ul><br><h3>投递工具</h3><ul><li>- 先通过Boss的筛选功能圈选出你的意向岗位</li><li>- <span style="color:red;">投递前在偏好设置中设置您的岗位偏好，便于精准投递。</span></li><li>- 批量投递简历。自定义单次投递数量。</li><li>- 发送自定义招呼语，充分展现您的优势。</li><li>- 投递后发送图片简历，绕开发送附件简历需要HR同意机制，直接触达。</li><li>- 自定义筛选过滤，根据您的需求筛选公司，职位，薪资…。</li></ul><br><h3>AI坐席使用</h3><ul><li>- 购买ai坐席之后，可在AI助手中开启全局AI坐席功能。</li><li>- 开启全局AI坐席功能后，HR的消息将会自动转发给AI坐席进行智能回复。</li><li>- 可随时打断AI坐席的回复，当在web端或app端自己回复HR之后，当前会话的AI坐席将会自动停止。</li><li>- 停止后，可在web端的消息列表页面中点击【重启当前会话AI坐席】按钮，重新开启当前会话的AI坐席。</li><li>- 也可在web端通过快捷指令【start】输入到聊天框并发送，开启当前会话的AI坐席。boss端并不会收到当前消息。</li><li>- 当hr拒绝您时，可触发拒绝挽留。主动发送简历，并发送自定义的挽留语。</li><li>- 当hr通过boss向你交换联系方式时，ai助手自动交换。</li><li>- 可在偏好设置中设置预设问题，ai坐席根据场景智能匹配您的预设问题，进行智能回答。</li></ul><br><h3>视频教程</h3><ul><li>- 点击下方链接观看视频教程。</li><li>- <a href="https://www.bilibili.com/video/BV1HKAyebESp" style="color:#5fb29f;" target="_blank">AI工作猎手使用教程</a></li></ul><br><h3>常见问题</h3><ul><li>- 在boss更新简历之后，请重新导入简历。</li><li>- 脚本未运行时，请尝试刷新页面。</li><li>- ai回复需要一定时间，请耐心等待。</li></ul><hr>', 23);
      const _hoisted_25 = [
        _hoisted_2$3
      ];
      const _sfc_main$5 = /* @__PURE__ */ defineComponent({
        __name: "UseDocument",
        setup(__props, { expose: __expose }) {
          __expose({ frontmatter: { "title": "使用文档", "date": "2021-08-11T02:17:52.000Z", "draft": false, "weight": 1 }, excerpt: void 0 });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", _hoisted_1$4, _hoisted_25);
          };
        }
      });
      const _hoisted_1$3 = { class: "markdown-container" };
      const _sfc_main$4 = /* @__PURE__ */ defineComponent({
        __name: "UseDocument",
        setup(__props) {
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", _hoisted_1$3, [
              createVNode(unref(_sfc_main$5))
            ]);
          };
        }
      });
      const ReadMe = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-65b48a9b"]]);
      const _withScopeId$1 = (n) => (pushScopeId("data-v-41595ce0"), n = n(), popScopeId(), n);
      const _hoisted_1$2 = { class: "container" };
      const _hoisted_2$2 = { class: "card-header" };
      const _hoisted_3$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createElementVNode("h3", null, "邀请码", -1));
      const _hoisted_4$1 = { style: { "display": "flex" } };
      const _hoisted_5$1 = { style: { "margin-right": "15px", "font-size": "14px", "color": "#909399" } };
      const _hoisted_6$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createElementVNode("h3", null, "产品兑换", -1));
      const _hoisted_7$1 = { class: "grid-content ep-bg-purple" };
      const _hoisted_8$1 = { class: "grid-content ep-bg-purple-light" };
      const _hoisted_9$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createElementVNode("div", { class: "card-header" }, [
        /* @__PURE__ */ createElementVNode("h3", null, "产品试用"),
        /* @__PURE__ */ createElementVNode("h3", null, "邀请列表")
      ], -1));
      const _hoisted_10$1 = { class: "grid-content ep-bg-purple" };
      const _hoisted_11$1 = { class: "grid-content ep-bg-purple-light" };
      const _sfc_main$3 = /* @__PURE__ */ defineComponent({
        __name: "InvitationExchange",
        setup(__props) {
          const axios2 = inject("$axios");
          const userStore = UserStore();
          let bindInviteCode = ref(userStore.user.bindInviteCode);
          let bindInviteCodeStatus = ref(!!userStore.user.bindInviteCode);
          const trialList = ref([]);
          const inviteList = ref([]);
          const activeTrialsCount = ref(0);
          onMounted(async () => {
            await fetchTrialList();
            await fetchInviteList();
          });
          const fetchTrialList = async () => {
            try {
              const response = await axios2.get("/api/user/trial/aiSeat/list");
              trialList.value = response.data.data;
            } catch (error) {
              logger$1.error("Failed to fetch trial list", error);
            }
          };
          const fetchInviteList = async () => {
            try {
              const response = await axios2.post("/api/user/invites/list");
              inviteList.value = response.data.data;
              activeTrialsCount.value = inviteList.value.filter((trial) => trial.status === 1).length;
            } catch (error) {
              logger$1.error("Failed to fetch invite list", error);
            }
          };
          const bindInvite = async () => {
            try {
              let param = `?inviteCode=${bindInviteCode.value}&name=${Tools.window._PAGE.name}`;
              await axios2.post("/api/user/invites/bind/code" + param);
              userStore.user.bindInviteCode = bindInviteCode.value;
              ElNotification({
                message: "绑定邀请码成功",
                type: "success",
                duration: 2e3
              });
              bindInviteCodeStatus.value = true;
            } catch (error) {
              logger$1.error("Failed to bind invite code", error);
              ElNotification({
                message: error,
                type: "error",
                duration: 2e3
              });
            }
          };
          const exchangeProduct = async (productId) => {
            try {
              let param = `?product=${productId}`;
              await axios2.post("/api/user/invites/exchange/products" + param);
              ElNotification({
                message: "产品兑换成功;请前往AI助手页面打开",
                type: "success",
                duration: 3e3
              });
              if (productId === -1) {
                await fetchTrialList();
              }
              await fetchInviteList();
            } catch (error) {
              ElNotification({
                message: error,
                type: "error",
                duration: 2e3
              });
            }
          };
          return (_ctx, _cache) => {
            const _component_el_text = ElText;
            const _component_el_input = ElInput;
            const _component_el_form_item = ElFormItem;
            const _component_el_button = ElButton;
            const _component_el_form = ElForm;
            const _component_el_col = ElCol;
            const _component_el_popconfirm = ElPopconfirm;
            const _component_el_button_group = ElButtonGroup;
            const _component_el_row = ElRow;
            const _component_el_card = ElCard;
            const _component_el_tag = ElTag;
            const _component_el_table_column = ElTableColumn;
            const _component_el_table = ElTable;
            return openBlock(), createElementBlock("div", _hoisted_1$2, [
              createVNode(_component_el_card, { class: "box-card" }, {
                header: withCtx(() => [
                  createElementVNode("div", _hoisted_2$2, [
                    _hoisted_3$1,
                    createElementVNode("div", _hoisted_4$1, [
                      createElementVNode("span", _hoisted_5$1, " 当前可兑换邀请人数: " + toDisplayString(activeTrialsCount.value), 1),
                      _hoisted_6$1
                    ])
                  ])
                ]),
                default: withCtx(() => [
                  createVNode(_component_el_row, null, {
                    default: withCtx(() => [
                      createVNode(_component_el_col, { span: 12 }, {
                        default: withCtx(() => [
                          createElementVNode("div", _hoisted_7$1, [
                            createVNode(_component_el_text, { class: "info-item" }, {
                              default: withCtx(() => [
                                createTextVNode("您的邀请码: " + toDisplayString(unref(userStore).user.inviteCode), 1)
                              ]),
                              _: 1
                            }),
                            createVNode(_component_el_form, {
                              inline: true,
                              class: "bind-form"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_form_item, { label: "绑定邀请码" }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_input, {
                                      modelValue: unref(bindInviteCode),
                                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(bindInviteCode) ? bindInviteCode.value = $event : bindInviteCode = $event),
                                      placeholder: "请输入邀请码",
                                      clearable: unref(bindInviteCodeStatus),
                                      disabled: unref(bindInviteCodeStatus)
                                    }, null, 8, ["modelValue", "clearable", "disabled"])
                                  ]),
                                  _: 1
                                }),
                                createVNode(_component_el_form_item, null, {
                                  default: withCtx(() => [
                                    !unref(bindInviteCodeStatus) ? (openBlock(), createBlock(_component_el_button, {
                                      key: 0,
                                      type: "primary",
                                      onClick: bindInvite
                                    }, {
                                      default: withCtx(() => [
                                        createTextVNode(" 立即绑定 ")
                                      ]),
                                      _: 1
                                    })) : createCommentVNode("", true)
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            })
                          ])
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_col, { span: 12 }, {
                        default: withCtx(() => [
                          createElementVNode("div", _hoisted_8$1, [
                            createVNode(_component_el_button_group, {
                              class: "exchange-group",
                              style: { "justify-content": "flex-end" }
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_popconfirm, {
                                  class: "box-item",
                                  title: "即将兑换，将归档1位邀请用户",
                                  placement: "top",
                                  onConfirm: _cache[1] || (_cache[1] = ($event) => exchangeProduct(-1))
                                }, {
                                  reference: withCtx(() => [
                                    createVNode(_component_el_button, {
                                      type: "primary",
                                      disabled: activeTrialsCount.value < 1
                                    }, {
                                      default: withCtx(() => [
                                        createTextVNode(" 兑换50次AI坐席 (邀请1人) ")
                                      ]),
                                      _: 1
                                    }, 8, ["disabled"])
                                  ]),
                                  _: 1
                                }),
                                createVNode(_component_el_popconfirm, {
                                  class: "box-item",
                                  title: "即将兑换，将归档2位邀请用户",
                                  placement: "top",
                                  onConfirm: _cache[2] || (_cache[2] = ($event) => exchangeProduct(1))
                                }, {
                                  reference: withCtx(() => [
                                    createVNode(_component_el_button, {
                                      type: "primary",
                                      disabled: activeTrialsCount.value < 2
                                    }, {
                                      default: withCtx(() => [
                                        createTextVNode(" 兑换1天尝鲜版 (邀请2人) ")
                                      ]),
                                      _: 1
                                    }, 8, ["disabled"])
                                  ]),
                                  _: 1
                                }),
                                createVNode(_component_el_popconfirm, {
                                  class: "box-item",
                                  title: "即将兑换，将归档4位邀请用户",
                                  placement: "top",
                                  onConfirm: _cache[3] || (_cache[3] = ($event) => exchangeProduct(2))
                                }, {
                                  reference: withCtx(() => [
                                    createVNode(_component_el_button, {
                                      type: "primary",
                                      disabled: activeTrialsCount.value < 4
                                    }, {
                                      default: withCtx(() => [
                                        createTextVNode(" 兑换7天基础版 (邀请4人) ")
                                      ]),
                                      _: 1
                                    }, 8, ["disabled"])
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            })
                          ])
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              createVNode(_component_el_card, { class: "box-card" }, {
                header: withCtx(() => [
                  _hoisted_9$1
                ]),
                default: withCtx(() => [
                  createVNode(_component_el_row, null, {
                    default: withCtx(() => [
                      createVNode(_component_el_col, { span: 12 }, {
                        default: withCtx(() => [
                          createElementVNode("div", _hoisted_10$1, [
                            createVNode(_component_el_table, {
                              data: trialList.value,
                              style: { "width": "100%" }
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_table_column, {
                                  prop: "productType",
                                  label: "产品类型",
                                  width: "120"
                                }, {
                                  default: withCtx(({ row }) => [
                                    createVNode(_component_el_tag, { type: "danger" }, {
                                      default: withCtx(() => [
                                        createTextVNode("AI坐席")
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 1
                                }),
                                createVNode(_component_el_table_column, {
                                  prop: "trialCount",
                                  label: "剩余额度",
                                  width: "120"
                                }),
                                createVNode(_component_el_table_column, {
                                  prop: "desc",
                                  label: "描述",
                                  width: "140"
                                })
                              ]),
                              _: 1
                            }, 8, ["data"])
                          ])
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_col, { span: 12 }, {
                        default: withCtx(() => [
                          createElementVNode("div", _hoisted_11$1, [
                            createVNode(_component_el_table, {
                              data: inviteList.value,
                              style: { "width": "100%" }
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_table_column, {
                                  prop: "beInviteeUsername",
                                  label: "用户名",
                                  width: "120"
                                }),
                                createVNode(_component_el_table_column, {
                                  label: "状态",
                                  width: "120"
                                }, {
                                  default: withCtx(({ row }) => [
                                    createVNode(_component_el_tag, {
                                      type: row.status === 1 ? "success" : "info"
                                    }, {
                                      default: withCtx(() => [
                                        createTextVNode(toDisplayString(row.status === 1 ? "正常" : "归档"), 1)
                                      ]),
                                      _: 2
                                    }, 1032, ["type"])
                                  ]),
                                  _: 1
                                }),
                                createVNode(_component_el_table_column, {
                                  prop: "createdDate",
                                  label: "绑定时间",
                                  width: "160"
                                })
                              ]),
                              _: 1
                            }, 8, ["data"])
                          ])
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]);
          };
        }
      });
      const InvitationExchange = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-41595ce0"]]);
      const _withScopeId = (n) => (pushScopeId("data-v-c984eb47"), n = n(), popScopeId(), n);
      const _hoisted_1$1 = { class: "ai-config" };
      const _hoisted_2$1 = { class: "tune-form" };
      const _hoisted_3 = { style: { "display": "flex" } };
      const _hoisted_4 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("span", { class: "unit" }, "秒", -1));
      const _hoisted_5 = { class: "chat-history" };
      const _hoisted_6 = { class: "bubble" };
      const _hoisted_7 = { class: "meta" };
      const _hoisted_8 = { class: "content" };
      const _hoisted_9 = {
        key: 0,
        class: "tags"
      };
      const _hoisted_10 = { class: "chat-composer" };
      const _hoisted_11 = { class: "composer-input" };
      const _sfc_main$2 = /* @__PURE__ */ defineComponent({
        __name: "AiConfig",
        setup(__props) {
          const providerOptions = [
            { label: "自定义", value: 0 },
            { label: "Deepseek", value: 1 },
            { label: "火山引擎", value: 2 },
            { label: "硅基流动", value: 3 },
            { label: "月之暗面", value: 4 },
            { label: "Open Router", value: 5 }
          ];
          const modelOptions = {
            0: [],
            // Custom
            1: ["deepseek-chat", "deepseek-reasoner"],
            2: ["deepseek-r1-250120", "..."],
            3: ["deepseek-ai/DeepSeek-V3", "..."],
            4: ["moonshot-v1-8k", "moonshot-v1-32k", "moonshot-v1-128k"],
            5: ["deepseek/deepseek-chat-v3-0324:free", "..."]
          };
          const formRef = ref();
          const availableModels = ref([]);
          const providerDetails = ref({});
          const form = ref({
            userId: 0,
            provider: 1,
            modelName: "",
            apiKey: "",
            baseUrl: "",
            timeout: 60,
            completionsPath: "",
            testPassed: 0,
            status: 0,
            userPrompt: ""
          });
          const isTestLoading = ref(false);
          const activeCollapseNames = ref(["tune"]);
          const debugDialogVisible = ref(false);
          const debugQuestion = ref("");
          const isDebugLoading = ref(false);
          const debugHistory = ref([]);
          const rules2 = {
            provider: [{ required: true, message: "请选择提供商类型", trigger: "change" }],
            modelName: [
              { required: true, message: "请输入模型名称", trigger: "change" },
              {
                validator: (rule, value, callback) => {
                  if (value === "...") {
                    callback(new Error("请选择具体模型名或输入模型名称"));
                  } else {
                    callback();
                  }
                },
                trigger: "change"
              }
            ],
            apiKey: [{ required: true, message: "请输入API Key", trigger: "change" }],
            timeout: [{ required: true, message: "请输入超时时间", trigger: "change" }],
            baseUrl: [{ required: true, message: "Base URL 不能为空", trigger: "change" }]
          };
          const fetchAllProviderDetails = async () => {
            try {
              const response = await request.get("/api/user/ai/config/all/provider");
              if (response.data.code === 200) {
                const details = response.data.data;
                providerDetails.value = details.reduce((acc, detail) => {
                  acc[detail.code] = detail;
                  return acc;
                }, {});
              }
            } catch (error) {
              ElMessage({
                type: "error",
                message: "获取供应商信息失败"
              });
            }
          };
          const lastFetchedConfig = ref(null);
          const compareWithLastConfig = () => {
            if (!lastFetchedConfig.value)
              return false;
            const currentConfig = form.value;
            const normalizeCompletionsPath = (path) => {
              return !path || path.trim() === "" ? "" : path;
            };
            return currentConfig.provider === lastFetchedConfig.value.provider && currentConfig.modelName === lastFetchedConfig.value.modelName && currentConfig.apiKey === lastFetchedConfig.value.apiKey && currentConfig.baseUrl === lastFetchedConfig.value.baseUrl && normalizeCompletionsPath(currentConfig.completionsPath) === normalizeCompletionsPath(lastFetchedConfig.value.completionsPath);
          };
          const handleProviderChange = (value, keepModelName = false) => {
            availableModels.value = modelOptions[value] || [];
            if (!keepModelName) {
              form.value.modelName = "";
            }
            if (value !== 0 && providerDetails.value[value]) {
              form.value.baseUrl = providerDetails.value[value].defaultBaseUrl;
            }
            const isDataUnchanged = compareWithLastConfig();
            if (!isDataUnchanged) {
              form.value.testPassed = 0;
            }
          };
          const fetchConfig = async () => {
            const saved = localStorage.getItem('ai-job-config');
            if (saved) {
                form.value = JSON.parse(saved);
                handleProviderChange(form.value.provider, true);
            }
          };
          watch(() => ({
            provider: form.value.provider,
            modelName: form.value.modelName,
            apiKey: form.value.apiKey,
            baseUrl: form.value.baseUrl,
            completionsPath: form.value.completionsPath,
            timeout: form.value.timeout,
            status: form.value.status
          }), () => {
            var _a;
            const isDataUnchanged = compareWithLastConfig();
            if (!isDataUnchanged) {
              form.value.testPassed = 0;
            }
            if (((_a = lastFetchedConfig.value) == null ? void 0 : _a.testPassed) && isDataUnchanged) {
              form.value.testPassed = 1;
            }
          }, { deep: true });
          const handleSave = async () => {
              localStorage.setItem('ai-job-config', JSON.stringify(form.value));
              form.value.testPassed = 1; 
              ElMessage({ type: "success", message: "配置已保存至浏览器本地" });
          };
          const handleTempSave = async () => {
            if (!formRef.value)
              return;
            await formRef.value.validate(async (valid) => {
              if (valid) {
                try {
                  const { userPrompt, ...rest } = form.value;
                  const response = await request.post("/api/user/ai/config/temp/save", rest);
                  if (response.data.code === 200) {
                    ElMessage({
                      type: "success",
                      message: "保存成功"
                    });
                    await fetchConfig();
                  }
                } catch (error) {
                  ElMessage({
                    type: "error",
                    message: "保存失败"
                  });
                }
              }
            });
          };
          const handleSavePrompt = async () => {
            try {
              const resp = await request.post("/api/user/ai/config/temp/save", {
                userPrompt: form.value.userPrompt || "",
                userId: form.value.userId
              });
              if (resp.data.code === 200) {
                ElMessage({ type: "success", message: "保存成功" });
              }
            } catch (e) {
              ElMessage({ type: "error", message: "保存失败" });
            }
          };
          const handleTest = async () => {
              isTestLoading.value = true;
              try {
                  const res = await AiPower.ask("Ping", "test", {jobTitle: "测试"});
                  if(res.data.code === 200) {
                      form.value.testPassed = 1;
                      ElNotification({ title: "测试通过", type: "success" });
                  }
              } catch (e) {
                  ElNotification({ title: "测试失败", message: String(e), type: "error" });
              } finally {
                  isTestLoading.value = false;
              }
          };
          const handleStatusChange = () => {
            ElNotification({
              title: "自有ApiKey提示",
              message: "需要点击保存按钮后生效",
              type: "info",
              duration: 3e3
            });
          };
          const openDebugDialog = () => {
            debugDialogVisible.value = true;
          };
          const jobKey = ref("");
          const getJobKey = () => {
            if (jobKey.value) {
              return jobKey.value;
            }
            let key = "ask-debug-" + Tools.window._PAGE.uid + "-" + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
            jobKey.value = key;
            return key;
          };
          const handleSendDebug = async () => {
            var _a;
            if (!debugQuestion.value) {
              ElMessage({ type: "warning", message: "请输入问题" });
              return;
            }
            if (debugHistory.value.length >= 20) {
              ElMessage({ type: "warning", message: "总对话长度不能超过20条，请先清空历史消息重试" });
              return;
            }
            const question = debugQuestion.value;
            debugHistory.value.push({ role: "user", content: question });
            debugQuestion.value = "";
            isDebugLoading.value = true;
            try {
              const payload = {
                jobKey: getJobKey(),
                question,
                jobInfo: {},
                userPrompt: form.value.userPrompt || "",
                messageList: debugHistory.value.slice(0, debugHistory.value.length - 1)
              };
              const resp = await request.post("/api/user/ai/config/debug", payload, {
                timeout: 6e4,
                headers: { "Content-Type": "application/json" }
              });
              const data = ((_a = resp == null ? void 0 : resp.data) == null ? void 0 : _a.data) || {};
              const answer = (data == null ? void 0 : data.answerContent) || "";
              const answerTypes = Array.isArray(data == null ? void 0 : data.answerTypeList) ? data.answerTypeList : [];
              const operationTypes = Array.isArray(data == null ? void 0 : data.operationTypeList) ? data.operationTypeList : [];
              debugHistory.value.push({ role: "assistant", content: answer, answerTypes, operationTypes });
            } catch (e) {
              ElMessage({ type: "error", message: "调试失败" });
            } finally {
              isDebugLoading.value = false;
            }
          };
          const handleClearHistory = () => {
            debugHistory.value = [];
            jobKey.value = "";
          };
          const mapAnswerType = (t) => {
            if (t === 0)
              return "NULL";
            if (t === 1)
              return "发送消息";
            if (t === 2)
              return "BOSS操作";
            if (t === 3)
              return "不回复当前消息";
            if (t === 4)
              return "AI服务异常";
            return String(t);
          };
          const mapOperationType = (t) => {
            if (t === 0)
              return "NULL";
            if (t === 1)
              return "发送简历";
            return String(t);
          };
          const mapRoleTitle = (role) => {
            if (role === "user")
              return "HR";
            return "AI坐席";
          };
          onMounted(() => {
            fetchAllProviderDetails();
            fetchConfig();
          });
          return (_ctx, _cache) => {
            const _component_el_input = ElInput;
            const _component_el_form_item = ElFormItem;
            const _component_el_button = ElButton;
            const _component_el_form = ElForm;
            const _component_el_collapse_item = ElCollapseItem;
            const _component_el_switch = ElSwitch;
            const _component_el_tooltip = ElTooltip;
            const _component_el_option = ElOption;
            const _component_el_select = ElSelect;
            const _component_el_input_number = ElInputNumber;
            const _component_el_collapse = ElCollapse;
            const _component_el_empty = ElEmpty;
            const _component_el_tag = ElTag;
            const _component_el_dialog = ElDialog;
            return openBlock(), createElementBlock("div", _hoisted_1$1, [
              createVNode(_component_el_collapse, {
                modelValue: activeCollapseNames.value,
                "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => activeCollapseNames.value = $event)
              }, {
                default: withCtx(() => [
                  createVNode(_component_el_collapse_item, {
                    name: "tune",
                    title: ">模型微调(点击展开收起)",
                    class: "tune-form"
                  }, {
                    default: withCtx(() => [
                      createElementVNode("div", _hoisted_2$1, [
                        createVNode(_component_el_form, { "label-width": "120px" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_form_item, { label: "用户提示词" }, {
                              default: withCtx(() => [
                                createVNode(_component_el_input, {
                                  modelValue: form.value.userPrompt,
                                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => form.value.userPrompt = $event),
                                  type: "textarea",
                                  rows: 6,
                                  maxlength: 5e3,
                                  "show-word-limit": "",
                                  placeholder: "请输入用于微调的用户提示词，将作为AI坐席的部分系统提示词使用 示例如下：\r\n## 语气风格\r\n- 使用比较轻快活泼的风格交流，同时保持积极专业的沟通态度\r\n- 避免过于正式或刻板的表达，保持对话流畅性\r\n\r\n## 信息处理\r\n- 用数据化成果突出个人价值，如完成3个百万级项目\r\n- 对薪资、到岗时间等敏感问题采用策略性回应\r\n\r\n## 以上仅作为示例写法，无实际意义\r\n"
                                }, null, 8, ["modelValue"])
                              ]),
                              _: 1
                            }),
                            createVNode(_component_el_form_item, null, {
                              default: withCtx(() => [
                                createVNode(_component_el_button, {
                                  type: "primary",
                                  onClick: handleSavePrompt
                                }, {
                                  default: withCtx(() => [
                                    createTextVNode("保存")
                                  ]),
                                  _: 1
                                }),
                                createVNode(_component_el_button, {
                                  type: "warning",
                                  onClick: openDebugDialog
                                }, {
                                  default: withCtx(() => [
                                    createTextVNode("调试")
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })
                      ])
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_collapse_item, {
                    name: "api",
                    title: ">自有API(点击展开收起)",
                    class: "tune-form"
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_el_form, {
                        ref_key: "formRef",
                        ref: formRef,
                        model: form.value,
                        rules: rules2,
                        "label-width": "120px",
                        class: "config-form"
                      }, {
                        default: withCtx(() => [
                          createElementVNode("div", _hoisted_3, [
                            createVNode(_component_el_tooltip, {
                              class: "box-item",
                              effect: "dark",
                              content: "测试不通过，测试通过后才可保存生效",
                              placement: "bottom",
                              visible: !form.value.testPassed && form.value.status === 1
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_form_item, {
                                  label: "启用自有API",
                                  prop: "status"
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_switch, {
                                      modelValue: form.value.status,
                                      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => form.value.status = $event),
                                      "active-value": 1,
                                      "inactive-value": 0,
                                      onChange: handleStatusChange
                                    }, null, 8, ["modelValue"])
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            }, 8, ["visible"]),
                            createVNode(_component_el_form_item, {
                              class: "select-opt-item",
                              label: "提供商",
                              prop: "provider"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_select, {
                                  modelValue: form.value.provider,
                                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => form.value.provider = $event),
                                  placeholder: "请选择大模型提供商",
                                  onChange: handleProviderChange
                                }, {
                                  default: withCtx(() => [
                                    (openBlock(), createElementBlock(Fragment, null, renderList(providerOptions, (option) => {
                                      return createVNode(_component_el_option, {
                                        key: option.value,
                                        label: option.label,
                                        value: option.value
                                      }, null, 8, ["label", "value"]);
                                    }), 64))
                                  ]),
                                  _: 1
                                }, 8, ["modelValue"])
                              ]),
                              _: 1
                            }),
                            createVNode(_component_el_form_item, {
                              class: "select-opt-item",
                              label: "模型名称",
                              prop: "modelName"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_select, {
                                  modelValue: form.value.modelName,
                                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => form.value.modelName = $event),
                                  placeholder: "请选择或输入模型名称",
                                  filterable: "",
                                  "allow-create": "",
                                  "default-first-option": ""
                                }, {
                                  default: withCtx(() => [
                                    (openBlock(true), createElementBlock(Fragment, null, renderList(availableModels.value, (model) => {
                                      return openBlock(), createBlock(_component_el_option, {
                                        key: model,
                                        label: model,
                                        value: model
                                      }, null, 8, ["label", "value"]);
                                    }), 128))
                                  ]),
                                  _: 1
                                }, 8, ["modelValue"])
                              ]),
                              _: 1
                            })
                          ]),
                          createVNode(_component_el_form_item, {
                            label: "API KEY",
                            prop: "apiKey"
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_el_input, {
                                modelValue: form.value.apiKey,
                                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => form.value.apiKey = $event),
                                placeholder: "请输入API Key",
                                "show-password": ""
                              }, null, 8, ["modelValue"])
                            ]),
                            _: 1
                          }),
                          createVNode(_component_el_form_item, {
                            label: "BASE URL",
                            prop: "baseUrl"
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_el_input, {
                                modelValue: form.value.baseUrl,
                                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => form.value.baseUrl = $event),
                                placeholder: "选择大模型提供商自动获取BASE URL"
                              }, null, 8, ["modelValue"])
                            ]),
                            _: 1
                          }),
                          createVNode(_component_el_form_item, {
                            label: "Completions",
                            prop: "completionsPath"
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_el_input, {
                                modelValue: form.value.completionsPath,
                                "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => form.value.completionsPath = $event),
                                placeholder: "不用填写 默认：/chat/completions"
                              }, null, 8, ["modelValue"])
                            ]),
                            _: 1
                          }),
                          createVNode(_component_el_form_item, {
                            label: "超时时间",
                            prop: "timeout"
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_el_input_number, {
                                modelValue: form.value.timeout,
                                "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => form.value.timeout = $event),
                                min: 1,
                                max: 120
                              }, null, 8, ["modelValue"]),
                              _hoisted_4
                            ]),
                            _: 1
                          }),
                          createVNode(_component_el_form_item, null, {
                            default: withCtx(() => [
                              createVNode(_component_el_button, {
                                type: "info",
                                onClick: handleTempSave
                              }, {
                                default: withCtx(() => [
                                  createTextVNode("暂存")
                                ]),
                                _: 1
                              }),
                              createVNode(_component_el_button, {
                                type: "success",
                                loading: isTestLoading.value,
                                onClick: handleTest
                              }, {
                                default: withCtx(() => [
                                  createTextVNode("测试")
                                ]),
                                _: 1
                              }, 8, ["loading"]),
                              createVNode(_component_el_tooltip, {
                                class: "box-item",
                                effect: "dark",
                                content: "请先测试；测试通过后才可保存生效",
                                placement: "bottom"
                              }, {
                                default: withCtx(() => [
                                  createVNode(_component_el_button, {
                                    type: "primary",
                                    onClick: handleSave,
                                    disabled: !form.value.testPassed
                                  }, {
                                    default: withCtx(() => [
                                      createTextVNode("保存")
                                    ]),
                                    _: 1
                                  }, 8, ["disabled"])
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }, 8, ["model"])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["modelValue"]),
              createVNode(_component_el_dialog, {
                modelValue: debugDialogVisible.value,
                "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => debugDialogVisible.value = $event),
                title: "调试用户提示词",
                width: "800px"
              }, {
                footer: withCtx(() => [
                  createVNode(_component_el_button, {
                    type: "warning",
                    disabled: isDebugLoading.value || debugHistory.value.length === 0,
                    onClick: handleClearHistory
                  }, {
                    default: withCtx(() => [
                      createTextVNode("清空历史 ")
                    ]),
                    _: 1
                  }, 8, ["disabled"]),
                  createVNode(_component_el_button, {
                    onClick: _cache[10] || (_cache[10] = ($event) => debugDialogVisible.value = false)
                  }, {
                    default: withCtx(() => [
                      createTextVNode("关闭")
                    ]),
                    _: 1
                  })
                ]),
                default: withCtx(() => [
                  createElementVNode("div", _hoisted_5, [
                    withDirectives(createVNode(_component_el_empty, { description: "暂无历史消息，请在下方开始你的调试吧" }, null, 512), [
                      [vShow, debugHistory.value.length === 0]
                    ]),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(debugHistory.value, (m, idx) => {
                      return openBlock(), createElementBlock("div", {
                        key: idx,
                        class: normalizeClass(["chat-row", m.role === "user" ? "from-user" : "from-ai"])
                      }, [
                        createElementVNode("div", _hoisted_6, [
                          createElementVNode("div", _hoisted_7, toDisplayString(mapRoleTitle(m.role)), 1),
                          createElementVNode("div", _hoisted_8, toDisplayString(m.content), 1),
                          m.role === "assistant" ? (openBlock(), createElementBlock("div", _hoisted_9, [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(m.answerTypes || [], (t, i) => {
                              return openBlock(), createBlock(_component_el_tag, {
                                key: "a-" + i,
                                size: "small",
                                type: "info"
                              }, {
                                default: withCtx(() => [
                                  createTextVNode(toDisplayString(mapAnswerType(t)), 1)
                                ]),
                                _: 2
                              }, 1024);
                            }), 128)),
                            (openBlock(true), createElementBlock(Fragment, null, renderList(m.operationTypes || [], (t, i) => {
                              return openBlock(), createBlock(_component_el_tag, {
                                key: "o-" + i,
                                size: "small",
                                type: "success"
                              }, {
                                default: withCtx(() => [
                                  createTextVNode(toDisplayString(mapOperationType(t)), 1)
                                ]),
                                _: 2
                              }, 1024);
                            }), 128))
                          ])) : createCommentVNode("", true)
                        ])
                      ], 2);
                    }), 128))
                  ]),
                  createElementVNode("div", _hoisted_10, [
                    createElementVNode("div", _hoisted_11, [
                      createVNode(_component_el_input, {
                        modelValue: debugQuestion.value,
                        "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => debugQuestion.value = $event),
                        type: "textarea",
                        autosize: { minRows: 3, maxRows: 8 },
                        maxlength: 5e3,
                        "show-word-limit": "",
                        placeholder: "作为招聘的HR角色提出你的问题,AI坐席将结合你的偏好设置与微调提示词给出最终回答",
                        clearable: ""
                      }, null, 8, ["modelValue"]),
                      createVNode(_component_el_button, {
                        class: "send-btn",
                        type: "primary",
                        loading: isDebugLoading.value,
                        onClick: handleSendDebug
                      }, {
                        default: withCtx(() => [
                          createTextVNode("发送 ")
                        ]),
                        _: 1
                      }, 8, ["loading"])
                    ])
                  ])
                ]),
                _: 1
              }, 8, ["modelValue"])
            ]);
          };
        }
      });
      const AiConfig = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-c984eb47"]]);
      const _hoisted_1 = { class: "container" };
      const _hoisted_2 = { class: "show-component" };
      const _sfc_main$1 = /* @__PURE__ */ defineComponent({
        __name: "Panel",
        setup(__props) {
          const showComponent = shallowRef(AiJob);
          const componentMap = /* @__PURE__ */ new Map();
          componentMap.set("1", { component: AiJob, name: "AI 助手" });
          componentMap.set("2", { component: Preference, name: "偏好设置" });
          componentMap.set("3", { component: RunRecord, name: "运行记录" });
          componentMap.set("4", { component: AiConfig, name: "AI 配置" });
          componentMap.set("6", { component: ReadMe, name: "使用文档" });
          const handleSelect = (key, keyPath) => {
            var _a;
            showComponent.value = (_a = componentMap.get(key)) == null ? void 0 : _a.component;
          };
          return (_ctx, _cache) => {
            const _component_el_menu_item = ElMenuItem;
            const _component_el_menu = ElMenu;
            return openBlock(), createElementBlock("div", _hoisted_1, [
              createVNode(_component_el_menu, {
                "default-active": "1",
                class: "el-menu-demo",
                mode: "horizontal",
                style: { "margin-left": "30px" },
                onSelect: handleSelect
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(componentMap).entries(), ([key, value]) => {
                    return openBlock(), createBlock(_component_el_menu_item, {
                      index: key,
                      key
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(value.name), 1)
                      ]),
                      _: 2
                    }, 1032, ["index"]);
                  }), 128))
                ]),
                _: 1
              }),
              createElementVNode("div", _hoisted_2, [
                (openBlock(), createBlock(resolveDynamicComponent(showComponent.value)))
              ])
            ]);
          };
        }
      });
      const Panel = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-3c51f398"]]);
      const _sfc_main = exports("default", /* @__PURE__ */ defineComponent({
        __name: "BossJobList",
        setup(__props) {
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Panel);
          };
        }
      }));

    })
  };
}));

System.import("./__entry.js", "./");